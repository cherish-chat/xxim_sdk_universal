// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `third.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

/// SmsCodeSendReq 发送短信请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SmsCodeSendReq)
pub struct SmsCodeSendReq {
    // message fields
    // @@protoc_insertion_point(field:pb.SmsCodeSendReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// 手机号
    // @@protoc_insertion_point(field:pb.SmsCodeSendReq.phone)
    pub phone: ::std::string::String,
    /// 手机国家区号
    // @@protoc_insertion_point(field:pb.SmsCodeSendReq.phoneCode)
    pub phoneCode: ::std::string::String,
    /// 短信场景
    // @@protoc_insertion_point(field:pb.SmsCodeSendReq.scene)
    pub scene: ::std::string::String,
    /// 过期时间
    // @@protoc_insertion_point(field:pb.SmsCodeSendReq.expireTime)
    pub expireTime: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SmsCodeSendReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmsCodeSendReq {
    fn default() -> &'a SmsCodeSendReq {
        <SmsCodeSendReq as ::protobuf::Message>::default_instance()
    }
}

impl SmsCodeSendReq {
    pub fn new() -> SmsCodeSendReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &SmsCodeSendReq| { &m.header },
            |m: &mut SmsCodeSendReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phone",
            |m: &SmsCodeSendReq| { &m.phone },
            |m: &mut SmsCodeSendReq| { &mut m.phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phoneCode",
            |m: &SmsCodeSendReq| { &m.phoneCode },
            |m: &mut SmsCodeSendReq| { &mut m.phoneCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &SmsCodeSendReq| { &m.scene },
            |m: &mut SmsCodeSendReq| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expireTime",
            |m: &SmsCodeSendReq| { &m.expireTime },
            |m: &mut SmsCodeSendReq| { &mut m.expireTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SmsCodeSendReq>(
            "SmsCodeSendReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SmsCodeSendReq {
    const NAME: &'static str = "SmsCodeSendReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.phone = is.read_string()?;
                },
                26 => {
                    self.phoneCode = is.read_string()?;
                },
                34 => {
                    self.scene = is.read_string()?;
                },
                40 => {
                    self.expireTime = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.phone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.phone);
        }
        if !self.phoneCode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.phoneCode);
        }
        if !self.scene.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.scene);
        }
        if let Some(v) = self.expireTime {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.phone.is_empty() {
            os.write_string(2, &self.phone)?;
        }
        if !self.phoneCode.is_empty() {
            os.write_string(3, &self.phoneCode)?;
        }
        if !self.scene.is_empty() {
            os.write_string(4, &self.scene)?;
        }
        if let Some(v) = self.expireTime {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmsCodeSendReq {
        SmsCodeSendReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.phone.clear();
        self.phoneCode.clear();
        self.scene.clear();
        self.expireTime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmsCodeSendReq {
        static instance: SmsCodeSendReq = SmsCodeSendReq {
            header: ::protobuf::MessageField::none(),
            phone: ::std::string::String::new(),
            phoneCode: ::std::string::String::new(),
            scene: ::std::string::String::new(),
            expireTime: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SmsCodeSendReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SmsCodeSendReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SmsCodeSendReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsCodeSendReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// SmsCodeSendResp 发送短信响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SmsCodeSendResp)
pub struct SmsCodeSendResp {
    // message fields
    // @@protoc_insertion_point(field:pb.SmsCodeSendResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SmsCodeSendResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmsCodeSendResp {
    fn default() -> &'a SmsCodeSendResp {
        <SmsCodeSendResp as ::protobuf::Message>::default_instance()
    }
}

impl SmsCodeSendResp {
    pub fn new() -> SmsCodeSendResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &SmsCodeSendResp| { &m.header },
            |m: &mut SmsCodeSendResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SmsCodeSendResp>(
            "SmsCodeSendResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SmsCodeSendResp {
    const NAME: &'static str = "SmsCodeSendResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmsCodeSendResp {
        SmsCodeSendResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmsCodeSendResp {
        static instance: SmsCodeSendResp = SmsCodeSendResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SmsCodeSendResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SmsCodeSendResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SmsCodeSendResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsCodeSendResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// SmsCodeVerifyReq 验证短信请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SmsCodeVerifyReq)
pub struct SmsCodeVerifyReq {
    // message fields
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// 手机号
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyReq.phone)
    pub phone: ::std::string::String,
    /// 手机国家区号
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyReq.phoneCode)
    pub phoneCode: ::std::string::String,
    /// 短信场景
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyReq.scene)
    pub scene: ::std::string::String,
    /// 验证码
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyReq.smsCode)
    pub smsCode: ::std::string::String,
    /// 是否立刻删除 删除后再次验证会失败
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyReq.delete)
    pub delete: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SmsCodeVerifyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmsCodeVerifyReq {
    fn default() -> &'a SmsCodeVerifyReq {
        <SmsCodeVerifyReq as ::protobuf::Message>::default_instance()
    }
}

impl SmsCodeVerifyReq {
    pub fn new() -> SmsCodeVerifyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &SmsCodeVerifyReq| { &m.header },
            |m: &mut SmsCodeVerifyReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phone",
            |m: &SmsCodeVerifyReq| { &m.phone },
            |m: &mut SmsCodeVerifyReq| { &mut m.phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phoneCode",
            |m: &SmsCodeVerifyReq| { &m.phoneCode },
            |m: &mut SmsCodeVerifyReq| { &mut m.phoneCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &SmsCodeVerifyReq| { &m.scene },
            |m: &mut SmsCodeVerifyReq| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "smsCode",
            |m: &SmsCodeVerifyReq| { &m.smsCode },
            |m: &mut SmsCodeVerifyReq| { &mut m.smsCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete",
            |m: &SmsCodeVerifyReq| { &m.delete },
            |m: &mut SmsCodeVerifyReq| { &mut m.delete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SmsCodeVerifyReq>(
            "SmsCodeVerifyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SmsCodeVerifyReq {
    const NAME: &'static str = "SmsCodeVerifyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.phone = is.read_string()?;
                },
                26 => {
                    self.phoneCode = is.read_string()?;
                },
                34 => {
                    self.scene = is.read_string()?;
                },
                42 => {
                    self.smsCode = is.read_string()?;
                },
                48 => {
                    self.delete = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.phone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.phone);
        }
        if !self.phoneCode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.phoneCode);
        }
        if !self.scene.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.scene);
        }
        if !self.smsCode.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.smsCode);
        }
        if self.delete != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.phone.is_empty() {
            os.write_string(2, &self.phone)?;
        }
        if !self.phoneCode.is_empty() {
            os.write_string(3, &self.phoneCode)?;
        }
        if !self.scene.is_empty() {
            os.write_string(4, &self.scene)?;
        }
        if !self.smsCode.is_empty() {
            os.write_string(5, &self.smsCode)?;
        }
        if self.delete != false {
            os.write_bool(6, self.delete)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmsCodeVerifyReq {
        SmsCodeVerifyReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.phone.clear();
        self.phoneCode.clear();
        self.scene.clear();
        self.smsCode.clear();
        self.delete = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmsCodeVerifyReq {
        static instance: SmsCodeVerifyReq = SmsCodeVerifyReq {
            header: ::protobuf::MessageField::none(),
            phone: ::std::string::String::new(),
            phoneCode: ::std::string::String::new(),
            scene: ::std::string::String::new(),
            smsCode: ::std::string::String::new(),
            delete: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SmsCodeVerifyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SmsCodeVerifyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SmsCodeVerifyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsCodeVerifyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// SmsCodeVerifyResp 验证短信响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SmsCodeVerifyResp)
pub struct SmsCodeVerifyResp {
    // message fields
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.SmsCodeVerifyResp.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SmsCodeVerifyResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmsCodeVerifyResp {
    fn default() -> &'a SmsCodeVerifyResp {
        <SmsCodeVerifyResp as ::protobuf::Message>::default_instance()
    }
}

impl SmsCodeVerifyResp {
    pub fn new() -> SmsCodeVerifyResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &SmsCodeVerifyResp| { &m.header },
            |m: &mut SmsCodeVerifyResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &SmsCodeVerifyResp| { &m.success },
            |m: &mut SmsCodeVerifyResp| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SmsCodeVerifyResp>(
            "SmsCodeVerifyResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SmsCodeVerifyResp {
    const NAME: &'static str = "SmsCodeVerifyResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmsCodeVerifyResp {
        SmsCodeVerifyResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmsCodeVerifyResp {
        static instance: SmsCodeVerifyResp = SmsCodeVerifyResp {
            header: ::protobuf::MessageField::none(),
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SmsCodeVerifyResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SmsCodeVerifyResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SmsCodeVerifyResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsCodeVerifyResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// EmailCodeSendReq 发送邮件请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.EmailCodeSendReq)
pub struct EmailCodeSendReq {
    // message fields
    // @@protoc_insertion_point(field:pb.EmailCodeSendReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// 邮件地址
    // @@protoc_insertion_point(field:pb.EmailCodeSendReq.email)
    pub email: ::std::string::String,
    /// 场景
    // @@protoc_insertion_point(field:pb.EmailCodeSendReq.scene)
    pub scene: ::std::string::String,
    /// 过期时间
    // @@protoc_insertion_point(field:pb.EmailCodeSendReq.expireTime)
    pub expireTime: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.EmailCodeSendReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmailCodeSendReq {
    fn default() -> &'a EmailCodeSendReq {
        <EmailCodeSendReq as ::protobuf::Message>::default_instance()
    }
}

impl EmailCodeSendReq {
    pub fn new() -> EmailCodeSendReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &EmailCodeSendReq| { &m.header },
            |m: &mut EmailCodeSendReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &EmailCodeSendReq| { &m.email },
            |m: &mut EmailCodeSendReq| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &EmailCodeSendReq| { &m.scene },
            |m: &mut EmailCodeSendReq| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expireTime",
            |m: &EmailCodeSendReq| { &m.expireTime },
            |m: &mut EmailCodeSendReq| { &mut m.expireTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmailCodeSendReq>(
            "EmailCodeSendReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmailCodeSendReq {
    const NAME: &'static str = "EmailCodeSendReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.email = is.read_string()?;
                },
                26 => {
                    self.scene = is.read_string()?;
                },
                32 => {
                    self.expireTime = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.email);
        }
        if !self.scene.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.scene);
        }
        if let Some(v) = self.expireTime {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.email.is_empty() {
            os.write_string(2, &self.email)?;
        }
        if !self.scene.is_empty() {
            os.write_string(3, &self.scene)?;
        }
        if let Some(v) = self.expireTime {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmailCodeSendReq {
        EmailCodeSendReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.email.clear();
        self.scene.clear();
        self.expireTime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmailCodeSendReq {
        static instance: EmailCodeSendReq = EmailCodeSendReq {
            header: ::protobuf::MessageField::none(),
            email: ::std::string::String::new(),
            scene: ::std::string::String::new(),
            expireTime: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmailCodeSendReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmailCodeSendReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmailCodeSendReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmailCodeSendReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// EmailCodeSendResp 发送邮件响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.EmailCodeSendResp)
pub struct EmailCodeSendResp {
    // message fields
    // @@protoc_insertion_point(field:pb.EmailCodeSendResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.EmailCodeSendResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmailCodeSendResp {
    fn default() -> &'a EmailCodeSendResp {
        <EmailCodeSendResp as ::protobuf::Message>::default_instance()
    }
}

impl EmailCodeSendResp {
    pub fn new() -> EmailCodeSendResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &EmailCodeSendResp| { &m.header },
            |m: &mut EmailCodeSendResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmailCodeSendResp>(
            "EmailCodeSendResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmailCodeSendResp {
    const NAME: &'static str = "EmailCodeSendResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmailCodeSendResp {
        EmailCodeSendResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmailCodeSendResp {
        static instance: EmailCodeSendResp = EmailCodeSendResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmailCodeSendResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmailCodeSendResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmailCodeSendResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmailCodeSendResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// EmailCodeVerifyReq 验证邮件请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.EmailCodeVerifyReq)
pub struct EmailCodeVerifyReq {
    // message fields
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// 邮件地址
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyReq.email)
    pub email: ::std::string::String,
    /// 场景
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyReq.scene)
    pub scene: ::std::string::String,
    /// 验证码
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyReq.emailCode)
    pub emailCode: ::std::string::String,
    /// 是否立刻删除 删除后再次验证会失败
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyReq.delete)
    pub delete: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.EmailCodeVerifyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmailCodeVerifyReq {
    fn default() -> &'a EmailCodeVerifyReq {
        <EmailCodeVerifyReq as ::protobuf::Message>::default_instance()
    }
}

impl EmailCodeVerifyReq {
    pub fn new() -> EmailCodeVerifyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &EmailCodeVerifyReq| { &m.header },
            |m: &mut EmailCodeVerifyReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &EmailCodeVerifyReq| { &m.email },
            |m: &mut EmailCodeVerifyReq| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scene",
            |m: &EmailCodeVerifyReq| { &m.scene },
            |m: &mut EmailCodeVerifyReq| { &mut m.scene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "emailCode",
            |m: &EmailCodeVerifyReq| { &m.emailCode },
            |m: &mut EmailCodeVerifyReq| { &mut m.emailCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete",
            |m: &EmailCodeVerifyReq| { &m.delete },
            |m: &mut EmailCodeVerifyReq| { &mut m.delete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmailCodeVerifyReq>(
            "EmailCodeVerifyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmailCodeVerifyReq {
    const NAME: &'static str = "EmailCodeVerifyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.email = is.read_string()?;
                },
                26 => {
                    self.scene = is.read_string()?;
                },
                34 => {
                    self.emailCode = is.read_string()?;
                },
                40 => {
                    self.delete = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.email);
        }
        if !self.scene.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.scene);
        }
        if !self.emailCode.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.emailCode);
        }
        if self.delete != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.email.is_empty() {
            os.write_string(2, &self.email)?;
        }
        if !self.scene.is_empty() {
            os.write_string(3, &self.scene)?;
        }
        if !self.emailCode.is_empty() {
            os.write_string(4, &self.emailCode)?;
        }
        if self.delete != false {
            os.write_bool(5, self.delete)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmailCodeVerifyReq {
        EmailCodeVerifyReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.email.clear();
        self.scene.clear();
        self.emailCode.clear();
        self.delete = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmailCodeVerifyReq {
        static instance: EmailCodeVerifyReq = EmailCodeVerifyReq {
            header: ::protobuf::MessageField::none(),
            email: ::std::string::String::new(),
            scene: ::std::string::String::new(),
            emailCode: ::std::string::String::new(),
            delete: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmailCodeVerifyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmailCodeVerifyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmailCodeVerifyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmailCodeVerifyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// EmailCodeVerifyResp 验证邮件响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.EmailCodeVerifyResp)
pub struct EmailCodeVerifyResp {
    // message fields
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.EmailCodeVerifyResp.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.EmailCodeVerifyResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmailCodeVerifyResp {
    fn default() -> &'a EmailCodeVerifyResp {
        <EmailCodeVerifyResp as ::protobuf::Message>::default_instance()
    }
}

impl EmailCodeVerifyResp {
    pub fn new() -> EmailCodeVerifyResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &EmailCodeVerifyResp| { &m.header },
            |m: &mut EmailCodeVerifyResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &EmailCodeVerifyResp| { &m.success },
            |m: &mut EmailCodeVerifyResp| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmailCodeVerifyResp>(
            "EmailCodeVerifyResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmailCodeVerifyResp {
    const NAME: &'static str = "EmailCodeVerifyResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmailCodeVerifyResp {
        EmailCodeVerifyResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmailCodeVerifyResp {
        static instance: EmailCodeVerifyResp = EmailCodeVerifyResp {
            header: ::protobuf::MessageField::none(),
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmailCodeVerifyResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmailCodeVerifyResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmailCodeVerifyResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmailCodeVerifyResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetCaptchaReq 获取图形验证码请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetCaptchaReq)
pub struct GetCaptchaReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// 过期时间
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.expireTime)
    pub expireTime: ::std::option::Option<i64>,
    /// 字符是否包含英文
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.includeEnglish)
    pub includeEnglish: bool,
    /// 字符是否包含数字
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.includeNumber)
    pub includeNumber: bool,
    /// 宽度
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.width)
    pub width: i32,
    /// 高度
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.height)
    pub height: i32,
    /// 字符数量
    // @@protoc_insertion_point(field:pb.GetCaptchaReq.charCount)
    pub charCount: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetCaptchaReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCaptchaReq {
    fn default() -> &'a GetCaptchaReq {
        <GetCaptchaReq as ::protobuf::Message>::default_instance()
    }
}

impl GetCaptchaReq {
    pub fn new() -> GetCaptchaReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GetCaptchaReq| { &m.header },
            |m: &mut GetCaptchaReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expireTime",
            |m: &GetCaptchaReq| { &m.expireTime },
            |m: &mut GetCaptchaReq| { &mut m.expireTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "includeEnglish",
            |m: &GetCaptchaReq| { &m.includeEnglish },
            |m: &mut GetCaptchaReq| { &mut m.includeEnglish },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "includeNumber",
            |m: &GetCaptchaReq| { &m.includeNumber },
            |m: &mut GetCaptchaReq| { &mut m.includeNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &GetCaptchaReq| { &m.width },
            |m: &mut GetCaptchaReq| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &GetCaptchaReq| { &m.height },
            |m: &mut GetCaptchaReq| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "charCount",
            |m: &GetCaptchaReq| { &m.charCount },
            |m: &mut GetCaptchaReq| { &mut m.charCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCaptchaReq>(
            "GetCaptchaReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCaptchaReq {
    const NAME: &'static str = "GetCaptchaReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.expireTime = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.includeEnglish = is.read_bool()?;
                },
                32 => {
                    self.includeNumber = is.read_bool()?;
                },
                40 => {
                    self.width = is.read_int32()?;
                },
                48 => {
                    self.height = is.read_int32()?;
                },
                56 => {
                    self.charCount = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expireTime {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if self.includeEnglish != false {
            my_size += 1 + 1;
        }
        if self.includeNumber != false {
            my_size += 1 + 1;
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.height);
        }
        if self.charCount != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.charCount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.expireTime {
            os.write_int64(2, v)?;
        }
        if self.includeEnglish != false {
            os.write_bool(3, self.includeEnglish)?;
        }
        if self.includeNumber != false {
            os.write_bool(4, self.includeNumber)?;
        }
        if self.width != 0 {
            os.write_int32(5, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(6, self.height)?;
        }
        if self.charCount != 0 {
            os.write_int32(7, self.charCount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCaptchaReq {
        GetCaptchaReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.expireTime = ::std::option::Option::None;
        self.includeEnglish = false;
        self.includeNumber = false;
        self.width = 0;
        self.height = 0;
        self.charCount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCaptchaReq {
        static instance: GetCaptchaReq = GetCaptchaReq {
            header: ::protobuf::MessageField::none(),
            expireTime: ::std::option::Option::None,
            includeEnglish: false,
            includeNumber: false,
            width: 0,
            height: 0,
            charCount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCaptchaReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCaptchaReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCaptchaReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCaptchaReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetCaptchaResp 获取图形验证码响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetCaptchaResp)
pub struct GetCaptchaResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GetCaptchaResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    /// 验证码id
    // @@protoc_insertion_point(field:pb.GetCaptchaResp.captchaId)
    pub captchaId: ::std::string::String,
    /// 图形验证码
    // @@protoc_insertion_point(field:pb.GetCaptchaResp.captchaCode)
    pub captchaCode: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetCaptchaResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCaptchaResp {
    fn default() -> &'a GetCaptchaResp {
        <GetCaptchaResp as ::protobuf::Message>::default_instance()
    }
}

impl GetCaptchaResp {
    pub fn new() -> GetCaptchaResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GetCaptchaResp| { &m.header },
            |m: &mut GetCaptchaResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "captchaId",
            |m: &GetCaptchaResp| { &m.captchaId },
            |m: &mut GetCaptchaResp| { &mut m.captchaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "captchaCode",
            |m: &GetCaptchaResp| { &m.captchaCode },
            |m: &mut GetCaptchaResp| { &mut m.captchaCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCaptchaResp>(
            "GetCaptchaResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCaptchaResp {
    const NAME: &'static str = "GetCaptchaResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.captchaId = is.read_string()?;
                },
                26 => {
                    self.captchaCode = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.captchaId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.captchaId);
        }
        if !self.captchaCode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.captchaCode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.captchaId.is_empty() {
            os.write_string(2, &self.captchaId)?;
        }
        if !self.captchaCode.is_empty() {
            os.write_string(3, &self.captchaCode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCaptchaResp {
        GetCaptchaResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.captchaId.clear();
        self.captchaCode.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCaptchaResp {
        static instance: GetCaptchaResp = GetCaptchaResp {
            header: ::protobuf::MessageField::none(),
            captchaId: ::std::string::String::new(),
            captchaCode: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCaptchaResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCaptchaResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCaptchaResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCaptchaResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CaptchaVerifyReq 验证图形验证码请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CaptchaVerifyReq)
pub struct CaptchaVerifyReq {
    // message fields
    // @@protoc_insertion_point(field:pb.CaptchaVerifyReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// 验证码id
    // @@protoc_insertion_point(field:pb.CaptchaVerifyReq.captchaId)
    pub captchaId: ::std::string::String,
    /// 验证码
    // @@protoc_insertion_point(field:pb.CaptchaVerifyReq.captchaCode)
    pub captchaCode: ::std::string::String,
    /// 是否立刻删除 删除后再次验证会失败
    // @@protoc_insertion_point(field:pb.CaptchaVerifyReq.delete)
    pub delete: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CaptchaVerifyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CaptchaVerifyReq {
    fn default() -> &'a CaptchaVerifyReq {
        <CaptchaVerifyReq as ::protobuf::Message>::default_instance()
    }
}

impl CaptchaVerifyReq {
    pub fn new() -> CaptchaVerifyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &CaptchaVerifyReq| { &m.header },
            |m: &mut CaptchaVerifyReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "captchaId",
            |m: &CaptchaVerifyReq| { &m.captchaId },
            |m: &mut CaptchaVerifyReq| { &mut m.captchaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "captchaCode",
            |m: &CaptchaVerifyReq| { &m.captchaCode },
            |m: &mut CaptchaVerifyReq| { &mut m.captchaCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete",
            |m: &CaptchaVerifyReq| { &m.delete },
            |m: &mut CaptchaVerifyReq| { &mut m.delete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CaptchaVerifyReq>(
            "CaptchaVerifyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CaptchaVerifyReq {
    const NAME: &'static str = "CaptchaVerifyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.captchaId = is.read_string()?;
                },
                26 => {
                    self.captchaCode = is.read_string()?;
                },
                32 => {
                    self.delete = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.captchaId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.captchaId);
        }
        if !self.captchaCode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.captchaCode);
        }
        if self.delete != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.captchaId.is_empty() {
            os.write_string(2, &self.captchaId)?;
        }
        if !self.captchaCode.is_empty() {
            os.write_string(3, &self.captchaCode)?;
        }
        if self.delete != false {
            os.write_bool(4, self.delete)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CaptchaVerifyReq {
        CaptchaVerifyReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.captchaId.clear();
        self.captchaCode.clear();
        self.delete = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CaptchaVerifyReq {
        static instance: CaptchaVerifyReq = CaptchaVerifyReq {
            header: ::protobuf::MessageField::none(),
            captchaId: ::std::string::String::new(),
            captchaCode: ::std::string::String::new(),
            delete: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CaptchaVerifyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CaptchaVerifyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CaptchaVerifyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaptchaVerifyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CaptchaVerifyResp 验证图形验证码响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CaptchaVerifyResp)
pub struct CaptchaVerifyResp {
    // message fields
    // @@protoc_insertion_point(field:pb.CaptchaVerifyResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.CaptchaVerifyResp.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CaptchaVerifyResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CaptchaVerifyResp {
    fn default() -> &'a CaptchaVerifyResp {
        <CaptchaVerifyResp as ::protobuf::Message>::default_instance()
    }
}

impl CaptchaVerifyResp {
    pub fn new() -> CaptchaVerifyResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &CaptchaVerifyResp| { &m.header },
            |m: &mut CaptchaVerifyResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &CaptchaVerifyResp| { &m.success },
            |m: &mut CaptchaVerifyResp| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CaptchaVerifyResp>(
            "CaptchaVerifyResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CaptchaVerifyResp {
    const NAME: &'static str = "CaptchaVerifyResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CaptchaVerifyResp {
        CaptchaVerifyResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CaptchaVerifyResp {
        static instance: CaptchaVerifyResp = CaptchaVerifyResp {
            header: ::protobuf::MessageField::none(),
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CaptchaVerifyResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CaptchaVerifyResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CaptchaVerifyResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaptchaVerifyResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bthird.proto\x12\x02pb\x1a\x0ccommon.proto\"\xb9\x01\n\x0eSmsCodeSe\
    ndReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06he\
    ader\x12\x14\n\x05phone\x18\x02\x20\x01(\tR\x05phone\x12\x1c\n\tphoneCod\
    e\x18\x03\x20\x01(\tR\tphoneCode\x12\x14\n\x05scene\x18\x04\x20\x01(\tR\
    \x05scene\x12#\n\nexpireTime\x18\x05\x20\x01(\x03H\0R\nexpireTime\x88\
    \x01\x01B\r\n\x0b_expireTime\"=\n\x0fSmsCodeSendResp\x12*\n\x06header\
    \x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"\xb9\x01\n\x10S\
    msCodeVerifyReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHea\
    derR\x06header\x12\x14\n\x05phone\x18\x02\x20\x01(\tR\x05phone\x12\x1c\n\
    \tphoneCode\x18\x03\x20\x01(\tR\tphoneCode\x12\x14\n\x05scene\x18\x04\
    \x20\x01(\tR\x05scene\x12\x18\n\x07smsCode\x18\x05\x20\x01(\tR\x07smsCod\
    e\x12\x16\n\x06delete\x18\x06\x20\x01(\x08R\x06delete\"Y\n\x11SmsCodeVer\
    ifyResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\
    \x06header\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07success\"\x9d\
    \x01\n\x10EmailCodeSendReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb\
    .RequestHeaderR\x06header\x12\x14\n\x05email\x18\x02\x20\x01(\tR\x05emai\
    l\x12\x14\n\x05scene\x18\x03\x20\x01(\tR\x05scene\x12#\n\nexpireTime\x18\
    \x04\x20\x01(\x03H\0R\nexpireTime\x88\x01\x01B\r\n\x0b_expireTime\"?\n\
    \x11EmailCodeSendResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Resp\
    onseHeaderR\x06header\"\xa1\x01\n\x12EmailCodeVerifyReq\x12)\n\x06header\
    \x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\x14\n\x05emai\
    l\x18\x02\x20\x01(\tR\x05email\x12\x14\n\x05scene\x18\x03\x20\x01(\tR\
    \x05scene\x12\x1c\n\temailCode\x18\x04\x20\x01(\tR\temailCode\x12\x16\n\
    \x06delete\x18\x05\x20\x01(\x08R\x06delete\"[\n\x13EmailCodeVerifyResp\
    \x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\
    \x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07success\"\x88\x02\n\rGetC\
    aptchaReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\
    \x06header\x12#\n\nexpireTime\x18\x02\x20\x01(\x03H\0R\nexpireTime\x88\
    \x01\x01\x12&\n\x0eincludeEnglish\x18\x03\x20\x01(\x08R\x0eincludeEnglis\
    h\x12$\n\rincludeNumber\x18\x04\x20\x01(\x08R\rincludeNumber\x12\x14\n\
    \x05width\x18\x05\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x06\x20\
    \x01(\x05R\x06height\x12\x1c\n\tcharCount\x18\x07\x20\x01(\x05R\tcharCou\
    ntB\r\n\x0b_expireTime\"|\n\x0eGetCaptchaResp\x12*\n\x06header\x18\x01\
    \x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12\x1c\n\tcaptchaId\x18\
    \x02\x20\x01(\tR\tcaptchaId\x12\x20\n\x0bcaptchaCode\x18\x03\x20\x01(\tR\
    \x0bcaptchaCode\"\x95\x01\n\x10CaptchaVerifyReq\x12)\n\x06header\x18\x01\
    \x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\x1c\n\tcaptchaId\x18\
    \x02\x20\x01(\tR\tcaptchaId\x12\x20\n\x0bcaptchaCode\x18\x03\x20\x01(\tR\
    \x0bcaptchaCode\x12\x16\n\x06delete\x18\x04\x20\x01(\x08R\x06delete\"Y\n\
    \x11CaptchaVerifyResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Resp\
    onseHeaderR\x06header\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07succ\
    ess2\x86\x01\n\nsmsService\x128\n\x0bSmsCodeSend\x12\x12.pb.SmsCodeSendR\
    eq\x1a\x13.pb.SmsCodeSendResp\"\0\x12>\n\rSmsCodeVerify\x12\x14.pb.SmsCo\
    deVerifyReq\x1a\x15.pb.SmsCodeVerifyResp\"\02\x94\x01\n\x0cemailService\
    \x12>\n\rEmailCodeSend\x12\x14.pb.EmailCodeSendReq\x1a\x15.pb.EmailCodeS\
    endResp\"\0\x12D\n\x0fEmailCodeVerify\x12\x16.pb.EmailCodeVerifyReq\x1a\
    \x17.pb.EmailCodeVerifyResp\"\02\x87\x01\n\x0ecaptchaService\x125\n\nGet\
    Captcha\x12\x11.pb.GetCaptchaReq\x1a\x12.pb.GetCaptchaResp\"\0\x12>\n\rC\
    aptchaVerify\x12\x14.pb.CaptchaVerifyReq\x1a\x15.pb.CaptchaVerifyResp\"\
    \0B\x06Z\x04./pbJ\x91%\n\x07\x12\x05\0\0\x9f\x01\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x0b\n\x08\n\x01\x08\x12\x03\
    \x02\0\x1b\n\t\n\x02\x08\x0b\x12\x03\x02\0\x1b\n\t\n\x02\x03\0\x12\x03\
    \x03\0\x16\nI\n\x02\x04\0\x12\x04\x08\0\x12\x01\x1a\"SmsCodeSendReq\x20\
    \xe5\x8f\x91\xe9\x80\x81\xe7\x9f\xad\xe4\xbf\xa1\xe8\xaf\xb7\xe6\xb1\x82\
    \n2\x19SmsCodeSend\x20\xe5\x8f\x91\xe9\x80\x81\xe7\x9f\xad\xe4\xbf\xa1\n\
    \n\n\n\x03\x04\0\x01\x12\x03\x08\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \t\x02\x1b\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\t\x02\x0f\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03\t\x10\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\t\x19\
    \x1a\n\x17\n\x04\x04\0\x02\x01\x12\x03\x0b\x02\x13\x1a\n\xe6\x89\x8b\xe6\
    \x9c\xba\xe5\x8f\xb7\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0b\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0b\t\x0e\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03\x0b\x11\x12\n\x20\n\x04\x04\0\x02\x02\x12\x03\r\x02\x17\
    \x1a\x13\xe6\x89\x8b\xe6\x9c\xba\xe5\x9b\xbd\xe5\xae\xb6\xe5\x8c\xba\xe5\
    \x8f\xb7\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\r\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x03\r\t\x12\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\
    \r\x15\x16\n\x1a\n\x04\x04\0\x02\x03\x12\x03\x0f\x02\x13\x1a\r\xe7\x9f\
    \xad\xe4\xbf\xa1\xe5\x9c\xba\xe6\x99\xaf\n\n\x0c\n\x05\x04\0\x02\x03\x05\
    \x12\x03\x0f\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x0f\t\x0e\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0f\x11\x12\n\x1a\n\x04\x04\0\x02\
    \x04\x12\x03\x11\x02\x20\x1a\r\xe8\xbf\x87\xe6\x9c\x9f\xe6\x97\xb6\xe9\
    \x97\xb4\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03\x11\x02\n\n\x0c\n\x05\
    \x04\0\x02\x04\x05\x12\x03\x11\x0b\x10\n\x0c\n\x05\x04\0\x02\x04\x01\x12\
    \x03\x11\x11\x1b\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x11\x1e\x1f\n/\n\
    \x02\x04\x01\x12\x04\x15\0\x17\x01\x1a#SmsCodeSendResp\x20\xe5\x8f\x91\
    \xe9\x80\x81\xe7\x9f\xad\xe4\xbf\xa1\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\
    \x04\x01\x01\x12\x03\x15\x08\x17\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x16\
    \x02\x1c\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x16\x02\x10\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03\x16\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03\x16\x1a\x1b\nM\n\x02\x04\x02\x12\x04\x1c\0(\x01\x1a$SmsCodeVerifyRe\
    q\x20\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9f\xad\xe4\xbf\xa1\xe8\xaf\xb7\xe6\
    \xb1\x82\n2\x1bSmsCodeVerify\x20\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9f\xad\xe4\
    \xbf\xa1\n\n\n\n\x03\x04\x02\x01\x12\x03\x1c\x08\x18\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x03\x1d\x02\x1b\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03\x1d\x02\
    \x0f\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1d\x10\x16\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03\x1d\x19\x1a\n\x17\n\x04\x04\x02\x02\x01\x12\x03\
    \x1f\x02\x13\x1a\n\xe6\x89\x8b\xe6\x9c\xba\xe5\x8f\xb7\n\n\x0c\n\x05\x04\
    \x02\x02\x01\x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x03\x1f\t\x0e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x1f\x11\x12\n\x20\
    \n\x04\x04\x02\x02\x02\x12\x03!\x02\x17\x1a\x13\xe6\x89\x8b\xe6\x9c\xba\
    \xe5\x9b\xbd\xe5\xae\xb6\xe5\x8c\xba\xe5\x8f\xb7\n\n\x0c\n\x05\x04\x02\
    \x02\x02\x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03!\t\
    \x12\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03!\x15\x16\n\x1a\n\x04\x04\
    \x02\x02\x03\x12\x03#\x02\x13\x1a\r\xe7\x9f\xad\xe4\xbf\xa1\xe5\x9c\xba\
    \xe6\x99\xaf\n\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03#\x02\x08\n\x0c\n\
    \x05\x04\x02\x02\x03\x01\x12\x03#\t\x0e\n\x0c\n\x05\x04\x02\x02\x03\x03\
    \x12\x03#\x11\x12\n\x17\n\x04\x04\x02\x02\x04\x12\x03%\x02\x15\x1a\n\xe9\
    \xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\n\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\
    \x03%\x02\x08\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03%\t\x10\n\x0c\n\x05\
    \x04\x02\x02\x04\x03\x12\x03%\x13\x14\n?\n\x04\x04\x02\x02\x05\x12\x03'\
    \x02\x12\x1a2\xe6\x98\xaf\xe5\x90\xa6\xe7\xab\x8b\xe5\x88\xbb\xe5\x88\
    \xa0\xe9\x99\xa4\x20\xe5\x88\xa0\xe9\x99\xa4\xe5\x90\x8e\xe5\x86\x8d\xe6\
    \xac\xa1\xe9\xaa\x8c\xe8\xaf\x81\xe4\xbc\x9a\xe5\xa4\xb1\xe8\xb4\xa5\n\n\
    \x0c\n\x05\x04\x02\x02\x05\x05\x12\x03'\x02\x06\n\x0c\n\x05\x04\x02\x02\
    \x05\x01\x12\x03'\x07\r\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03'\x10\x11\
    \n1\n\x02\x04\x03\x12\x04+\0.\x01\x1a%SmsCodeVerifyResp\x20\xe9\xaa\x8c\
    \xe8\xaf\x81\xe7\x9f\xad\xe4\xbf\xa1\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\
    \x04\x03\x01\x12\x03+\x08\x19\n\x0b\n\x04\x04\x03\x02\0\x12\x03,\x02\x1c\
    \n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03,\x02\x10\n\x0c\n\x05\x04\x03\x02\
    \0\x01\x12\x03,\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03,\x1a\x1b\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03-\x02\x13\n\x0c\n\x05\x04\x03\x02\x01\
    \x05\x12\x03-\x02\x06\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03-\x07\x0e\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03-\x11\x12\nM\n\x02\x04\x04\x12\x04\
    3\0;\x01\x1a$EmailCodeSendReq\x20\xe5\x8f\x91\xe9\x80\x81\xe9\x82\xae\
    \xe4\xbb\xb6\xe8\xaf\xb7\xe6\xb1\x82\n2\x1bEmailCodeSend\x20\xe5\x8f\x91\
    \xe9\x80\x81\xe9\x82\xae\xe4\xbb\xb6\n\n\n\n\x03\x04\x04\x01\x12\x033\
    \x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x034\x02\x1b\n\x0c\n\x05\x04\x04\
    \x02\0\x06\x12\x034\x02\x0f\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x034\x10\
    \x16\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x034\x19\x1a\n\x1a\n\x04\x04\x04\
    \x02\x01\x12\x036\x02\x13\x1a\r\xe9\x82\xae\xe4\xbb\xb6\xe5\x9c\xb0\xe5\
    \x9d\x80\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x036\x02\x08\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x036\t\x0e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x036\x11\x12\n\x14\n\x04\x04\x04\x02\x02\x12\x038\x02\x13\x1a\x07\xe5\
    \x9c\xba\xe6\x99\xaf\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x038\x02\x08\
    \n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x038\t\x0e\n\x0c\n\x05\x04\x04\x02\
    \x02\x03\x12\x038\x11\x12\n\x1a\n\x04\x04\x04\x02\x03\x12\x03:\x02\x20\
    \x1a\r\xe8\xbf\x87\xe6\x9c\x9f\xe6\x97\xb6\xe9\x97\xb4\n\n\x0c\n\x05\x04\
    \x04\x02\x03\x04\x12\x03:\x02\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03:\
    \x0b\x10\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03:\x11\x1b\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03:\x1e\x1f\n1\n\x02\x04\x05\x12\x04>\0@\x01\
    \x1a%EmailCodeSendResp\x20\xe5\x8f\x91\xe9\x80\x81\xe9\x82\xae\xe4\xbb\
    \xb6\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\x04\x05\x01\x12\x03>\x08\x19\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03?\x02\x1c\n\x0c\n\x05\x04\x05\x02\0\x06\
    \x12\x03?\x02\x10\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03?\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03?\x1a\x1b\nQ\n\x02\x04\x06\x12\x04E\0O\x01\
    \x1a&EmailCodeVerifyReq\x20\xe9\xaa\x8c\xe8\xaf\x81\xe9\x82\xae\xe4\xbb\
    \xb6\xe8\xaf\xb7\xe6\xb1\x82\n2\x1dEmailCodeVerify\x20\xe9\xaa\x8c\xe8\
    \xaf\x81\xe9\x82\xae\xe4\xbb\xb6\n\n\n\n\x03\x04\x06\x01\x12\x03E\x08\
    \x1a\n\x0b\n\x04\x04\x06\x02\0\x12\x03F\x02\x1b\n\x0c\n\x05\x04\x06\x02\
    \0\x06\x12\x03F\x02\x0f\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03F\x10\x16\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03F\x19\x1a\n\x1a\n\x04\x04\x06\x02\
    \x01\x12\x03H\x02\x13\x1a\r\xe9\x82\xae\xe4\xbb\xb6\xe5\x9c\xb0\xe5\x9d\
    \x80\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03H\x02\x08\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03H\t\x0e\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03H\
    \x11\x12\n\x14\n\x04\x04\x06\x02\x02\x12\x03J\x02\x13\x1a\x07\xe5\x9c\
    \xba\xe6\x99\xaf\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03J\x02\x08\n\
    \x0c\n\x05\x04\x06\x02\x02\x01\x12\x03J\t\x0e\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03J\x11\x12\n\x17\n\x04\x04\x06\x02\x03\x12\x03L\x02\x17\
    \x1a\n\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\n\n\x0c\n\x05\x04\x06\x02\x03\
    \x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03L\t\x12\n\
    \x0c\n\x05\x04\x06\x02\x03\x03\x12\x03L\x15\x16\n?\n\x04\x04\x06\x02\x04\
    \x12\x03N\x02\x12\x1a2\xe6\x98\xaf\xe5\x90\xa6\xe7\xab\x8b\xe5\x88\xbb\
    \xe5\x88\xa0\xe9\x99\xa4\x20\xe5\x88\xa0\xe9\x99\xa4\xe5\x90\x8e\xe5\x86\
    \x8d\xe6\xac\xa1\xe9\xaa\x8c\xe8\xaf\x81\xe4\xbc\x9a\xe5\xa4\xb1\xe8\xb4\
    \xa5\n\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03N\x02\x06\n\x0c\n\x05\x04\
    \x06\x02\x04\x01\x12\x03N\x07\r\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03N\
    \x10\x11\n3\n\x02\x04\x07\x12\x04R\0U\x01\x1a'EmailCodeVerifyResp\x20\
    \xe9\xaa\x8c\xe8\xaf\x81\xe9\x82\xae\xe4\xbb\xb6\xe5\x93\x8d\xe5\xba\x94\
    \n\n\n\n\x03\x04\x07\x01\x12\x03R\x08\x1b\n\x0b\n\x04\x04\x07\x02\0\x12\
    \x03S\x02\x1c\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03S\x02\x10\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03S\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03S\x1a\x1b\n\x0b\n\x04\x04\x07\x02\x01\x12\x03T\x02\x13\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03T\x02\x06\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x03T\x07\x0e\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03T\x11\x12\nY\n\
    \x02\x04\x08\x12\x04Z\0h\x01\x1a*GetCaptchaReq\x20\xe8\x8e\xb7\xe5\x8f\
    \x96\xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\xe8\xaf\
    \xb7\xe6\xb1\x82\n2!GetCaptcha\x20\xe8\x8e\xb7\xe5\x8f\x96\xe5\x9b\xbe\
    \xe5\xbd\xa2\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\n\n\n\n\x03\x04\x08\x01\
    \x12\x03Z\x08\x15\n\x0b\n\x04\x04\x08\x02\0\x12\x03[\x02\x1b\n\x0c\n\x05\
    \x04\x08\x02\0\x06\x12\x03[\x02\x0f\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03[\x10\x16\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03[\x19\x1a\n\x1a\n\x04\
    \x04\x08\x02\x01\x12\x03]\x02\x20\x1a\r\xe8\xbf\x87\xe6\x9c\x9f\xe6\x97\
    \xb6\xe9\x97\xb4\n\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03]\x02\n\n\x0c\
    \n\x05\x04\x08\x02\x01\x05\x12\x03]\x0b\x10\n\x0c\n\x05\x04\x08\x02\x01\
    \x01\x12\x03]\x11\x1b\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03]\x1e\x1f\n\
    &\n\x04\x04\x08\x02\x02\x12\x03_\x02\x1a\x1a\x19\xe5\xad\x97\xe7\xac\xa6\
    \xe6\x98\xaf\xe5\x90\xa6\xe5\x8c\x85\xe5\x90\xab\xe8\x8b\xb1\xe6\x96\x87\
    \n\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03_\x02\x06\n\x0c\n\x05\x04\x08\
    \x02\x02\x01\x12\x03_\x07\x15\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03_\
    \x18\x19\n&\n\x04\x04\x08\x02\x03\x12\x03a\x02\x19\x1a\x19\xe5\xad\x97\
    \xe7\xac\xa6\xe6\x98\xaf\xe5\x90\xa6\xe5\x8c\x85\xe5\x90\xab\xe6\x95\xb0\
    \xe5\xad\x97\n\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03a\x02\x06\n\x0c\n\
    \x05\x04\x08\x02\x03\x01\x12\x03a\x07\x14\n\x0c\n\x05\x04\x08\x02\x03\
    \x03\x12\x03a\x17\x18\n\x14\n\x04\x04\x08\x02\x04\x12\x03c\x02\x12\x1a\
    \x07\xe5\xae\xbd\xe5\xba\xa6\n\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03c\
    \x02\x07\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03c\x08\r\n\x0c\n\x05\x04\
    \x08\x02\x04\x03\x12\x03c\x10\x11\n\x14\n\x04\x04\x08\x02\x05\x12\x03e\
    \x02\x13\x1a\x07\xe9\xab\x98\xe5\xba\xa6\n\n\x0c\n\x05\x04\x08\x02\x05\
    \x05\x12\x03e\x02\x07\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\x03e\x08\x0e\n\
    \x0c\n\x05\x04\x08\x02\x05\x03\x12\x03e\x11\x12\n\x1a\n\x04\x04\x08\x02\
    \x06\x12\x03g\x02\x16\x1a\r\xe5\xad\x97\xe7\xac\xa6\xe6\x95\xb0\xe9\x87\
    \x8f\n\n\x0c\n\x05\x04\x08\x02\x06\x05\x12\x03g\x02\x07\n\x0c\n\x05\x04\
    \x08\x02\x06\x01\x12\x03g\x08\x11\n\x0c\n\x05\x04\x08\x02\x06\x03\x12\
    \x03g\x14\x15\n7\n\x02\x04\t\x12\x04k\0q\x01\x1a+GetCaptchaResp\x20\xe8\
    \x8e\xb7\xe5\x8f\x96\xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\xe8\xaf\x81\xe7\
    \xa0\x81\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\x04\t\x01\x12\x03k\x08\x16\
    \n\x0b\n\x04\x04\t\x02\0\x12\x03l\x02\x1c\n\x0c\n\x05\x04\t\x02\0\x06\
    \x12\x03l\x02\x10\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03l\x11\x17\n\x0c\n\
    \x05\x04\t\x02\0\x03\x12\x03l\x1a\x1b\n\x19\n\x04\x04\t\x02\x01\x12\x03n\
    \x02\x17\x1a\x0c\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81id\n\n\x0c\n\x05\x04\
    \t\x02\x01\x05\x12\x03n\x02\x08\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03n\t\
    \x12\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03n\x15\x16\n\x1d\n\x04\x04\t\
    \x02\x02\x12\x03p\x02\x19\x1a\x10\xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\
    \xe8\xaf\x81\xe7\xa0\x81\n\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03p\x02\
    \x08\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03p\t\x14\n\x0c\n\x05\x04\t\x02\
    \x02\x03\x12\x03p\x17\x18\n_\n\x02\x04\n\x12\x04v\0~\x01\x1a-CaptchaVeri\
    fyReq\x20\xe9\xaa\x8c\xe8\xaf\x81\xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\
    \xe8\xaf\x81\xe7\xa0\x81\xe8\xaf\xb7\xe6\xb1\x82\n2$CaptchaVerify\x20\
    \xe9\xaa\x8c\xe8\xaf\x81\xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\xe8\xaf\x81\
    \xe7\xa0\x81\n\n\n\n\x03\x04\n\x01\x12\x03v\x08\x18\n\x0b\n\x04\x04\n\
    \x02\0\x12\x03w\x02\x1b\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03w\x02\x0f\n\
    \x0c\n\x05\x04\n\x02\0\x01\x12\x03w\x10\x16\n\x0c\n\x05\x04\n\x02\0\x03\
    \x12\x03w\x19\x1a\n\x19\n\x04\x04\n\x02\x01\x12\x03y\x02\x17\x1a\x0c\xe9\
    \xaa\x8c\xe8\xaf\x81\xe7\xa0\x81id\n\n\x0c\n\x05\x04\n\x02\x01\x05\x12\
    \x03y\x02\x08\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03y\t\x12\n\x0c\n\x05\
    \x04\n\x02\x01\x03\x12\x03y\x15\x16\n\x17\n\x04\x04\n\x02\x02\x12\x03{\
    \x02\x19\x1a\n\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\n\n\x0c\n\x05\x04\n\
    \x02\x02\x05\x12\x03{\x02\x08\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03{\t\
    \x14\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03{\x17\x18\n?\n\x04\x04\n\x02\
    \x03\x12\x03}\x02\x12\x1a2\xe6\x98\xaf\xe5\x90\xa6\xe7\xab\x8b\xe5\x88\
    \xbb\xe5\x88\xa0\xe9\x99\xa4\x20\xe5\x88\xa0\xe9\x99\xa4\xe5\x90\x8e\xe5\
    \x86\x8d\xe6\xac\xa1\xe9\xaa\x8c\xe8\xaf\x81\xe4\xbc\x9a\xe5\xa4\xb1\xe8\
    \xb4\xa5\n\n\x0c\n\x05\x04\n\x02\x03\x05\x12\x03}\x02\x06\n\x0c\n\x05\
    \x04\n\x02\x03\x01\x12\x03}\x07\r\n\x0c\n\x05\x04\n\x02\x03\x03\x12\x03}\
    \x10\x11\n<\n\x02\x04\x0b\x12\x06\x81\x01\0\x84\x01\x01\x1a.CaptchaVerif\
    yResp\x20\xe9\xaa\x8c\xe8\xaf\x81\xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\
    \xe8\xaf\x81\xe7\xa0\x81\xe5\x93\x8d\xe5\xba\x94\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\x81\x01\x08\x19\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x82\x01\
    \x02\x1c\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\x82\x01\x02\x10\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x03\
    \x12\x04\x82\x01\x1a\x1b\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x83\x01\x02\
    \x13\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x83\x01\x02\x06\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\x83\x01\x07\x0e\n\r\n\x05\x04\x0b\x02\x01\x03\
    \x12\x04\x83\x01\x11\x12\n\x0c\n\x02\x06\0\x12\x06\x86\x01\0\x8d\x01\x01\
    \n\x0b\n\x03\x06\0\x01\x12\x04\x86\x01\x08\x12\nL\n\x04\x06\0\x02\0\x12\
    \x04\x89\x01\x02>\x1a>SmsCodeSend\x20\xe5\x8f\x91\xe9\x80\x81\xe7\x9f\
    \xad\xe4\xbf\xa1\n\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\
    \xba\xba\xe5\x91\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe8\x87\xaa\xe8\xa1\x8c\xe5\
    \xae\x9e\xe7\x8e\xb0\n\n\r\n\x05\x06\0\x02\0\x01\x12\x04\x89\x01\x06\x11\
    \n\r\n\x05\x06\0\x02\0\x02\x12\x04\x89\x01\x12\x20\n\r\n\x05\x06\0\x02\0\
    \x03\x12\x04\x89\x01+:\nN\n\x04\x06\0\x02\x01\x12\x04\x8c\x01\x02D\x1a@S\
    msCodeVerify\x20\xe9\xaa\x8c\xe8\xaf\x81\xe7\x9f\xad\xe4\xbf\xa1\n\xe4\
    \xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\
    \x8f\xaf\xe4\xbb\xa5\xe8\x87\xaa\xe8\xa1\x8c\xe5\xae\x9e\xe7\x8e\xb0\n\n\
    \r\n\x05\x06\0\x02\x01\x01\x12\x04\x8c\x01\x06\x13\n\r\n\x05\x06\0\x02\
    \x01\x02\x12\x04\x8c\x01\x14$\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\x8c\
    \x01/@\n\x0c\n\x02\x06\x01\x12\x06\x8f\x01\0\x96\x01\x01\n\x0b\n\x03\x06\
    \x01\x01\x12\x04\x8f\x01\x08\x14\nN\n\x04\x06\x01\x02\0\x12\x04\x92\x01\
    \x02D\x1a@EmailCodeSend\x20\xe5\x8f\x91\xe9\x80\x81\xe9\x82\xae\xe4\xbb\
    \xb6\n\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\
    \x91\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe8\x87\xaa\xe8\xa1\x8c\xe5\xae\x9e\xe7\
    \x8e\xb0\n\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\x92\x01\x06\x13\n\r\n\x05\
    \x06\x01\x02\0\x02\x12\x04\x92\x01\x14$\n\r\n\x05\x06\x01\x02\0\x03\x12\
    \x04\x92\x01/@\nP\n\x04\x06\x01\x02\x01\x12\x04\x95\x01\x02J\x1aBEmailCo\
    deVerify\x20\xe9\xaa\x8c\xe8\xaf\x81\xe9\x82\xae\xe4\xbb\xb6\n\xe4\xba\
    \x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\x8f\
    \xaf\xe4\xbb\xa5\xe8\x87\xaa\xe8\xa1\x8c\xe5\xae\x9e\xe7\x8e\xb0\n\n\r\n\
    \x05\x06\x01\x02\x01\x01\x12\x04\x95\x01\x06\x15\n\r\n\x05\x06\x01\x02\
    \x01\x02\x12\x04\x95\x01\x16(\n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\x95\
    \x013F\n\x0c\n\x02\x06\x02\x12\x06\x98\x01\0\x9f\x01\x01\n\x0b\n\x03\x06\
    \x02\x01\x12\x04\x98\x01\x08\x16\nT\n\x04\x06\x02\x02\0\x12\x04\x9b\x01\
    \x02;\x1aFGetCaptcha\x20\xe8\x8e\xb7\xe5\x8f\x96\xe5\x9b\xbe\xe5\xbd\xa2\
    \xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\n\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\
    \x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe8\x87\
    \xaa\xe8\xa1\x8c\xe5\xae\x9e\xe7\x8e\xb0\n\n\r\n\x05\x06\x02\x02\0\x01\
    \x12\x04\x9b\x01\x06\x10\n\r\n\x05\x06\x02\x02\0\x02\x12\x04\x9b\x01\x11\
    \x1e\n\r\n\x05\x06\x02\x02\0\x03\x12\x04\x9b\x01)7\nW\n\x04\x06\x02\x02\
    \x01\x12\x04\x9e\x01\x02D\x1aICaptchaVerify\x20\xe9\xaa\x8c\xe8\xaf\x81\
    \xe5\x9b\xbe\xe5\xbd\xa2\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\n\xe4\xba\
    \x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\x8f\
    \xaf\xe4\xbb\xa5\xe8\x87\xaa\xe8\xa1\x8c\xe5\xae\x9e\xe7\x8e\xb0\n\n\r\n\
    \x05\x06\x02\x02\x01\x01\x12\x04\x9e\x01\x06\x13\n\r\n\x05\x06\x02\x02\
    \x01\x02\x12\x04\x9e\x01\x14$\n\r\n\x05\x06\x02\x02\x01\x03\x12\x04\x9e\
    \x01/@b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(SmsCodeSendReq::generated_message_descriptor_data());
            messages.push(SmsCodeSendResp::generated_message_descriptor_data());
            messages.push(SmsCodeVerifyReq::generated_message_descriptor_data());
            messages.push(SmsCodeVerifyResp::generated_message_descriptor_data());
            messages.push(EmailCodeSendReq::generated_message_descriptor_data());
            messages.push(EmailCodeSendResp::generated_message_descriptor_data());
            messages.push(EmailCodeVerifyReq::generated_message_descriptor_data());
            messages.push(EmailCodeVerifyResp::generated_message_descriptor_data());
            messages.push(GetCaptchaReq::generated_message_descriptor_data());
            messages.push(GetCaptchaResp::generated_message_descriptor_data());
            messages.push(CaptchaVerifyReq::generated_message_descriptor_data());
            messages.push(CaptchaVerifyResp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
