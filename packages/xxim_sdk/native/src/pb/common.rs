// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `common.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

/// RequestHeader 请求头
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.RequestHeader)
pub struct RequestHeader {
    // message fields
    // @@protoc_insertion_point(field:pb.RequestHeader.appId)
    pub appId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.clientIp)
    pub clientIp: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.installId)
    pub installId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.platform)
    pub platform: ::protobuf::EnumOrUnknown<Platform>,
    // @@protoc_insertion_point(field:pb.RequestHeader.deviceModel)
    pub deviceModel: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.osVersion)
    pub osVersion: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.appVersion)
    pub appVersion: ::std::string::String,
    // @@protoc_insertion_point(field:pb.RequestHeader.extra)
    pub extra: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.RequestHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestHeader {
    fn default() -> &'a RequestHeader {
        <RequestHeader as ::protobuf::Message>::default_instance()
    }
}

impl RequestHeader {
    pub fn new() -> RequestHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "appId",
            |m: &RequestHeader| { &m.appId },
            |m: &mut RequestHeader| { &mut m.appId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &RequestHeader| { &m.userId },
            |m: &mut RequestHeader| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clientIp",
            |m: &RequestHeader| { &m.clientIp },
            |m: &mut RequestHeader| { &mut m.clientIp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installId",
            |m: &RequestHeader| { &m.installId },
            |m: &mut RequestHeader| { &mut m.installId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform",
            |m: &RequestHeader| { &m.platform },
            |m: &mut RequestHeader| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deviceModel",
            |m: &RequestHeader| { &m.deviceModel },
            |m: &mut RequestHeader| { &mut m.deviceModel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "osVersion",
            |m: &RequestHeader| { &m.osVersion },
            |m: &mut RequestHeader| { &mut m.osVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "appVersion",
            |m: &RequestHeader| { &m.appVersion },
            |m: &mut RequestHeader| { &mut m.appVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra",
            |m: &RequestHeader| { &m.extra },
            |m: &mut RequestHeader| { &mut m.extra },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestHeader>(
            "RequestHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestHeader {
    const NAME: &'static str = "RequestHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.appId = is.read_string()?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                26 => {
                    self.clientIp = is.read_string()?;
                },
                34 => {
                    self.installId = is.read_string()?;
                },
                40 => {
                    self.platform = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.deviceModel = is.read_string()?;
                },
                58 => {
                    self.osVersion = is.read_string()?;
                },
                66 => {
                    self.appVersion = is.read_string()?;
                },
                74 => {
                    self.extra = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.appId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appId);
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if !self.clientIp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.clientIp);
        }
        if !self.installId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.installId);
        }
        if self.platform != ::protobuf::EnumOrUnknown::new(Platform::IOS) {
            my_size += ::protobuf::rt::int32_size(5, self.platform.value());
        }
        if !self.deviceModel.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.deviceModel);
        }
        if !self.osVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.osVersion);
        }
        if !self.appVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.appVersion);
        }
        if !self.extra.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.extra);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.appId.is_empty() {
            os.write_string(1, &self.appId)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if !self.clientIp.is_empty() {
            os.write_string(3, &self.clientIp)?;
        }
        if !self.installId.is_empty() {
            os.write_string(4, &self.installId)?;
        }
        if self.platform != ::protobuf::EnumOrUnknown::new(Platform::IOS) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.platform))?;
        }
        if !self.deviceModel.is_empty() {
            os.write_string(6, &self.deviceModel)?;
        }
        if !self.osVersion.is_empty() {
            os.write_string(7, &self.osVersion)?;
        }
        if !self.appVersion.is_empty() {
            os.write_string(8, &self.appVersion)?;
        }
        if !self.extra.is_empty() {
            os.write_string(9, &self.extra)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestHeader {
        RequestHeader::new()
    }

    fn clear(&mut self) {
        self.appId.clear();
        self.userId.clear();
        self.clientIp.clear();
        self.installId.clear();
        self.platform = ::protobuf::EnumOrUnknown::new(Platform::IOS);
        self.deviceModel.clear();
        self.osVersion.clear();
        self.appVersion.clear();
        self.extra.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestHeader {
        static instance: RequestHeader = RequestHeader {
            appId: ::std::string::String::new(),
            userId: ::std::string::String::new(),
            clientIp: ::std::string::String::new(),
            installId: ::std::string::String::new(),
            platform: ::protobuf::EnumOrUnknown::from_i32(0),
            deviceModel: ::std::string::String::new(),
            osVersion: ::std::string::String::new(),
            appVersion: ::std::string::String::new(),
            extra: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// ToastActionData toast提示 客户端根据level显示不同的颜色 可能持续不同的时间
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ToastActionData)
pub struct ToastActionData {
    // message fields
    // @@protoc_insertion_point(field:pb.ToastActionData.level)
    pub level: ::protobuf::EnumOrUnknown<toast_action_data::Level>,
    // @@protoc_insertion_point(field:pb.ToastActionData.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ToastActionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ToastActionData {
    fn default() -> &'a ToastActionData {
        <ToastActionData as ::protobuf::Message>::default_instance()
    }
}

impl ToastActionData {
    pub fn new() -> ToastActionData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &ToastActionData| { &m.level },
            |m: &mut ToastActionData| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &ToastActionData| { &m.message },
            |m: &mut ToastActionData| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ToastActionData>(
            "ToastActionData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ToastActionData {
    const NAME: &'static str = "ToastActionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != ::protobuf::EnumOrUnknown::new(toast_action_data::Level::INFO) {
            my_size += ::protobuf::rt::int32_size(1, self.level.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != ::protobuf::EnumOrUnknown::new(toast_action_data::Level::INFO) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ToastActionData {
        ToastActionData::new()
    }

    fn clear(&mut self) {
        self.level = ::protobuf::EnumOrUnknown::new(toast_action_data::Level::INFO);
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ToastActionData {
        static instance: ToastActionData = ToastActionData {
            level: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ToastActionData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ToastActionData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ToastActionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ToastActionData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ToastActionData`
pub mod toast_action_data {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:pb.ToastActionData.Level)
    pub enum Level {
        // @@protoc_insertion_point(enum_value:pb.ToastActionData.Level.INFO)
        INFO = 0,
        // @@protoc_insertion_point(enum_value:pb.ToastActionData.Level.WARN)
        WARN = 1,
        // @@protoc_insertion_point(enum_value:pb.ToastActionData.Level.ERROR)
        ERROR = 2,
    }

    impl ::protobuf::Enum for Level {
        const NAME: &'static str = "Level";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Level> {
            match value {
                0 => ::std::option::Option::Some(Level::INFO),
                1 => ::std::option::Option::Some(Level::WARN),
                2 => ::std::option::Option::Some(Level::ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Level] = &[
            Level::INFO,
            Level::WARN,
            Level::ERROR,
        ];
    }

    impl ::protobuf::EnumFull for Level {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ToastActionData.Level").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Level {
        fn default() -> Self {
            Level::INFO
        }
    }

    impl Level {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Level>("ToastActionData.Level")
        }
    }
}

/// AlertActionData alert提示 永远有一个关闭按钮 以下描述的是另一个操作按钮
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.AlertActionData)
pub struct AlertActionData {
    // message fields
    // @@protoc_insertion_point(field:pb.AlertActionData.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:pb.AlertActionData.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:pb.AlertActionData.buttonType)
    pub buttonType: ::protobuf::EnumOrUnknown<alert_action_data::ButtonType>,
    // @@protoc_insertion_point(field:pb.AlertActionData.buttonLabel)
    pub buttonLabel: ::std::string::String,
    // @@protoc_insertion_point(field:pb.AlertActionData.buttonData)
    pub buttonData: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.AlertActionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlertActionData {
    fn default() -> &'a AlertActionData {
        <AlertActionData as ::protobuf::Message>::default_instance()
    }
}

impl AlertActionData {
    pub fn new() -> AlertActionData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &AlertActionData| { &m.title },
            |m: &mut AlertActionData| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &AlertActionData| { &m.message },
            |m: &mut AlertActionData| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buttonType",
            |m: &AlertActionData| { &m.buttonType },
            |m: &mut AlertActionData| { &mut m.buttonType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buttonLabel",
            |m: &AlertActionData| { &m.buttonLabel },
            |m: &mut AlertActionData| { &mut m.buttonLabel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buttonData",
            |m: &AlertActionData| { &m.buttonData },
            |m: &mut AlertActionData| { &mut m.buttonData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlertActionData>(
            "AlertActionData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlertActionData {
    const NAME: &'static str = "AlertActionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                24 => {
                    self.buttonType = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.buttonLabel = is.read_string()?;
                },
                42 => {
                    self.buttonData = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if self.buttonType != ::protobuf::EnumOrUnknown::new(alert_action_data::ButtonType::NO_BUTTON) {
            my_size += ::protobuf::rt::int32_size(3, self.buttonType.value());
        }
        if !self.buttonLabel.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.buttonLabel);
        }
        if !self.buttonData.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.buttonData);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if self.buttonType != ::protobuf::EnumOrUnknown::new(alert_action_data::ButtonType::NO_BUTTON) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.buttonType))?;
        }
        if !self.buttonLabel.is_empty() {
            os.write_string(4, &self.buttonLabel)?;
        }
        if !self.buttonData.is_empty() {
            os.write_string(5, &self.buttonData)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlertActionData {
        AlertActionData::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.message.clear();
        self.buttonType = ::protobuf::EnumOrUnknown::new(alert_action_data::ButtonType::NO_BUTTON);
        self.buttonLabel.clear();
        self.buttonData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlertActionData {
        static instance: AlertActionData = AlertActionData {
            title: ::std::string::String::new(),
            message: ::std::string::String::new(),
            buttonType: ::protobuf::EnumOrUnknown::from_i32(0),
            buttonLabel: ::std::string::String::new(),
            buttonData: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlertActionData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlertActionData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlertActionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertActionData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AlertActionData`
pub mod alert_action_data {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:pb.AlertActionData.ButtonType)
    pub enum ButtonType {
        // @@protoc_insertion_point(enum_value:pb.AlertActionData.ButtonType.NO_BUTTON)
        NO_BUTTON = 0,
        // @@protoc_insertion_point(enum_value:pb.AlertActionData.ButtonType.JUMP_URL)
        JUMP_URL = 1,
    }

    impl ::protobuf::Enum for ButtonType {
        const NAME: &'static str = "ButtonType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ButtonType> {
            match value {
                0 => ::std::option::Option::Some(ButtonType::NO_BUTTON),
                1 => ::std::option::Option::Some(ButtonType::JUMP_URL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ButtonType] = &[
            ButtonType::NO_BUTTON,
            ButtonType::JUMP_URL,
        ];
    }

    impl ::protobuf::EnumFull for ButtonType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AlertActionData.ButtonType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ButtonType {
        fn default() -> Self {
            ButtonType::NO_BUTTON
        }
    }

    impl ButtonType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ButtonType>("AlertActionData.ButtonType")
        }
    }
}

/// ResponseHeader 响应头
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ResponseHeader)
pub struct ResponseHeader {
    // message fields
    // @@protoc_insertion_point(field:pb.ResponseHeader.code)
    pub code: ::protobuf::EnumOrUnknown<ResponseCode>,
    // @@protoc_insertion_point(field:pb.ResponseHeader.actionType)
    pub actionType: ::protobuf::EnumOrUnknown<ResponseActionType>,
    // @@protoc_insertion_point(field:pb.ResponseHeader.actionData)
    pub actionData: ::std::string::String,
    // @@protoc_insertion_point(field:pb.ResponseHeader.extra)
    pub extra: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ResponseHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseHeader {
    fn default() -> &'a ResponseHeader {
        <ResponseHeader as ::protobuf::Message>::default_instance()
    }
}

impl ResponseHeader {
    pub fn new() -> ResponseHeader {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ResponseHeader| { &m.code },
            |m: &mut ResponseHeader| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actionType",
            |m: &ResponseHeader| { &m.actionType },
            |m: &mut ResponseHeader| { &mut m.actionType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actionData",
            |m: &ResponseHeader| { &m.actionData },
            |m: &mut ResponseHeader| { &mut m.actionData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extra",
            |m: &ResponseHeader| { &m.extra },
            |m: &mut ResponseHeader| { &mut m.extra },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseHeader>(
            "ResponseHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseHeader {
    const NAME: &'static str = "ResponseHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.actionType = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.actionData = is.read_string()?;
                },
                34 => {
                    self.extra = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != ::protobuf::EnumOrUnknown::new(ResponseCode::SUCCESS) {
            my_size += ::protobuf::rt::int32_size(1, self.code.value());
        }
        if self.actionType != ::protobuf::EnumOrUnknown::new(ResponseActionType::NONE_ACTION) {
            my_size += ::protobuf::rt::int32_size(2, self.actionType.value());
        }
        if !self.actionData.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actionData);
        }
        if !self.extra.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.extra);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != ::protobuf::EnumOrUnknown::new(ResponseCode::SUCCESS) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.code))?;
        }
        if self.actionType != ::protobuf::EnumOrUnknown::new(ResponseActionType::NONE_ACTION) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.actionType))?;
        }
        if !self.actionData.is_empty() {
            os.write_string(3, &self.actionData)?;
        }
        if !self.extra.is_empty() {
            os.write_string(4, &self.extra)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseHeader {
        ResponseHeader::new()
    }

    fn clear(&mut self) {
        self.code = ::protobuf::EnumOrUnknown::new(ResponseCode::SUCCESS);
        self.actionType = ::protobuf::EnumOrUnknown::new(ResponseActionType::NONE_ACTION);
        self.actionData.clear();
        self.extra.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseHeader {
        static instance: ResponseHeader = ResponseHeader {
            code: ::protobuf::EnumOrUnknown::from_i32(0),
            actionType: ::protobuf::EnumOrUnknown::from_i32(0),
            actionData: ::std::string::String::new(),
            extra: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Message 消息
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.Message)
pub struct Message {
    // message fields
    /// MessageId 消息id 由服务端插入时生成
    // @@protoc_insertion_point(field:pb.Message.messageId)
    pub messageId: ::std::string::String,
    /// UUID 客户端生成的id 由客户端生成 在客户端保证唯一性
    // @@protoc_insertion_point(field:pb.Message.uuid)
    pub uuid: ::std::string::String,
    /// 发送到哪个会话
    // @@protoc_insertion_point(field:pb.Message.conversationId)
    pub conversationId: ::std::string::String,
    /// 会话类型
    // @@protoc_insertion_point(field:pb.Message.conversationType)
    pub conversationType: ::protobuf::EnumOrUnknown<ConversationType>,
    // @@protoc_insertion_point(field:pb.Message.sender)
    pub sender: ::protobuf::MessageField<message::Sender>,
    /// 消息内容
    // @@protoc_insertion_point(field:pb.Message.content)
    pub content: ::std::vec::Vec<u8>,
    /// 消息类型
    // @@protoc_insertion_point(field:pb.Message.contentType)
    pub contentType: ::protobuf::EnumOrUnknown<MessageContentType>,
    /// 发送时间 由客户端生成
    // @@protoc_insertion_point(field:pb.Message.sendTime)
    pub sendTime: i64,
    /// 插入时间 由服务端生成
    // @@protoc_insertion_point(field:pb.Message.insertTime)
    pub insertTime: i64,
    /// 在会话中的消息顺序
    // @@protoc_insertion_point(field:pb.Message.seq)
    pub seq: i64,
    // @@protoc_insertion_point(field:pb.Message.option)
    pub option: ::protobuf::MessageField<message::Option>,
    /// extraMap, example: {"platformSource": "windows"}
    // @@protoc_insertion_point(field:pb.Message.extraMap)
    pub extraMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "messageId",
            |m: &Message| { &m.messageId },
            |m: &mut Message| { &mut m.messageId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &Message| { &m.uuid },
            |m: &mut Message| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conversationId",
            |m: &Message| { &m.conversationId },
            |m: &mut Message| { &mut m.conversationId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conversationType",
            |m: &Message| { &m.conversationType },
            |m: &mut Message| { &mut m.conversationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, message::Sender>(
            "sender",
            |m: &Message| { &m.sender },
            |m: &mut Message| { &mut m.sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &Message| { &m.content },
            |m: &mut Message| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contentType",
            |m: &Message| { &m.contentType },
            |m: &mut Message| { &mut m.contentType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sendTime",
            |m: &Message| { &m.sendTime },
            |m: &mut Message| { &mut m.sendTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "insertTime",
            |m: &Message| { &m.insertTime },
            |m: &mut Message| { &mut m.insertTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seq",
            |m: &Message| { &m.seq },
            |m: &mut Message| { &mut m.seq },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, message::Option>(
            "option",
            |m: &Message| { &m.option },
            |m: &mut Message| { &mut m.option },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extraMap",
            |m: &Message| { &m.extraMap },
            |m: &mut Message| { &mut m.extraMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messageId = is.read_string()?;
                },
                18 => {
                    self.uuid = is.read_string()?;
                },
                26 => {
                    self.conversationId = is.read_string()?;
                },
                32 => {
                    self.conversationType = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sender)?;
                },
                50 => {
                    self.content = is.read_bytes()?;
                },
                56 => {
                    self.contentType = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.sendTime = is.read_int64()?;
                },
                72 => {
                    self.insertTime = is.read_int64()?;
                },
                80 => {
                    self.seq = is.read_int64()?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                138 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extraMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.messageId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.messageId);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uuid);
        }
        if !self.conversationId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.conversationId);
        }
        if self.conversationType != ::protobuf::EnumOrUnknown::new(ConversationType::Single) {
            my_size += ::protobuf::rt::int32_size(4, self.conversationType.value());
        }
        if let Some(v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.content);
        }
        if self.contentType != ::protobuf::EnumOrUnknown::new(MessageContentType::Text) {
            my_size += ::protobuf::rt::int32_size(7, self.contentType.value());
        }
        if self.sendTime != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.sendTime);
        }
        if self.insertTime != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.insertTime);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.seq);
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.messageId.is_empty() {
            os.write_string(1, &self.messageId)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(2, &self.uuid)?;
        }
        if !self.conversationId.is_empty() {
            os.write_string(3, &self.conversationId)?;
        }
        if self.conversationType != ::protobuf::EnumOrUnknown::new(ConversationType::Single) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.conversationType))?;
        }
        if let Some(v) = self.sender.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(6, &self.content)?;
        }
        if self.contentType != ::protobuf::EnumOrUnknown::new(MessageContentType::Text) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.contentType))?;
        }
        if self.sendTime != 0 {
            os.write_int64(8, self.sendTime)?;
        }
        if self.insertTime != 0 {
            os.write_int64(9, self.insertTime)?;
        }
        if self.seq != 0 {
            os.write_int64(10, self.seq)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(138)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.messageId.clear();
        self.uuid.clear();
        self.conversationId.clear();
        self.conversationType = ::protobuf::EnumOrUnknown::new(ConversationType::Single);
        self.sender.clear();
        self.content.clear();
        self.contentType = ::protobuf::EnumOrUnknown::new(MessageContentType::Text);
        self.sendTime = 0;
        self.insertTime = 0;
        self.seq = 0;
        self.option.clear();
        self.extraMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: ::protobuf::rt::Lazy<Message> = ::protobuf::rt::Lazy::new();
        instance.get(Message::new)
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {
    /// 发送者
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.Message.Sender)
    pub struct Sender {
        // message fields
        /// 发送者id
        // @@protoc_insertion_point(field:pb.Message.Sender.id)
        pub id: ::std::string::String,
        /// 发送者名称
        // @@protoc_insertion_point(field:pb.Message.Sender.name)
        pub name: ::std::string::String,
        /// 发送者头像
        // @@protoc_insertion_point(field:pb.Message.Sender.avatar)
        pub avatar: ::std::string::String,
        /// extra
        // @@protoc_insertion_point(field:pb.Message.Sender.extra)
        pub extra: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:pb.Message.Sender.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sender {
        fn default() -> &'a Sender {
            <Sender as ::protobuf::Message>::default_instance()
        }
    }

    impl Sender {
        pub fn new() -> Sender {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &Sender| { &m.id },
                |m: &mut Sender| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Sender| { &m.name },
                |m: &mut Sender| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "avatar",
                |m: &Sender| { &m.avatar },
                |m: &mut Sender| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "extra",
                |m: &Sender| { &m.extra },
                |m: &mut Sender| { &mut m.extra },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sender>(
                "Message.Sender",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sender {
        const NAME: &'static str = "Sender";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    },
                    18 => {
                        self.name = is.read_string()?;
                    },
                    26 => {
                        self.avatar = is.read_string()?;
                    },
                    90 => {
                        self.extra = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.name);
            }
            if !self.avatar.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.avatar);
            }
            if !self.extra.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.extra);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.name.is_empty() {
                os.write_string(2, &self.name)?;
            }
            if !self.avatar.is_empty() {
                os.write_string(3, &self.avatar)?;
            }
            if !self.extra.is_empty() {
                os.write_string(11, &self.extra)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sender {
            Sender::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.name.clear();
            self.avatar.clear();
            self.extra.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sender {
            static instance: Sender = Sender {
                id: ::std::string::String::new(),
                name: ::std::string::String::new(),
                avatar: ::std::string::String::new(),
                extra: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sender {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Message.Sender").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sender {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sender {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// 选项
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.Message.Option)
    pub struct Option {
        // message fields
        /// 服务端是否保存该消息
        // @@protoc_insertion_point(field:pb.Message.Option.storageForServer)
        pub storageForServer: bool,
        /// 客户端是否保存该消息
        // @@protoc_insertion_point(field:pb.Message.Option.storageForClient)
        pub storageForClient: bool,
        /// 是否需要解密 （端对端加密技术，服务端无法解密）
        // @@protoc_insertion_point(field:pb.Message.Option.needDecrypt)
        pub needDecrypt: bool,
        /// 消息是否需要计入未读数
        // @@protoc_insertion_point(field:pb.Message.Option.countUnread)
        pub countUnread: bool,
        // special fields
        // @@protoc_insertion_point(special_field:pb.Message.Option.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Option {
        fn default() -> &'a Option {
            <Option as ::protobuf::Message>::default_instance()
        }
    }

    impl Option {
        pub fn new() -> Option {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "storageForServer",
                |m: &Option| { &m.storageForServer },
                |m: &mut Option| { &mut m.storageForServer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "storageForClient",
                |m: &Option| { &m.storageForClient },
                |m: &mut Option| { &mut m.storageForClient },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "needDecrypt",
                |m: &Option| { &m.needDecrypt },
                |m: &mut Option| { &mut m.needDecrypt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "countUnread",
                |m: &Option| { &m.countUnread },
                |m: &mut Option| { &mut m.countUnread },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
                "Message.Option",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Option {
        const NAME: &'static str = "Option";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.storageForServer = is.read_bool()?;
                    },
                    16 => {
                        self.storageForClient = is.read_bool()?;
                    },
                    24 => {
                        self.needDecrypt = is.read_bool()?;
                    },
                    32 => {
                        self.countUnread = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.storageForServer != false {
                my_size += 1 + 1;
            }
            if self.storageForClient != false {
                my_size += 1 + 1;
            }
            if self.needDecrypt != false {
                my_size += 1 + 1;
            }
            if self.countUnread != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.storageForServer != false {
                os.write_bool(1, self.storageForServer)?;
            }
            if self.storageForClient != false {
                os.write_bool(2, self.storageForClient)?;
            }
            if self.needDecrypt != false {
                os.write_bool(3, self.needDecrypt)?;
            }
            if self.countUnread != false {
                os.write_bool(4, self.countUnread)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Option {
            Option::new()
        }

        fn clear(&mut self) {
            self.storageForServer = false;
            self.storageForClient = false;
            self.needDecrypt = false;
            self.countUnread = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Option {
            static instance: Option = Option {
                storageForServer: false,
                storageForClient: false,
                needDecrypt: false,
                countUnread: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Option {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Message.Option").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Option {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Option {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// Notice 通知
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.Notice)
pub struct Notice {
    // message fields
    /// 通知id 因为通知永远都是服务端发送给客户端的，所以通知id一定唯一。
    // @@protoc_insertion_point(field:pb.Notice.noticeId)
    pub noticeId: ::std::string::String,
    /// 发送到哪个会话
    // @@protoc_insertion_point(field:pb.Notice.conversationId)
    pub conversationId: ::std::string::String,
    /// 会话类型
    // @@protoc_insertion_point(field:pb.Notice.conversationType)
    pub conversationType: ::protobuf::EnumOrUnknown<ConversationType>,
    /// 通知内容
    // @@protoc_insertion_point(field:pb.Notice.content)
    pub content: ::std::string::String,
    /// 通知类型
    // @@protoc_insertion_point(field:pb.Notice.contentType)
    pub contentType: ::protobuf::EnumOrUnknown<NoticeContentType>,
    /// 通知的更新时间
    // @@protoc_insertion_point(field:pb.Notice.updateTime)
    pub updateTime: i64,
    /// 排序
    // @@protoc_insertion_point(field:pb.Notice.sort)
    pub sort: i64,
    // special fields
    // @@protoc_insertion_point(special_field:pb.Notice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Notice {
    fn default() -> &'a Notice {
        <Notice as ::protobuf::Message>::default_instance()
    }
}

impl Notice {
    pub fn new() -> Notice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noticeId",
            |m: &Notice| { &m.noticeId },
            |m: &mut Notice| { &mut m.noticeId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conversationId",
            |m: &Notice| { &m.conversationId },
            |m: &mut Notice| { &mut m.conversationId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conversationType",
            |m: &Notice| { &m.conversationType },
            |m: &mut Notice| { &mut m.conversationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &Notice| { &m.content },
            |m: &mut Notice| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contentType",
            |m: &Notice| { &m.contentType },
            |m: &mut Notice| { &mut m.contentType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updateTime",
            |m: &Notice| { &m.updateTime },
            |m: &mut Notice| { &mut m.updateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort",
            |m: &Notice| { &m.sort },
            |m: &mut Notice| { &mut m.sort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Notice>(
            "Notice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Notice {
    const NAME: &'static str = "Notice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.noticeId = is.read_string()?;
                },
                18 => {
                    self.conversationId = is.read_string()?;
                },
                24 => {
                    self.conversationType = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.content = is.read_string()?;
                },
                40 => {
                    self.contentType = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.updateTime = is.read_int64()?;
                },
                56 => {
                    self.sort = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.noticeId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noticeId);
        }
        if !self.conversationId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.conversationId);
        }
        if self.conversationType != ::protobuf::EnumOrUnknown::new(ConversationType::Single) {
            my_size += ::protobuf::rt::int32_size(3, self.conversationType.value());
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.content);
        }
        if self.contentType != ::protobuf::EnumOrUnknown::new(NoticeContentType::NewFriendRequest) {
            my_size += ::protobuf::rt::int32_size(5, self.contentType.value());
        }
        if self.updateTime != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.updateTime);
        }
        if self.sort != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.sort);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.noticeId.is_empty() {
            os.write_string(1, &self.noticeId)?;
        }
        if !self.conversationId.is_empty() {
            os.write_string(2, &self.conversationId)?;
        }
        if self.conversationType != ::protobuf::EnumOrUnknown::new(ConversationType::Single) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.conversationType))?;
        }
        if !self.content.is_empty() {
            os.write_string(4, &self.content)?;
        }
        if self.contentType != ::protobuf::EnumOrUnknown::new(NoticeContentType::NewFriendRequest) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.contentType))?;
        }
        if self.updateTime != 0 {
            os.write_int64(6, self.updateTime)?;
        }
        if self.sort != 0 {
            os.write_int64(7, self.sort)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Notice {
        Notice::new()
    }

    fn clear(&mut self) {
        self.noticeId.clear();
        self.conversationId.clear();
        self.conversationType = ::protobuf::EnumOrUnknown::new(ConversationType::Single);
        self.content.clear();
        self.contentType = ::protobuf::EnumOrUnknown::new(NoticeContentType::NewFriendRequest);
        self.updateTime = 0;
        self.sort = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Notice {
        static instance: Notice = Notice {
            noticeId: ::std::string::String::new(),
            conversationId: ::std::string::String::new(),
            conversationType: ::protobuf::EnumOrUnknown::from_i32(0),
            content: ::std::string::String::new(),
            contentType: ::protobuf::EnumOrUnknown::from_i32(0),
            updateTime: 0,
            sort: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Notice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Notice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Notice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Platform 平台枚举
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.Platform)
pub enum Platform {
    // @@protoc_insertion_point(enum_value:pb.Platform.IOS)
    IOS = 0,
    // @@protoc_insertion_point(enum_value:pb.Platform.ANDROID)
    ANDROID = 1,
    // @@protoc_insertion_point(enum_value:pb.Platform.WEB)
    WEB = 2,
    // @@protoc_insertion_point(enum_value:pb.Platform.WINDOWS)
    WINDOWS = 3,
    // @@protoc_insertion_point(enum_value:pb.Platform.MAC)
    MAC = 4,
    // @@protoc_insertion_point(enum_value:pb.Platform.LINUX)
    LINUX = 5,
    // @@protoc_insertion_point(enum_value:pb.Platform.Ipad)
    Ipad = 6,
    // @@protoc_insertion_point(enum_value:pb.Platform.AndroidPad)
    AndroidPad = 7,
}

impl ::protobuf::Enum for Platform {
    const NAME: &'static str = "Platform";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Platform> {
        match value {
            0 => ::std::option::Option::Some(Platform::IOS),
            1 => ::std::option::Option::Some(Platform::ANDROID),
            2 => ::std::option::Option::Some(Platform::WEB),
            3 => ::std::option::Option::Some(Platform::WINDOWS),
            4 => ::std::option::Option::Some(Platform::MAC),
            5 => ::std::option::Option::Some(Platform::LINUX),
            6 => ::std::option::Option::Some(Platform::Ipad),
            7 => ::std::option::Option::Some(Platform::AndroidPad),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Platform] = &[
        Platform::IOS,
        Platform::ANDROID,
        Platform::WEB,
        Platform::WINDOWS,
        Platform::MAC,
        Platform::LINUX,
        Platform::Ipad,
        Platform::AndroidPad,
    ];
}

impl ::protobuf::EnumFull for Platform {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Platform").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Platform {
    fn default() -> Self {
        Platform::IOS
    }
}

impl Platform {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Platform>("Platform")
    }
}

/// ResponseCode
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.ResponseCode)
pub enum ResponseCode {
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.SUCCESS)
    SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.INVALID_DATA)
    INVALID_DATA = 1,
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.UNAUTHORIZED)
    UNAUTHORIZED = 2,
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.FORBIDDEN)
    FORBIDDEN = 3,
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.INVALID_METHOD)
    INVALID_METHOD = 4,
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.TIMEOUT)
    TIMEOUT = 5,
    // @@protoc_insertion_point(enum_value:pb.ResponseCode.SERVER_ERROR)
    SERVER_ERROR = 6,
}

impl ::protobuf::Enum for ResponseCode {
    const NAME: &'static str = "ResponseCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseCode> {
        match value {
            0 => ::std::option::Option::Some(ResponseCode::SUCCESS),
            1 => ::std::option::Option::Some(ResponseCode::INVALID_DATA),
            2 => ::std::option::Option::Some(ResponseCode::UNAUTHORIZED),
            3 => ::std::option::Option::Some(ResponseCode::FORBIDDEN),
            4 => ::std::option::Option::Some(ResponseCode::INVALID_METHOD),
            5 => ::std::option::Option::Some(ResponseCode::TIMEOUT),
            6 => ::std::option::Option::Some(ResponseCode::SERVER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ResponseCode] = &[
        ResponseCode::SUCCESS,
        ResponseCode::INVALID_DATA,
        ResponseCode::UNAUTHORIZED,
        ResponseCode::FORBIDDEN,
        ResponseCode::INVALID_METHOD,
        ResponseCode::TIMEOUT,
        ResponseCode::SERVER_ERROR,
    ];
}

impl ::protobuf::EnumFull for ResponseCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ResponseCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ResponseCode {
    fn default() -> Self {
        ResponseCode::SUCCESS
    }
}

impl ResponseCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResponseCode>("ResponseCode")
    }
}

/// ResponseActionType 客户端收到响应后做的动作类型
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.ResponseActionType)
pub enum ResponseActionType {
    // @@protoc_insertion_point(enum_value:pb.ResponseActionType.NONE_ACTION)
    NONE_ACTION = 0,
    // @@protoc_insertion_point(enum_value:pb.ResponseActionType.TOAST_ACTION)
    TOAST_ACTION = 1,
    // @@protoc_insertion_point(enum_value:pb.ResponseActionType.ALERT_ACTION)
    ALERT_ACTION = 2,
    // @@protoc_insertion_point(enum_value:pb.ResponseActionType.SECOND_AUTH_ACTION)
    SECOND_AUTH_ACTION = 3,
}

impl ::protobuf::Enum for ResponseActionType {
    const NAME: &'static str = "ResponseActionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseActionType> {
        match value {
            0 => ::std::option::Option::Some(ResponseActionType::NONE_ACTION),
            1 => ::std::option::Option::Some(ResponseActionType::TOAST_ACTION),
            2 => ::std::option::Option::Some(ResponseActionType::ALERT_ACTION),
            3 => ::std::option::Option::Some(ResponseActionType::SECOND_AUTH_ACTION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ResponseActionType] = &[
        ResponseActionType::NONE_ACTION,
        ResponseActionType::TOAST_ACTION,
        ResponseActionType::ALERT_ACTION,
        ResponseActionType::SECOND_AUTH_ACTION,
    ];
}

impl ::protobuf::EnumFull for ResponseActionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ResponseActionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ResponseActionType {
    fn default() -> Self {
        ResponseActionType::NONE_ACTION
    }
}

impl ResponseActionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResponseActionType>("ResponseActionType")
    }
}

/// WebsocketCustomCloseCode websocket关闭码
/// You can define custom codes in the 3000-4999 range.
/// The 3000-3999 range is reserved for use by libraries, frameworks and applications.
/// The 4000-4999 range is reserved for private use.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.WebsocketCustomCloseCode)
pub enum WebsocketCustomCloseCode {
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeZero)
    CloseCodeZero = 0,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeNormalClose)
    CloseCodeNormalClose = 1000,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeGoingAway)
    CloseCodeGoingAway = 1001,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeProtocolError)
    CloseCodeProtocolError = 1002,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeUnsupportedData)
    CloseCodeUnsupportedData = 1003,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeNoStatusReceived)
    CloseCodeNoStatusReceived = 1005,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeAbnormalClosure)
    CloseCodeAbnormalClosure = 1006,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeAuthenticationFailed)
    CloseCodeAuthenticationFailed = 4001,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeDuplicateConnection)
    CloseCodeDuplicateConnection = 4002,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeServerInternalError)
    CloseCodeServerInternalError = 4003,
    // @@protoc_insertion_point(enum_value:pb.WebsocketCustomCloseCode.CloseCodeHeartbeatTimeout)
    CloseCodeHeartbeatTimeout = 4004,
}

impl ::protobuf::Enum for WebsocketCustomCloseCode {
    const NAME: &'static str = "WebsocketCustomCloseCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WebsocketCustomCloseCode> {
        match value {
            0 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeZero),
            1000 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeNormalClose),
            1001 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeGoingAway),
            1002 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeProtocolError),
            1003 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeUnsupportedData),
            1005 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeNoStatusReceived),
            1006 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeAbnormalClosure),
            4001 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeAuthenticationFailed),
            4002 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeDuplicateConnection),
            4003 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeServerInternalError),
            4004 => ::std::option::Option::Some(WebsocketCustomCloseCode::CloseCodeHeartbeatTimeout),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WebsocketCustomCloseCode] = &[
        WebsocketCustomCloseCode::CloseCodeZero,
        WebsocketCustomCloseCode::CloseCodeNormalClose,
        WebsocketCustomCloseCode::CloseCodeGoingAway,
        WebsocketCustomCloseCode::CloseCodeProtocolError,
        WebsocketCustomCloseCode::CloseCodeUnsupportedData,
        WebsocketCustomCloseCode::CloseCodeNoStatusReceived,
        WebsocketCustomCloseCode::CloseCodeAbnormalClosure,
        WebsocketCustomCloseCode::CloseCodeAuthenticationFailed,
        WebsocketCustomCloseCode::CloseCodeDuplicateConnection,
        WebsocketCustomCloseCode::CloseCodeServerInternalError,
        WebsocketCustomCloseCode::CloseCodeHeartbeatTimeout,
    ];
}

impl ::protobuf::EnumFull for WebsocketCustomCloseCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WebsocketCustomCloseCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            WebsocketCustomCloseCode::CloseCodeZero => 0,
            WebsocketCustomCloseCode::CloseCodeNormalClose => 1,
            WebsocketCustomCloseCode::CloseCodeGoingAway => 2,
            WebsocketCustomCloseCode::CloseCodeProtocolError => 3,
            WebsocketCustomCloseCode::CloseCodeUnsupportedData => 4,
            WebsocketCustomCloseCode::CloseCodeNoStatusReceived => 5,
            WebsocketCustomCloseCode::CloseCodeAbnormalClosure => 6,
            WebsocketCustomCloseCode::CloseCodeAuthenticationFailed => 7,
            WebsocketCustomCloseCode::CloseCodeDuplicateConnection => 8,
            WebsocketCustomCloseCode::CloseCodeServerInternalError => 9,
            WebsocketCustomCloseCode::CloseCodeHeartbeatTimeout => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WebsocketCustomCloseCode {
    fn default() -> Self {
        WebsocketCustomCloseCode::CloseCodeZero
    }
}

impl WebsocketCustomCloseCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebsocketCustomCloseCode>("WebsocketCustomCloseCode")
    }
}

/// ConversationType 会话类型
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.ConversationType)
pub enum ConversationType {
    // @@protoc_insertion_point(enum_value:pb.ConversationType.Single)
    Single = 0,
    // @@protoc_insertion_point(enum_value:pb.ConversationType.Group)
    Group = 1,
    // @@protoc_insertion_point(enum_value:pb.ConversationType.Subscription)
    Subscription = 2,
}

impl ::protobuf::Enum for ConversationType {
    const NAME: &'static str = "ConversationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConversationType> {
        match value {
            0 => ::std::option::Option::Some(ConversationType::Single),
            1 => ::std::option::Option::Some(ConversationType::Group),
            2 => ::std::option::Option::Some(ConversationType::Subscription),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ConversationType] = &[
        ConversationType::Single,
        ConversationType::Group,
        ConversationType::Subscription,
    ];
}

impl ::protobuf::EnumFull for ConversationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ConversationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ConversationType {
    fn default() -> Self {
        ConversationType::Single
    }
}

impl ConversationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConversationType>("ConversationType")
    }
}

/// NoticeContentType 通知内容类型
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.NoticeContentType)
pub enum NoticeContentType {
    // @@protoc_insertion_point(enum_value:pb.NoticeContentType.NewFriendRequest)
    NewFriendRequest = 0,
    // @@protoc_insertion_point(enum_value:pb.NoticeContentType.JoinNewGroup)
    JoinNewGroup = 1,
    // @@protoc_insertion_point(enum_value:pb.NoticeContentType.OnlineStatus)
    OnlineStatus = 2,
}

impl ::protobuf::Enum for NoticeContentType {
    const NAME: &'static str = "NoticeContentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NoticeContentType> {
        match value {
            0 => ::std::option::Option::Some(NoticeContentType::NewFriendRequest),
            1 => ::std::option::Option::Some(NoticeContentType::JoinNewGroup),
            2 => ::std::option::Option::Some(NoticeContentType::OnlineStatus),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NoticeContentType] = &[
        NoticeContentType::NewFriendRequest,
        NoticeContentType::JoinNewGroup,
        NoticeContentType::OnlineStatus,
    ];
}

impl ::protobuf::EnumFull for NoticeContentType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NoticeContentType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NoticeContentType {
    fn default() -> Self {
        NoticeContentType::NewFriendRequest
    }
}

impl NoticeContentType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NoticeContentType>("NoticeContentType")
    }
}

/// MessageContentType 消息内容类型
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.MessageContentType)
pub enum MessageContentType {
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Text)
    Text = 0,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Markdown)
    Markdown = 1,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Image)
    Image = 2,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Voice)
    Voice = 3,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Video)
    Video = 4,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Typing)
    Typing = 101,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Read)
    Read = 102,
    // @@protoc_insertion_point(enum_value:pb.MessageContentType.Recall)
    Recall = 103,
}

impl ::protobuf::Enum for MessageContentType {
    const NAME: &'static str = "MessageContentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageContentType> {
        match value {
            0 => ::std::option::Option::Some(MessageContentType::Text),
            1 => ::std::option::Option::Some(MessageContentType::Markdown),
            2 => ::std::option::Option::Some(MessageContentType::Image),
            3 => ::std::option::Option::Some(MessageContentType::Voice),
            4 => ::std::option::Option::Some(MessageContentType::Video),
            101 => ::std::option::Option::Some(MessageContentType::Typing),
            102 => ::std::option::Option::Some(MessageContentType::Read),
            103 => ::std::option::Option::Some(MessageContentType::Recall),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageContentType] = &[
        MessageContentType::Text,
        MessageContentType::Markdown,
        MessageContentType::Image,
        MessageContentType::Voice,
        MessageContentType::Video,
        MessageContentType::Typing,
        MessageContentType::Read,
        MessageContentType::Recall,
    ];
}

impl ::protobuf::EnumFull for MessageContentType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageContentType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MessageContentType::Text => 0,
            MessageContentType::Markdown => 1,
            MessageContentType::Image => 2,
            MessageContentType::Voice => 3,
            MessageContentType::Video => 4,
            MessageContentType::Typing => 5,
            MessageContentType::Read => 6,
            MessageContentType::Recall => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MessageContentType {
    fn default() -> Self {
        MessageContentType::Text
    }
}

impl MessageContentType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageContentType>("MessageContentType")
    }
}

/// ConversationSettingKey 会话设置key
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.ConversationSettingKey)
pub enum ConversationSettingKey {
    // @@protoc_insertion_point(enum_value:pb.ConversationSettingKey.IsPinned)
    IsPinned = 0,
    // @@protoc_insertion_point(enum_value:pb.ConversationSettingKey.IsMuted)
    IsMuted = 1,
    // @@protoc_insertion_point(enum_value:pb.ConversationSettingKey.IsBlocked)
    IsBlocked = 2,
    // @@protoc_insertion_point(enum_value:pb.ConversationSettingKey.IsFolded)
    IsFolded = 3,
    // @@protoc_insertion_point(enum_value:pb.ConversationSettingKey.ConversationAlias)
    ConversationAlias = 4,
    // @@protoc_insertion_point(enum_value:pb.ConversationSettingKey.NicknameInConversation)
    NicknameInConversation = 5,
}

impl ::protobuf::Enum for ConversationSettingKey {
    const NAME: &'static str = "ConversationSettingKey";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConversationSettingKey> {
        match value {
            0 => ::std::option::Option::Some(ConversationSettingKey::IsPinned),
            1 => ::std::option::Option::Some(ConversationSettingKey::IsMuted),
            2 => ::std::option::Option::Some(ConversationSettingKey::IsBlocked),
            3 => ::std::option::Option::Some(ConversationSettingKey::IsFolded),
            4 => ::std::option::Option::Some(ConversationSettingKey::ConversationAlias),
            5 => ::std::option::Option::Some(ConversationSettingKey::NicknameInConversation),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ConversationSettingKey] = &[
        ConversationSettingKey::IsPinned,
        ConversationSettingKey::IsMuted,
        ConversationSettingKey::IsBlocked,
        ConversationSettingKey::IsFolded,
        ConversationSettingKey::ConversationAlias,
        ConversationSettingKey::NicknameInConversation,
    ];
}

impl ::protobuf::EnumFull for ConversationSettingKey {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ConversationSettingKey").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ConversationSettingKey {
    fn default() -> Self {
        ConversationSettingKey::IsPinned
    }
}

impl ConversationSettingKey {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConversationSettingKey>("ConversationSettingKey")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ccommon.proto\x12\x02pb\"\x97\x02\n\rRequestHeader\x12\x14\n\x05app\
    Id\x18\x01\x20\x01(\tR\x05appId\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\
    \x06userId\x12\x1a\n\x08clientIp\x18\x03\x20\x01(\tR\x08clientIp\x12\x1c\
    \n\tinstallId\x18\x04\x20\x01(\tR\tinstallId\x12(\n\x08platform\x18\x05\
    \x20\x01(\x0e2\x0c.pb.PlatformR\x08platform\x12\x20\n\x0bdeviceModel\x18\
    \x06\x20\x01(\tR\x0bdeviceModel\x12\x1c\n\tosVersion\x18\x07\x20\x01(\tR\
    \tosVersion\x12\x1e\n\nappVersion\x18\x08\x20\x01(\tR\nappVersion\x12\
    \x14\n\x05extra\x18\t\x20\x01(\tR\x05extra\"\x84\x01\n\x0fToastActionDat\
    a\x12/\n\x05level\x18\x01\x20\x01(\x0e2\x19.pb.ToastActionData.LevelR\
    \x05level\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"&\n\x05Le\
    vel\x12\x08\n\x04INFO\x10\0\x12\x08\n\x04WARN\x10\x01\x12\t\n\x05ERROR\
    \x10\x02\"\xee\x01\n\x0fAlertActionData\x12\x14\n\x05title\x18\x01\x20\
    \x01(\tR\x05title\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\
    \x12>\n\nbuttonType\x18\x03\x20\x01(\x0e2\x1e.pb.AlertActionData.ButtonT\
    ypeR\nbuttonType\x12\x20\n\x0bbuttonLabel\x18\x04\x20\x01(\tR\x0bbuttonL\
    abel\x12\x1e\n\nbuttonData\x18\x05\x20\x01(\tR\nbuttonData\")\n\nButtonT\
    ype\x12\r\n\tNO_BUTTON\x10\0\x12\x0c\n\x08JUMP_URL\x10\x01\"\xa4\x01\n\
    \x0eResponseHeader\x12$\n\x04code\x18\x01\x20\x01(\x0e2\x10.pb.ResponseC\
    odeR\x04code\x126\n\nactionType\x18\x02\x20\x01(\x0e2\x16.pb.ResponseAct\
    ionTypeR\nactionType\x12\x1e\n\nactionData\x18\x03\x20\x01(\tR\nactionDa\
    ta\x12\x14\n\x05extra\x18\x04\x20\x01(\tR\x05extra\"\x96\x06\n\x07Messag\
    e\x12\x1c\n\tmessageId\x18\x01\x20\x01(\tR\tmessageId\x12\x12\n\x04uuid\
    \x18\x02\x20\x01(\tR\x04uuid\x12&\n\x0econversationId\x18\x03\x20\x01(\t\
    R\x0econversationId\x12@\n\x10conversationType\x18\x04\x20\x01(\x0e2\x14\
    .pb.ConversationTypeR\x10conversationType\x12*\n\x06sender\x18\x05\x20\
    \x01(\x0b2\x12.pb.Message.SenderR\x06sender\x12\x18\n\x07content\x18\x06\
    \x20\x01(\x0cR\x07content\x128\n\x0bcontentType\x18\x07\x20\x01(\x0e2\
    \x16.pb.MessageContentTypeR\x0bcontentType\x12\x1a\n\x08sendTime\x18\x08\
    \x20\x01(\x03R\x08sendTime\x12\x1e\n\ninsertTime\x18\t\x20\x01(\x03R\nin\
    sertTime\x12\x10\n\x03seq\x18\n\x20\x01(\x03R\x03seq\x12*\n\x06option\
    \x18\x10\x20\x01(\x0b2\x12.pb.Message.OptionR\x06option\x125\n\x08extraM\
    ap\x18\x11\x20\x03(\x0b2\x19.pb.Message.ExtraMapEntryR\x08extraMap\x1aZ\
    \n\x06Sender\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x16\n\x06avatar\x18\x03\x20\x01(\tR\x06\
    avatar\x12\x14\n\x05extra\x18\x0b\x20\x01(\tR\x05extra\x1a\xa4\x01\n\x06\
    Option\x12*\n\x10storageForServer\x18\x01\x20\x01(\x08R\x10storageForSer\
    ver\x12*\n\x10storageForClient\x18\x02\x20\x01(\x08R\x10storageForClient\
    \x12\x20\n\x0bneedDecrypt\x18\x03\x20\x01(\x08R\x0bneedDecrypt\x12\x20\n\
    \x0bcountUnread\x18\x04\x20\x01(\x08R\x0bcountUnread\x1a;\n\rExtraMapEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\x95\x02\n\x06Notice\x12\x1a\n\x08n\
    oticeId\x18\x01\x20\x01(\tR\x08noticeId\x12&\n\x0econversationId\x18\x02\
    \x20\x01(\tR\x0econversationId\x12@\n\x10conversationType\x18\x03\x20\
    \x01(\x0e2\x14.pb.ConversationTypeR\x10conversationType\x12\x18\n\x07con\
    tent\x18\x04\x20\x01(\tR\x07content\x127\n\x0bcontentType\x18\x05\x20\
    \x01(\x0e2\x15.pb.NoticeContentTypeR\x0bcontentType\x12\x1e\n\nupdateTim\
    e\x18\x06\x20\x01(\x03R\nupdateTime\x12\x12\n\x04sort\x18\x07\x20\x01(\
    \x03R\x04sort*d\n\x08Platform\x12\x07\n\x03IOS\x10\0\x12\x0b\n\x07ANDROI\
    D\x10\x01\x12\x07\n\x03WEB\x10\x02\x12\x0b\n\x07WINDOWS\x10\x03\x12\x07\
    \n\x03MAC\x10\x04\x12\t\n\x05LINUX\x10\x05\x12\x08\n\x04Ipad\x10\x06\x12\
    \x0e\n\nAndroidPad\x10\x07*\x81\x01\n\x0cResponseCode\x12\x0b\n\x07SUCCE\
    SS\x10\0\x12\x10\n\x0cINVALID_DATA\x10\x01\x12\x10\n\x0cUNAUTHORIZED\x10\
    \x02\x12\r\n\tFORBIDDEN\x10\x03\x12\x12\n\x0eINVALID_METHOD\x10\x04\x12\
    \x0b\n\x07TIMEOUT\x10\x05\x12\x10\n\x0cSERVER_ERROR\x10\x06*a\n\x12Respo\
    nseActionType\x12\x0f\n\x0bNONE_ACTION\x10\0\x12\x10\n\x0cTOAST_ACTION\
    \x10\x01\x12\x10\n\x0cALERT_ACTION\x10\x02\x12\x16\n\x12SECOND_AUTH_ACTI\
    ON\x10\x03*\xe6\x02\n\x18WebsocketCustomCloseCode\x12\x11\n\rCloseCodeZe\
    ro\x10\0\x12\x19\n\x14CloseCodeNormalClose\x10\xe8\x07\x12\x17\n\x12Clos\
    eCodeGoingAway\x10\xe9\x07\x12\x1b\n\x16CloseCodeProtocolError\x10\xea\
    \x07\x12\x1d\n\x18CloseCodeUnsupportedData\x10\xeb\x07\x12\x1e\n\x19Clos\
    eCodeNoStatusReceived\x10\xed\x07\x12\x1d\n\x18CloseCodeAbnormalClosure\
    \x10\xee\x07\x12\"\n\x1dCloseCodeAuthenticationFailed\x10\xa1\x1f\x12!\n\
    \x1cCloseCodeDuplicateConnection\x10\xa2\x1f\x12!\n\x1cCloseCodeServerIn\
    ternalError\x10\xa3\x1f\x12\x1e\n\x19CloseCodeHeartbeatTimeout\x10\xa4\
    \x1f*;\n\x10ConversationType\x12\n\n\x06Single\x10\0\x12\t\n\x05Group\
    \x10\x01\x12\x10\n\x0cSubscription\x10\x02*M\n\x11NoticeContentType\x12\
    \x14\n\x10NewFriendRequest\x10\0\x12\x10\n\x0cJoinNewGroup\x10\x01\x12\
    \x10\n\x0cOnlineStatus\x10\x02*o\n\x12MessageContentType\x12\x08\n\x04Te\
    xt\x10\0\x12\x0c\n\x08Markdown\x10\x01\x12\t\n\x05Image\x10\x02\x12\t\n\
    \x05Voice\x10\x03\x12\t\n\x05Video\x10\x04\x12\n\n\x06Typing\x10e\x12\
    \x08\n\x04Read\x10f\x12\n\n\x06Recall\x10g*\x83\x01\n\x16ConversationSet\
    tingKey\x12\x0c\n\x08IsPinned\x10\0\x12\x0b\n\x07IsMuted\x10\x01\x12\r\n\
    \tIsBlocked\x10\x02\x12\x0c\n\x08IsFolded\x10\x03\x12\x15\n\x11Conversat\
    ionAlias\x10\x04\x12\x1a\n\x16NicknameInConversation\x10\x05B\x06Z\x04./\
    pbJ\xfeC\n\x07\x12\x05\0\0\xe0\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\
    \x08\n\x01\x02\x12\x03\x01\0\x0b\n\x08\n\x01\x08\x12\x03\x02\0\x1b\n\t\n\
    \x02\x08\x0b\x12\x03\x02\0\x1b\n\"\n\x02\x05\0\x12\x04\x05\0\x0e\x01\x1a\
    \x16Platform\x20\xe5\xb9\xb3\xe5\x8f\xb0\xe6\x9e\x9a\xe4\xb8\xbe\n\n\n\n\
    \x03\x05\0\x01\x12\x03\x05\x05\r\n\x12\n\x04\x05\0\x02\0\x12\x03\x06\x02\
    \n\"\x05\x20ios\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x02\x05\n\x0c\
    \n\x05\x05\0\x02\0\x02\x12\x03\x06\x08\t\n\x16\n\x04\x05\0\x02\x01\x12\
    \x03\x07\x02\x0e\"\t\x20android\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\
    \x07\x02\t\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x07\x0c\r\n\x12\n\x04\
    \x05\0\x02\x02\x12\x03\x08\x02\n\"\x05\x20web\n\n\x0c\n\x05\x05\0\x02\
    \x02\x01\x12\x03\x08\x02\x05\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08\
    \x08\t\n\x16\n\x04\x05\0\x02\x03\x12\x03\t\x02\x0e\"\t\x20windows\n\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x02\t\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\t\x0c\r\n\x12\n\x04\x05\0\x02\x04\x12\x03\n\x02\n\"\x05\x20\
    mac\n\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\n\x02\x05\n\x0c\n\x05\x05\0\
    \x02\x04\x02\x12\x03\n\x08\t\n\x14\n\x04\x05\0\x02\x05\x12\x03\x0b\x02\
    \x0c\"\x07\x20linux\n\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0b\x02\x07\
    \n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0b\n\x0b\n\x13\n\x04\x05\0\x02\
    \x06\x12\x03\x0c\x02\x0b\"\x06\x20ipad\n\n\x0c\n\x05\x05\0\x02\x06\x01\
    \x12\x03\x0c\x02\x06\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\x0c\t\n\n\x1a\
    \n\x04\x05\0\x02\x07\x12\x03\r\x02\x11\"\r\x20android\x20pad\n\n\x0c\n\
    \x05\x05\0\x02\x07\x01\x12\x03\r\x02\x0c\n\x0c\n\x05\x05\0\x02\x07\x02\
    \x12\x03\r\x0f\x10\n$\n\x02\x04\0\x12\x04\x11\0\x1b\x01\x1a\x18RequestHe\
    ader\x20\xe8\xaf\xb7\xe6\xb1\x82\xe5\xa4\xb4\n\n\n\n\x03\x04\0\x01\x12\
    \x03\x11\x08\x15\n\x17\n\x04\x04\0\x02\0\x12\x03\x12\x02\x13\"\n\x20\xe5\
    \xba\x94\xe7\x94\xa8id\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x12\x02\x08\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x12\t\x0e\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x12\x11\x12\n\x17\n\x04\x04\0\x02\x01\x12\x03\x13\x02\x14\"\
    \n\x20\xe7\x94\xa8\xe6\x88\xb7id\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\
    \x13\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x13\t\x0f\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\x13\x12\x13\n\x1a\n\x04\x04\0\x02\x02\x12\x03\
    \x14\x02\x16\"\r\x20\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xafip\n\n\x0c\n\x05\
    \x04\0\x02\x02\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x03\x14\t\x11\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x14\x14\x15\n1\n\
    \x04\x04\0\x02\x03\x12\x03\x15\x02\x17\"$\x20\xe5\xae\x89\xe8\xa3\x85\
    \xe5\x90\x8e\xe5\x90\x91\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8\xe6\xb3\xa8\
    \xe5\x86\x8c\xe7\x9a\x84UUID\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x15\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x15\t\x12\n\x0c\n\x05\x04\
    \0\x02\x03\x03\x12\x03\x15\x15\x16\n\x15\n\x04\x04\0\x02\x04\x12\x03\x16\
    \x02\x18\"\x08\x20\xe5\xb9\xb3\xe5\x8f\xb0\n\n\x0c\n\x05\x04\0\x02\x04\
    \x06\x12\x03\x16\x02\n\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x16\x0b\x13\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x16\x16\x17\n\x1b\n\x04\x04\0\x02\
    \x05\x12\x03\x17\x02\x19\"\x0e\x20\xe8\xae\xbe\xe5\xa4\x87\xe5\x9e\x8b\
    \xe5\x8f\xb7\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\x17\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x03\x17\t\x14\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03\x17\x17\x18\n!\n\x04\x04\0\x02\x06\x12\x03\x18\x02\x17\"\x14\
    \x20\xe6\x93\x8d\xe4\xbd\x9c\xe7\xb3\xbb\xe7\xbb\x9f\xe7\x89\x88\xe6\x9c\
    \xac\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x18\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03\x18\t\x12\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x18\x15\x16\n\x18\n\x04\x04\0\x02\x07\x12\x03\x19\x02\x18\"\x0b\x20app\
    \xe7\x89\x88\xe6\x9c\xac\n\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x19\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x19\t\x13\n\x0c\n\x05\x04\0\
    \x02\x07\x03\x12\x03\x19\x16\x17\n\x1b\n\x04\x04\0\x02\x08\x12\x03\x1a\
    \x02\x13\"\x0e\x20\xe9\xa2\x9d\xe5\xa4\x96\xe4\xbf\xa1\xe6\x81\xaf\n\n\
    \x0c\n\x05\x04\0\x02\x08\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x08\x01\x12\x03\x1a\t\x0e\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1a\x11\
    \x12\n\x19\n\x02\x05\x01\x12\x04\x1e\0&\x01\x1a\rResponseCode\n\n\n\n\
    \x03\x05\x01\x01\x12\x03\x1e\x05\x11\n\x15\n\x04\x05\x01\x02\0\x12\x03\
    \x1f\x02\x0e\"\x08\x20\xe6\x88\x90\xe5\x8a\x9f\n\n\x0c\n\x05\x05\x01\x02\
    \0\x01\x12\x03\x1f\x02\t\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x1f\x0c\r\
    \n\x1e\n\x04\x05\x01\x02\x01\x12\x03\x20\x02\x13\"\x11\x20\xe6\x97\xa0\
    \xe6\x95\x88\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\n\n\x0c\n\x05\x05\x01\
    \x02\x01\x01\x12\x03\x20\x02\x0e\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\
    \x20\x11\x12\n\x18\n\x04\x05\x01\x02\x02\x12\x03!\x02\x13\"\x0b\x20\xe6\
    \x9c\xaa\xe6\x8e\x88\xe6\x9d\x83\n\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\
    \x03!\x02\x0e\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03!\x11\x12\n\x1b\n\
    \x04\x05\x01\x02\x03\x12\x03\"\x02\x10\"\x0e\x20\xe7\xa6\x81\xe6\xad\xa2\
    \xe8\xae\xbf\xe9\x97\xae\n\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\"\x02\
    \x0b\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\"\x0e\x0f\n\x1e\n\x04\x05\
    \x01\x02\x04\x12\x03#\x02\x15\"\x11\x20\xe6\x97\xa0\xe6\x95\x88\xe7\x9a\
    \x84\xe6\x96\xb9\xe6\xb3\x95\n\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03#\
    \x02\x10\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03#\x13\x14\n\x15\n\x04\
    \x05\x01\x02\x05\x12\x03$\x02\x0e\"\x08\x20\xe8\xb6\x85\xe6\x97\xb6\n\n\
    \x0c\n\x05\x05\x01\x02\x05\x01\x12\x03$\x02\t\n\x0c\n\x05\x05\x01\x02\
    \x05\x02\x12\x03$\x0c\r\n\x1e\n\x04\x05\x01\x02\x06\x12\x03%\x02\x13\"\
    \x11\x20\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8\xe9\x94\x99\xe8\xaf\xaf\n\n\
    \x0c\n\x05\x05\x01\x02\x06\x01\x12\x03%\x02\x0e\n\x0c\n\x05\x05\x01\x02\
    \x06\x02\x12\x03%\x11\x12\nJ\n\x02\x05\x02\x12\x04)\0.\x01\x1a>ResponseA\
    ctionType\x20\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe6\x94\xb6\xe5\x88\
    \xb0\xe5\x93\x8d\xe5\xba\x94\xe5\x90\x8e\xe5\x81\x9a\xe7\x9a\x84\xe5\x8a\
    \xa8\xe4\xbd\x9c\xe7\xb1\xbb\xe5\x9e\x8b\n\n\n\n\x03\x05\x02\x01\x12\x03\
    )\x05\x17\n\x18\n\x04\x05\x02\x02\0\x12\x03*\x02\x12\"\x0b\x20\xe6\x97\
    \xa0\xe5\x8a\xa8\xe4\xbd\x9c\n\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03*\
    \x02\r\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03*\x10\x11\n\x1a\n\x04\x05\
    \x02\x02\x01\x12\x03+\x02\x13\"\r\x20toast\xe6\x8f\x90\xe7\xa4\xba\n\n\
    \x0c\n\x05\x05\x02\x02\x01\x01\x12\x03+\x02\x0e\n\x0c\n\x05\x05\x02\x02\
    \x01\x02\x12\x03+\x11\x12\n\x1a\n\x04\x05\x02\x02\x02\x12\x03,\x02\x13\"\
    \r\x20alert\xe6\x8f\x90\xe7\xa4\xba\n\n\x0c\n\x05\x05\x02\x02\x02\x01\
    \x12\x03,\x02\x0e\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03,\x11\x12\n\xa4\
    \x01\n\x04\x05\x02\x02\x03\x12\x03-\x02\x19\"\x96\x01\x20\xe4\xba\x8c\
    \xe6\xac\xa1\xe8\xae\xa4\xe8\xaf\x81\x20\xe4\xb8\x80\xe6\xae\xb5\xe6\x97\
    \xb6\xe9\x97\xb4\xe5\x86\x85\xe6\xb2\xa1\xe6\x9c\x89\xe8\xbf\x9b\xe8\xa1\
    \x8c\xe4\xba\x8c\xe6\xac\xa1\xe9\xaa\x8c\xe8\xaf\x81\x20\xe8\x80\x8c\xe4\
    \xb8\x94\xe6\xad\xa4\xe6\xac\xa1\xe6\x98\xaf\xe9\xab\x98\xe5\x8d\xb1\xe6\
    \x93\x8d\xe4\xbd\x9c\x20\xe6\xad\xa4\xe6\x97\xb6\xe5\xae\xa2\xe6\x88\xb7\
    \xe7\xab\xaf\xe5\xba\x94\xe8\xaf\xa5\xe5\xbc\xb9\xe5\x87\xba\xe4\xba\x8c\
    \xe6\xac\xa1\xe9\xaa\x8c\xe8\xaf\x81\xe7\x95\x8c\xe9\x9d\xa2\x20\xe9\xaa\
    \x8c\xe8\xaf\x81\xe7\x9f\xad\xe4\xbf\xa1\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\
    \x81\n\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03-\x02\x14\n\x0c\n\x05\x05\
    \x02\x02\x03\x02\x12\x03-\x17\x18\nn\n\x02\x04\x01\x12\x041\09\x01\x1abT\
    oastActionData\x20toast\xe6\x8f\x90\xe7\xa4\xba\x20\xe5\xae\xa2\xe6\x88\
    \xb7\xe7\xab\xaf\xe6\xa0\xb9\xe6\x8d\xaelevel\xe6\x98\xbe\xe7\xa4\xba\
    \xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84\xe9\xa2\x9c\xe8\x89\xb2\x20\xe5\x8f\
    \xaf\xe8\x83\xbd\xe6\x8c\x81\xe7\xbb\xad\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\
    \x84\xe6\x97\xb6\xe9\x97\xb4\n\n\n\n\x03\x04\x01\x01\x12\x031\x08\x17\n\
    \x0c\n\x04\x04\x01\x04\0\x12\x042\x026\x03\n\x0c\n\x05\x04\x01\x04\0\x01\
    \x12\x032\x07\x0c\n\x17\n\x06\x04\x01\x04\0\x02\0\x12\x033\x04\r\"\x08\
    \x20\xe4\xbf\xa1\xe6\x81\xaf\n\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\
    \x033\x04\x08\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x033\x0b\x0c\n\x17\
    \n\x06\x04\x01\x04\0\x02\x01\x12\x034\x04\r\"\x08\x20\xe8\xad\xa6\xe5\
    \x91\x8a\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x034\x04\x08\n\x0e\
    \n\x07\x04\x01\x04\0\x02\x01\x02\x12\x034\x0b\x0c\n\x17\n\x06\x04\x01\
    \x04\0\x02\x02\x12\x035\x04\x0e\"\x08\x20\xe9\x94\x99\xe8\xaf\xaf\n\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x035\x04\t\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x02\x02\x12\x035\x0c\r\n\x15\n\x04\x04\x01\x02\0\x12\x037\x02\
    \x12\"\x08\x20\xe7\xba\xa7\xe5\x88\xab\n\n\x0c\n\x05\x04\x01\x02\0\x06\
    \x12\x037\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x037\x08\r\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x037\x10\x11\n\x15\n\x04\x04\x01\x02\x01\x12\
    \x038\x02\x15\"\x08\x20\xe6\xb6\x88\xe6\x81\xaf\n\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x038\t\
    \x10\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x038\x13\x14\nl\n\x02\x04\x02\
    \x12\x04<\0F\x01\x1a`AlertActionData\x20alert\xe6\x8f\x90\xe7\xa4\xba\
    \x20\xe6\xb0\xb8\xe8\xbf\x9c\xe6\x9c\x89\xe4\xb8\x80\xe4\xb8\xaa\xe5\x85\
    \xb3\xe9\x97\xad\xe6\x8c\x89\xe9\x92\xae\x20\xe4\xbb\xa5\xe4\xb8\x8b\xe6\
    \x8f\x8f\xe8\xbf\xb0\xe7\x9a\x84\xe6\x98\xaf\xe5\x8f\xa6\xe4\xb8\x80\xe4\
    \xb8\xaa\xe6\x93\x8d\xe4\xbd\x9c\xe6\x8c\x89\xe9\x92\xae\n\n\n\n\x03\x04\
    \x02\x01\x12\x03<\x08\x17\n\x0c\n\x04\x04\x02\x04\0\x12\x04=\x02@\x03\n\
    \x0c\n\x05\x04\x02\x04\0\x01\x12\x03=\x07\x11\n\x1a\n\x06\x04\x02\x04\0\
    \x02\0\x12\x03>\x04\x12\"\x0b\x20\xe6\x97\xa0\xe6\x8c\x89\xe9\x92\xae\n\
    \n\x0e\n\x07\x04\x02\x04\0\x02\0\x01\x12\x03>\x04\r\n\x0e\n\x07\x04\x02\
    \x04\0\x02\0\x02\x12\x03>\x10\x11\n\x1a\n\x06\x04\x02\x04\0\x02\x01\x12\
    \x03?\x04\x11\"\x0b\x20\xe8\xb7\xb3\xe8\xbd\xacurl\n\n\x0e\n\x07\x04\x02\
    \x04\0\x02\x01\x01\x12\x03?\x04\x0c\n\x0e\n\x07\x04\x02\x04\0\x02\x01\
    \x02\x12\x03?\x0f\x10\n\x15\n\x04\x04\x02\x02\0\x12\x03A\x02\x13\"\x08\
    \x20\xe6\xa0\x87\xe9\xa2\x98\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03A\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03A\t\x0e\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03A\x11\x12\n\x15\n\x04\x04\x02\x02\x01\x12\x03B\x02\
    \x15\"\x08\x20\xe6\xb6\x88\xe6\x81\xaf\n\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03B\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03B\t\x10\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03B\x13\x14\n\x1b\n\x04\x04\x02\x02\x02\
    \x12\x03C\x02\x1c\"\x0e\x20\xe6\x8c\x89\xe9\x92\xae\xe7\xb1\xbb\xe5\x9e\
    \x8b\n\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03C\x02\x0c\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03C\r\x17\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03C\
    \x1a\x1b\n\x1b\n\x04\x04\x02\x02\x03\x12\x03D\x02\x19\"\x0e\x20\xe6\x8c\
    \x89\xe9\x92\xae\xe6\xa0\x87\xe7\xad\xbe\n\n\x0c\n\x05\x04\x02\x02\x03\
    \x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03D\t\x14\n\
    \x0c\n\x05\x04\x02\x02\x03\x03\x12\x03D\x17\x18\n\x1b\n\x04\x04\x02\x02\
    \x04\x12\x03E\x02\x18\"\x0e\x20\xe6\x8c\x89\xe9\x92\xae\xe6\x95\xb0\xe6\
    \x8d\xae\n\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03E\x02\x08\n\x0c\n\x05\
    \x04\x02\x02\x04\x01\x12\x03E\t\x13\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\
    \x03E\x16\x17\n%\n\x02\x04\x03\x12\x04I\0N\x01\x1a\x19ResponseHeader\x20\
    \xe5\x93\x8d\xe5\xba\x94\xe5\xa4\xb4\n\n\n\n\x03\x04\x03\x01\x12\x03I\
    \x08\x16\n\x18\n\x04\x04\x03\x02\0\x12\x03J\x02\x18\"\x0b\x20\xe9\x94\
    \x99\xe8\xaf\xaf\xe7\xa0\x81\n\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03J\
    \x02\x0e\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03J\x0f\x13\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03J\x16\x17\n\x1b\n\x04\x04\x03\x02\x01\x12\x03K\x02\
    $\"\x0e\x20\xe5\x8a\xa8\xe4\xbd\x9c\xe7\xb1\xbb\xe5\x9e\x8b\n\n\x0c\n\
    \x05\x04\x03\x02\x01\x06\x12\x03K\x02\x14\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03K\x15\x1f\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03K\"#\n)\n\
    \x04\x04\x03\x02\x02\x12\x03L\x02\x18\"\x1c\x20\xe5\x8a\xa8\xe4\xbd\x9c\
    \xe6\x95\xb0\xe6\x8d\xae\x20json\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2\n\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03L\t\x13\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03L\x16\x17\
    \n\x1b\n\x04\x04\x03\x02\x03\x12\x03M\x02\x13\"\x0e\x20\xe9\xa2\x9d\xe5\
    \xa4\x96\xe4\xbf\xa1\xe6\x81\xaf\n\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\
    \x03M\x02\x08\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03M\t\x0e\n\x0c\n\x05\
    \x04\x03\x02\x03\x03\x12\x03M\x11\x12\n\xf1\x01\n\x02\x05\x03\x12\x04T\0\
    a\x01\x1a\xe4\x01WebsocketCustomCloseCode\x20websocket\xe5\x85\xb3\xe9\
    \x97\xad\xe7\xa0\x81\nYou\x20can\x20define\x20custom\x20codes\x20in\x20t\
    he\x203000-4999\x20range.\nThe\x203000-3999\x20range\x20is\x20reserved\
    \x20for\x20use\x20by\x20libraries,\x20frameworks\x20and\x20applications.\
    \nThe\x204000-4999\x20range\x20is\x20reserved\x20for\x20private\x20use.\
    \n\n\n\n\x03\x05\x03\x01\x12\x03T\x05\x1d\n)\n\x04\x05\x03\x02\0\x12\x03\
    U\x02\x14\"\x1c\x20pb\xe5\xbf\x85\xe9\xa1\xbb\xe6\x9c\x89\xe4\xb8\x80\
    \xe4\xb8\xaa\xe9\xbb\x98\xe8\xae\xa4\xe5\x80\xbc\n\n\x0c\n\x05\x05\x03\
    \x02\0\x01\x12\x03U\x02\x0f\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03U\x12\
    \x13\n\x1b\n\x04\x05\x03\x02\x01\x12\x03V\x02\x1e\"\x0e\x20\xe6\xad\xa3\
    \xe5\xb8\xb8\xe5\x85\xb3\xe9\x97\xad\n\n\x0c\n\x05\x05\x03\x02\x01\x01\
    \x12\x03V\x02\x16\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03V\x19\x1d\n\x15\
    \n\x04\x05\x03\x02\x02\x12\x03W\x02\x1c\"\x08\x20\xe7\xa6\xbb\xe5\xbc\
    \x80\n\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x03W\x02\x14\n\x0c\n\x05\x05\
    \x03\x02\x02\x02\x12\x03W\x17\x1b\n\x1b\n\x04\x05\x03\x02\x03\x12\x03X\
    \x02\x20\"\x0e\x20\xe5\x8d\x8f\xe8\xae\xae\xe9\x94\x99\xe8\xaf\xaf\n\n\
    \x0c\n\x05\x05\x03\x02\x03\x01\x12\x03X\x02\x18\n\x0c\n\x05\x05\x03\x02\
    \x03\x02\x12\x03X\x1b\x1f\n!\n\x04\x05\x03\x02\x04\x12\x03Y\x02\"\"\x14\
    \x20\xe4\xb8\x8d\xe6\x94\xaf\xe6\x8c\x81\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\
    \xae\n\n\x0c\n\x05\x05\x03\x02\x04\x01\x12\x03Y\x02\x1a\n\x0c\n\x05\x05\
    \x03\x02\x04\x02\x12\x03Y\x1d!\n!\n\x04\x05\x03\x02\x05\x12\x03Z\x02#\"\
    \x14\x20\xe6\xb2\xa1\xe6\x9c\x89\xe6\x94\xb6\xe5\x88\xb0\xe7\x8a\xb6\xe6\
    \x80\x81\n\n\x0c\n\x05\x05\x03\x02\x05\x01\x12\x03Z\x02\x1b\n\x0c\n\x05\
    \x05\x03\x02\x05\x02\x12\x03Z\x1e\"\n\x1b\n\x04\x05\x03\x02\x06\x12\x03[\
    \x02\"\"\x0e\x20\xe5\xbc\x82\xe5\xb8\xb8\xe5\x85\xb3\xe9\x97\xad\n\n\x0c\
    \n\x05\x05\x03\x02\x06\x01\x12\x03[\x02\x1a\n\x0c\n\x05\x05\x03\x02\x06\
    \x02\x12\x03[\x1d!\n\x1b\n\x04\x05\x03\x02\x07\x12\x03]\x02'\"\x0e\x20\
    \xe8\xae\xa4\xe8\xaf\x81\xe5\xa4\xb1\xe8\xb4\xa5\n\n\x0c\n\x05\x05\x03\
    \x02\x07\x01\x12\x03]\x02\x1f\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\x03]\"\
    &\n\x1b\n\x04\x05\x03\x02\x08\x12\x03^\x02&\"\x0e\x20\xe9\x87\x8d\xe5\
    \xa4\x8d\xe8\xbf\x9e\xe6\x8e\xa5\n\n\x0c\n\x05\x05\x03\x02\x08\x01\x12\
    \x03^\x02\x1e\n\x0c\n\x05\x05\x03\x02\x08\x02\x12\x03^!%\n$\n\x04\x05\
    \x03\x02\t\x12\x03_\x02&\"\x17\x20\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8\
    \xe5\x86\x85\xe9\x83\xa8\xe9\x94\x99\xe8\xaf\xaf\n\n\x0c\n\x05\x05\x03\
    \x02\t\x01\x12\x03_\x02\x1e\n\x0c\n\x05\x05\x03\x02\t\x02\x12\x03_!%\n\
    \x1b\n\x04\x05\x03\x02\n\x12\x03`\x02#\"\x0e\x20\xe5\xbf\x83\xe8\xb7\xb3\
    \xe8\xb6\x85\xe6\x97\xb6\n\n\x0c\n\x05\x05\x03\x02\n\x01\x12\x03`\x02\
    \x1b\n\x0c\n\x05\x05\x03\x02\n\x02\x12\x03`\x1e\"\n*\n\x02\x05\x04\x12\
    \x04d\0k\x01\x1a\x1eConversationType\x20\xe4\xbc\x9a\xe8\xaf\x9d\xe7\xb1\
    \xbb\xe5\x9e\x8b\n\n\n\n\x03\x05\x04\x01\x12\x03d\x05\x15\n\x15\n\x04\
    \x05\x04\x02\0\x12\x03f\x02\r\x1a\x08\x20\xe5\x8d\x95\xe8\x81\x8a\n\n\
    \x0c\n\x05\x05\x04\x02\0\x01\x12\x03f\x02\x08\n\x0c\n\x05\x05\x04\x02\0\
    \x02\x12\x03f\x0b\x0c\n\x15\n\x04\x05\x04\x02\x01\x12\x03h\x02\x0c\x1a\
    \x08\x20\xe7\xbe\xa4\xe8\x81\x8a\n\n\x0c\n\x05\x05\x04\x02\x01\x01\x12\
    \x03h\x02\x07\n\x0c\n\x05\x05\x04\x02\x01\x02\x12\x03h\n\x0b\n\x18\n\x04\
    \x05\x04\x02\x02\x12\x03j\x02\x13\x1a\x0b\x20\xe8\xae\xa2\xe9\x98\x85\
    \xe5\x8f\xb7\n\n\x0c\n\x05\x05\x04\x02\x02\x01\x12\x03j\x02\x0e\n\x0c\n\
    \x05\x05\x04\x02\x02\x02\x12\x03j\x11\x12\n1\n\x02\x05\x05\x12\x04n\0u\
    \x01\x1a%NoticeContentType\x20\xe9\x80\x9a\xe7\x9f\xa5\xe5\x86\x85\xe5\
    \xae\xb9\xe7\xb1\xbb\xe5\x9e\x8b\n\n\n\n\x03\x05\x05\x01\x12\x03n\x05\
    \x16\n$\n\x04\x05\x05\x02\0\x12\x03p\x02\x17\x1a\x17\x20\xe6\x9c\x89\xe6\
    \x96\xb0\xe7\x9a\x84\xe5\xa5\xbd\xe5\x8f\x8b\xe8\xaf\xb7\xe6\xb1\x82\n\n\
    \x0c\n\x05\x05\x05\x02\0\x01\x12\x03p\x02\x12\n\x0c\n\x05\x05\x05\x02\0\
    \x02\x12\x03p\x15\x16\n!\n\x04\x05\x05\x02\x01\x12\x03r\x02\x13\x1a\x14\
    \x20\xe5\x8a\xa0\xe5\x85\xa5\xe5\x88\xb0\xe4\xba\x86\xe6\x96\xb0\xe7\xbe\
    \xa4\n\n\x0c\n\x05\x05\x05\x02\x01\x01\x12\x03r\x02\x0e\n\x0c\n\x05\x05\
    \x05\x02\x01\x02\x12\x03r\x11\x12\n\x1b\n\x04\x05\x05\x02\x02\x12\x03t\
    \x02\x13\x1a\x0e\x20\xe5\x9c\xa8\xe7\xba\xbf\xe7\x8a\xb6\xe6\x80\x81\n\n\
    \x0c\n\x05\x05\x05\x02\x02\x01\x12\x03t\x02\x0e\n\x0c\n\x05\x05\x05\x02\
    \x02\x02\x12\x03t\x11\x12\n3\n\x02\x05\x06\x12\x05x\0\x8a\x01\x01\x1a&Me\
    ssageContentType\x20\xe6\xb6\x88\xe6\x81\xaf\xe5\x86\x85\xe5\xae\xb9\xe7\
    \xb1\xbb\xe5\x9e\x8b\n\n\n\n\x03\x05\x06\x01\x12\x03x\x05\x17\n\x15\n\
    \x04\x05\x06\x02\0\x12\x03z\x02\x0b\x1a\x08\x20\xe5\x9b\xbe\xe6\x96\x87\
    \n\n\x0c\n\x05\x05\x06\x02\0\x01\x12\x03z\x02\x06\n\x0c\n\x05\x05\x06\
    \x02\0\x02\x12\x03z\t\n\n\x17\n\x04\x05\x06\x02\x01\x12\x03|\x02\x0f\x1a\
    \n\x20Markdown\n\n\x0c\n\x05\x05\x06\x02\x01\x01\x12\x03|\x02\n\n\x0c\n\
    \x05\x05\x06\x02\x01\x02\x12\x03|\r\x0e\n\x15\n\x04\x05\x06\x02\x02\x12\
    \x03~\x02\x0c\x1a\x08\x20\xe5\x9b\xbe\xe7\x89\x87\n\n\x0c\n\x05\x05\x06\
    \x02\x02\x01\x12\x03~\x02\x07\n\x0c\n\x05\x05\x06\x02\x02\x02\x12\x03~\n\
    \x0b\n\x16\n\x04\x05\x06\x02\x03\x12\x04\x80\x01\x02\x0c\x1a\x08\x20\xe8\
    \xaf\xad\xe9\x9f\xb3\n\n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\x80\x01\x02\
    \x07\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\x80\x01\n\x0b\n\x16\n\x04\x05\
    \x06\x02\x04\x12\x04\x82\x01\x02\x0c\x1a\x08\x20\xe8\xa7\x86\xe9\xa2\x91\
    \n\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\x82\x01\x02\x07\n\r\n\x05\x05\
    \x06\x02\x04\x02\x12\x04\x82\x01\n\x0b\n\x1c\n\x04\x05\x06\x02\x05\x12\
    \x04\x85\x01\x02\x0f\x1a\x0e\x20\xe6\xad\xa3\xe5\x9c\xa8\xe8\xbe\x93\xe5\
    \x85\xa5\n\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\x85\x01\x02\x08\n\r\n\
    \x05\x05\x06\x02\x05\x02\x12\x04\x85\x01\x0b\x0e\n\x16\n\x04\x05\x06\x02\
    \x06\x12\x04\x87\x01\x02\r\x1a\x08\x20\xe5\xb7\xb2\xe8\xaf\xbb\n\n\r\n\
    \x05\x05\x06\x02\x06\x01\x12\x04\x87\x01\x02\x06\n\r\n\x05\x05\x06\x02\
    \x06\x02\x12\x04\x87\x01\t\x0c\n\x16\n\x04\x05\x06\x02\x07\x12\x04\x89\
    \x01\x02\x0f\x1a\x08\x20\xe6\x92\xa4\xe5\x9b\x9e\n\n\r\n\x05\x05\x06\x02\
    \x07\x01\x12\x04\x89\x01\x02\x08\n\r\n\x05\x05\x06\x02\x07\x02\x12\x04\
    \x89\x01\x0b\x0e\n5\n\x02\x05\x07\x12\x06\x8d\x01\0\x9a\x01\x01\x1a'Conv\
    ersationSettingKey\x20\xe4\xbc\x9a\xe8\xaf\x9d\xe8\xae\xbe\xe7\xbd\xaeke\
    y\n\n\x0b\n\x03\x05\x07\x01\x12\x04\x8d\x01\x05\x1b\n\x1c\n\x04\x05\x07\
    \x02\0\x12\x04\x8f\x01\x02\x0f\x1a\x0e\x20\xe6\x98\xaf\xe5\x90\xa6\xe7\
    \xbd\xae\xe9\xa1\xb6\n\n\r\n\x05\x05\x07\x02\0\x01\x12\x04\x8f\x01\x02\n\
    \n\r\n\x05\x05\x07\x02\0\x02\x12\x04\x8f\x01\r\x0e\n\x1f\n\x04\x05\x07\
    \x02\x01\x12\x04\x91\x01\x02\x0e\x1a\x11\x20\xe6\x98\xaf\xe5\x90\xa6\xe5\
    \x85\x8d\xe6\x89\x93\xe6\x89\xb0\n\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\
    \x91\x01\x02\t\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\x91\x01\x0c\r\n\x1c\
    \n\x04\x05\x07\x02\x02\x12\x04\x93\x01\x02\x10\x1a\x0e\x20\xe6\x98\xaf\
    \xe5\x90\xa6\xe5\xb1\x8f\xe8\x94\xbd\n\n\r\n\x05\x05\x07\x02\x02\x01\x12\
    \x04\x93\x01\x02\x0b\n\r\n\x05\x05\x07\x02\x02\x02\x12\x04\x93\x01\x0e\
    \x0f\n\x1c\n\x04\x05\x07\x02\x03\x12\x04\x95\x01\x02\x0f\x1a\x0e\x20\xe6\
    \x98\xaf\xe5\x90\xa6\xe6\x8a\x98\xe5\x8f\xa0\n\n\r\n\x05\x05\x07\x02\x03\
    \x01\x12\x04\x95\x01\x02\n\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\x95\x01\
    \r\x0e\n+\n\x04\x05\x07\x02\x04\x12\x04\x97\x01\x02\x18\x1a\x1d\x20\xe8\
    \x87\xaa\xe5\xb7\xb1\xe8\xae\xbe\xe7\xbd\xae\xe7\x9a\x84\xe4\xbc\x9a\xe8\
    \xaf\x9d\xe5\xa4\x87\xe6\xb3\xa8\n\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\
    \x97\x01\x02\x13\n\r\n\x05\x05\x07\x02\x04\x02\x12\x04\x97\x01\x16\x17\n\
    %\n\x04\x05\x07\x02\x05\x12\x04\x99\x01\x02\x1d\x1a\x17\x20\xe5\x9c\xa8\
    \xe4\xbc\x9a\xe8\xaf\x9d\xe4\xb8\xad\xe7\x9a\x84\xe6\x98\xb5\xe7\xa7\xb0\
    \n\n\r\n\x05\x05\x07\x02\x05\x01\x12\x04\x99\x01\x02\x18\n\r\n\x05\x05\
    \x07\x02\x05\x02\x12\x04\x99\x01\x1b\x1c\n\x1d\n\x02\x04\x04\x12\x06\x9d\
    \x01\0\xce\x01\x01\x1a\x0fMessage\x20\xe6\xb6\x88\xe6\x81\xaf\n\n\x0b\n\
    \x03\x04\x04\x01\x12\x04\x9d\x01\x08\x0f\n=\n\x04\x04\x04\x02\0\x12\x04\
    \x9f\x01\x02\x17\x1a/MessageId\x20\xe6\xb6\x88\xe6\x81\xafid\x20\xe7\x94\
    \xb1\xe6\x9c\x8d\xe5\x8a\xa1\xe7\xab\xaf\xe6\x8f\x92\xe5\x85\xa5\xe6\x97\
    \xb6\xe7\x94\x9f\xe6\x88\x90\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x9f\
    \x01\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x9f\x01\t\x12\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\x9f\x01\x15\x16\nW\n\x04\x04\x04\x02\x01\x12\
    \x04\xa1\x01\x02\x12\x1aIUUID\x20\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\
    \xe7\x94\x9f\xe6\x88\x90\xe7\x9a\x84id\x20\xe7\x94\xb1\xe5\xae\xa2\xe6\
    \x88\xb7\xe7\xab\xaf\xe7\x94\x9f\xe6\x88\x90\x20\xe5\x9c\xa8\xe5\xae\xa2\
    \xe6\x88\xb7\xe7\xab\xaf\xe4\xbf\x9d\xe8\xaf\x81\xe5\x94\xaf\xe4\xb8\x80\
    \xe6\x80\xa7\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xa1\x01\x02\x08\n\r\
    \n\x05\x04\x04\x02\x01\x01\x12\x04\xa1\x01\t\r\n\r\n\x05\x04\x04\x02\x01\
    \x03\x12\x04\xa1\x01\x10\x11\n\x96\x01\n\x04\x04\x04\x02\x02\x12\x04\xa4\
    \x01\x02\x1c\x1a\x16\xe5\x8f\x91\xe9\x80\x81\xe5\x88\xb0\xe5\x93\xaa\xe4\
    \xb8\xaa\xe4\xbc\x9a\xe8\xaf\x9d\n\"p\x20\xe5\x8d\x95\xe8\x81\x8a:\x20\
    \xe9\x82\xa3\xe4\xb9\x88\xe8\xaf\xa5\xe5\x80\xbc\xe4\xb8\xba\xe6\x8e\xa5\
    \xe5\x8f\x97\xe8\x80\x85\xe7\x9a\x84id\xef\xbc\x9b\xe7\xbe\xa4\xe8\x81\
    \x8a\xef\xbc\x9a\xe9\x82\xa3\xe4\xb9\x88\xe8\xaf\xa5\xe5\x80\xbc\xe4\xb8\
    \xba\xe7\xbe\xa4id\xef\xbc\x9b\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7\xef\
    \xbc\x9a\xe9\x82\xa3\xe4\xb9\x88\xe8\xaf\xa5\xe5\x80\xbc\xe4\xb8\xba\xe8\
    \xae\xa2\xe9\x98\x85\xe5\x8f\xb7id\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\
    \x04\xa4\x01\x02\x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xa4\x01\t\x17\
    \n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xa4\x01\x1a\x1b\n\x1b\n\x04\x04\
    \x04\x02\x03\x12\x04\xa6\x01\x02(\x1a\r\xe4\xbc\x9a\xe8\xaf\x9d\xe7\xb1\
    \xbb\xe5\x9e\x8b\n\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\xa6\x01\x02\x12\
    \n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xa6\x01\x13#\n\r\n\x05\x04\x04\
    \x02\x03\x03\x12\x04\xa6\x01&'\n\x1a\n\x04\x04\x04\x03\0\x12\x06\xa8\x01\
    \x02\xb1\x01\x03\x1a\n\xe5\x8f\x91\xe9\x80\x81\xe8\x80\x85\n\n\r\n\x05\
    \x04\x04\x03\0\x01\x12\x04\xa8\x01\n\x10\n\x1c\n\x06\x04\x04\x03\0\x02\0\
    \x12\x04\xaa\x01\x04\x12\x1a\x0c\xe5\x8f\x91\xe9\x80\x81\xe8\x80\x85id\n\
    \n\x0f\n\x07\x04\x04\x03\0\x02\0\x05\x12\x04\xaa\x01\x04\n\n\x0f\n\x07\
    \x04\x04\x03\0\x02\0\x01\x12\x04\xaa\x01\x0b\r\n\x0f\n\x07\x04\x04\x03\0\
    \x02\0\x03\x12\x04\xaa\x01\x10\x11\n\x20\n\x06\x04\x04\x03\0\x02\x01\x12\
    \x04\xac\x01\x04\x14\x1a\x10\xe5\x8f\x91\xe9\x80\x81\xe8\x80\x85\xe5\x90\
    \x8d\xe7\xa7\xb0\n\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x05\x12\x04\xac\x01\
    \x04\n\n\x0f\n\x07\x04\x04\x03\0\x02\x01\x01\x12\x04\xac\x01\x0b\x0f\n\
    \x0f\n\x07\x04\x04\x03\0\x02\x01\x03\x12\x04\xac\x01\x12\x13\n\x20\n\x06\
    \x04\x04\x03\0\x02\x02\x12\x04\xae\x01\x04\x16\x1a\x10\xe5\x8f\x91\xe9\
    \x80\x81\xe8\x80\x85\xe5\xa4\xb4\xe5\x83\x8f\n\n\x0f\n\x07\x04\x04\x03\0\
    \x02\x02\x05\x12\x04\xae\x01\x04\n\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x01\
    \x12\x04\xae\x01\x0b\x11\n\x0f\n\x07\x04\x04\x03\0\x02\x02\x03\x12\x04\
    \xae\x01\x14\x15\n\x16\n\x06\x04\x04\x03\0\x02\x03\x12\x04\xb0\x01\x04\
    \x16\x1a\x06extra\n\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x05\x12\x04\xb0\
    \x01\x04\n\n\x0f\n\x07\x04\x04\x03\0\x02\x03\x01\x12\x04\xb0\x01\x0b\x10\
    \n\x0f\n\x07\x04\x04\x03\0\x02\x03\x03\x12\x04\xb0\x01\x13\x15\n5\n\x04\
    \x04\x04\x02\x04\x12\x04\xb2\x01\x02\x14\"'\x20\xe6\x9c\x89\xe5\x8f\xaf\
    \xe8\x83\xbd\xe6\x98\xaf\xe7\xb3\xbb\xe7\xbb\x9f\x20\xe9\x82\xa3\xe4\xb9\
    \x88\xe8\xaf\xa5\xe5\x80\xbc\xe4\xb8\xba\xe7\xa9\xba\n\n\r\n\x05\x04\x04\
    \x02\x04\x06\x12\x04\xb2\x01\x02\x08\n\r\n\x05\x04\x04\x02\x04\x01\x12\
    \x04\xb2\x01\t\x0f\n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\xb2\x01\x12\x13\
    \n\x1b\n\x04\x04\x04\x02\x05\x12\x04\xb5\x01\x02\x14\x1a\r\xe6\xb6\x88\
    \xe6\x81\xaf\xe5\x86\x85\xe5\xae\xb9\n\n\r\n\x05\x04\x04\x02\x05\x05\x12\
    \x04\xb5\x01\x02\x07\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\xb5\x01\x08\
    \x0f\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xb5\x01\x12\x13\n\x1b\n\x04\
    \x04\x04\x02\x06\x12\x04\xb7\x01\x02%\x1a\r\xe6\xb6\x88\xe6\x81\xaf\xe7\
    \xb1\xbb\xe5\x9e\x8b\n\n\r\n\x05\x04\x04\x02\x06\x06\x12\x04\xb7\x01\x02\
    \x14\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\xb7\x01\x15\x20\n\r\n\x05\x04\
    \x04\x02\x06\x03\x12\x04\xb7\x01#$\n.\n\x04\x04\x04\x02\x07\x12\x04\xba\
    \x01\x02\x15\x1a\x20\xe5\x8f\x91\xe9\x80\x81\xe6\x97\xb6\xe9\x97\xb4\x20\
    \xe7\x94\xb1\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe7\x94\x9f\xe6\x88\x90\
    \n\n\r\n\x05\x04\x04\x02\x07\x05\x12\x04\xba\x01\x02\x07\n\r\n\x05\x04\
    \x04\x02\x07\x01\x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x04\x02\x07\x03\
    \x12\x04\xba\x01\x13\x14\n.\n\x04\x04\x04\x02\x08\x12\x04\xbc\x01\x02\
    \x17\x1a\x20\xe6\x8f\x92\xe5\x85\xa5\xe6\x97\xb6\xe9\x97\xb4\x20\xe7\x94\
    \xb1\xe6\x9c\x8d\xe5\x8a\xa1\xe7\xab\xaf\xe7\x94\x9f\xe6\x88\x90\n\n\r\n\
    \x05\x04\x04\x02\x08\x05\x12\x04\xbc\x01\x02\x07\n\r\n\x05\x04\x04\x02\
    \x08\x01\x12\x04\xbc\x01\x08\x12\n\r\n\x05\x04\x04\x02\x08\x03\x12\x04\
    \xbc\x01\x15\x16\n*\n\x04\x04\x04\x02\t\x12\x04\xbe\x01\x02\x11\x1a\x1c\
    \xe5\x9c\xa8\xe4\xbc\x9a\xe8\xaf\x9d\xe4\xb8\xad\xe7\x9a\x84\xe6\xb6\x88\
    \xe6\x81\xaf\xe9\xa1\xba\xe5\xba\x8f\n\n\r\n\x05\x04\x04\x02\t\x05\x12\
    \x04\xbe\x01\x02\x07\n\r\n\x05\x04\x04\x02\t\x01\x12\x04\xbe\x01\x08\x0b\
    \n\r\n\x05\x04\x04\x02\t\x03\x12\x04\xbe\x01\x0e\x10\n\x17\n\x04\x04\x04\
    \x03\x01\x12\x06\xc1\x01\x02\xca\x01\x03\x1a\x07\xe9\x80\x89\xe9\xa1\xb9\
    \n\n\r\n\x05\x04\x04\x03\x01\x01\x12\x04\xc1\x01\n\x10\n/\n\x06\x04\x04\
    \x03\x01\x02\0\x12\x04\xc3\x01\x04\x1e\x1a\x1f\xe6\x9c\x8d\xe5\x8a\xa1\
    \xe7\xab\xaf\xe6\x98\xaf\xe5\x90\xa6\xe4\xbf\x9d\xe5\xad\x98\xe8\xaf\xa5\
    \xe6\xb6\x88\xe6\x81\xaf\n\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x05\x12\x04\
    \xc3\x01\x04\x08\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x01\x12\x04\xc3\x01\t\
    \x19\n\x0f\n\x07\x04\x04\x03\x01\x02\0\x03\x12\x04\xc3\x01\x1c\x1d\n/\n\
    \x06\x04\x04\x03\x01\x02\x01\x12\x04\xc5\x01\x04\x1e\x1a\x1f\xe5\xae\xa2\
    \xe6\x88\xb7\xe7\xab\xaf\xe6\x98\xaf\xe5\x90\xa6\xe4\xbf\x9d\xe5\xad\x98\
    \xe8\xaf\xa5\xe6\xb6\x88\xe6\x81\xaf\n\n\x0f\n\x07\x04\x04\x03\x01\x02\
    \x01\x05\x12\x04\xc5\x01\x04\x08\n\x0f\n\x07\x04\x04\x03\x01\x02\x01\x01\
    \x12\x04\xc5\x01\t\x19\n\x0f\n\x07\x04\x04\x03\x01\x02\x01\x03\x12\x04\
    \xc5\x01\x1c\x1d\nW\n\x06\x04\x04\x03\x01\x02\x02\x12\x04\xc7\x01\x04\
    \x19\x1aG\xe6\x98\xaf\xe5\x90\xa6\xe9\x9c\x80\xe8\xa6\x81\xe8\xa7\xa3\
    \xe5\xaf\x86\x20\xef\xbc\x88\xe7\xab\xaf\xe5\xaf\xb9\xe7\xab\xaf\xe5\x8a\
    \xa0\xe5\xaf\x86\xe6\x8a\x80\xe6\x9c\xaf\xef\xbc\x8c\xe6\x9c\x8d\xe5\x8a\
    \xa1\xe7\xab\xaf\xe6\x97\xa0\xe6\xb3\x95\xe8\xa7\xa3\xe5\xaf\x86\xef\xbc\
    \x89\n\n\x0f\n\x07\x04\x04\x03\x01\x02\x02\x05\x12\x04\xc7\x01\x04\x08\n\
    \x0f\n\x07\x04\x04\x03\x01\x02\x02\x01\x12\x04\xc7\x01\t\x14\n\x0f\n\x07\
    \x04\x04\x03\x01\x02\x02\x03\x12\x04\xc7\x01\x17\x18\n2\n\x06\x04\x04\
    \x03\x01\x02\x03\x12\x04\xc9\x01\x04\x19\x1a\"\xe6\xb6\x88\xe6\x81\xaf\
    \xe6\x98\xaf\xe5\x90\xa6\xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xa1\xe5\x85\xa5\
    \xe6\x9c\xaa\xe8\xaf\xbb\xe6\x95\xb0\n\n\x0f\n\x07\x04\x04\x03\x01\x02\
    \x03\x05\x12\x04\xc9\x01\x04\x08\n\x0f\n\x07\x04\x04\x03\x01\x02\x03\x01\
    \x12\x04\xc9\x01\t\x14\n\x0f\n\x07\x04\x04\x03\x01\x02\x03\x03\x12\x04\
    \xc9\x01\x17\x18\n\x0c\n\x04\x04\x04\x02\n\x12\x04\xcb\x01\x02\x15\n\r\n\
    \x05\x04\x04\x02\n\x06\x12\x04\xcb\x01\x02\x08\n\r\n\x05\x04\x04\x02\n\
    \x01\x12\x04\xcb\x01\t\x0f\n\r\n\x05\x04\x04\x02\n\x03\x12\x04\xcb\x01\
    \x12\x14\n?\n\x04\x04\x04\x02\x0b\x12\x04\xcd\x01\x02$\x1a1extraMap,\x20\
    example:\x20{\"platformSource\":\x20\"windows\"}\n\n\r\n\x05\x04\x04\x02\
    \x0b\x06\x12\x04\xcd\x01\x02\x15\n\r\n\x05\x04\x04\x02\x0b\x01\x12\x04\
    \xcd\x01\x16\x1e\n\r\n\x05\x04\x04\x02\x0b\x03\x12\x04\xcd\x01!#\n\x1c\n\
    \x02\x04\x05\x12\x06\xd1\x01\0\xe0\x01\x01\x1a\x0eNotice\x20\xe9\x80\x9a\
    \xe7\x9f\xa5\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xd1\x01\x08\x0e\nn\n\x04\
    \x04\x05\x02\0\x12\x04\xd3\x01\x02\x16\x1a`\xe9\x80\x9a\xe7\x9f\xa5id\
    \x20\xe5\x9b\xa0\xe4\xb8\xba\xe9\x80\x9a\xe7\x9f\xa5\xe6\xb0\xb8\xe8\xbf\
    \x9c\xe9\x83\xbd\xe6\x98\xaf\xe6\x9c\x8d\xe5\x8a\xa1\xe7\xab\xaf\xe5\x8f\
    \x91\xe9\x80\x81\xe7\xbb\x99\xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe7\x9a\
    \x84\xef\xbc\x8c\xe6\x89\x80\xe4\xbb\xa5\xe9\x80\x9a\xe7\x9f\xa5id\xe4\
    \xb8\x80\xe5\xae\x9a\xe5\x94\xaf\xe4\xb8\x80\xe3\x80\x82\n\n\r\n\x05\x04\
    \x05\x02\0\x05\x12\x04\xd3\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\
    \x04\xd3\x01\t\x11\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xd3\x01\x14\x15\n\
    \xa2\x01\n\x04\x04\x05\x02\x01\x12\x04\xd5\x01\x02\x1c\x1a\x16\xe5\x8f\
    \x91\xe9\x80\x81\xe5\x88\xb0\xe5\x93\xaa\xe4\xb8\xaa\xe4\xbc\x9a\xe8\xaf\
    \x9d\n\"|\x20\xe5\x8d\x95\xe8\x81\x8a:\x20\xe9\x82\xa3\xe4\xb9\x88\xe8\
    \xaf\xa5\xe5\x80\xbc\xe4\xb8\xba\xe5\x8f\x91\xe9\x80\x81\xe8\x80\x85\xe5\
    \x92\x8c\xe6\x8e\xa5\xe5\x8f\x97\xe8\x80\x85\xe7\x9a\x84id\xef\xbc\x9b\
    \xe7\xbe\xa4\xe8\x81\x8a\xef\xbc\x9a\xe9\x82\xa3\xe4\xb9\x88\xe8\xaf\xa5\
    \xe5\x80\xbc\xe4\xb8\xba\xe7\xbe\xa4id\xef\xbc\x9b\xe8\xae\xa2\xe9\x98\
    \x85\xe5\x8f\xb7\xef\xbc\x9a\xe9\x82\xa3\xe4\xb9\x88\xe8\xaf\xa5\xe5\x80\
    \xbc\xe4\xb8\xba\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7id\n\n\r\n\x05\x04\
    \x05\x02\x01\x05\x12\x04\xd5\x01\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\
    \x12\x04\xd5\x01\t\x17\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xd5\x01\x1a\
    \x1b\n\x1b\n\x04\x04\x05\x02\x02\x12\x04\xd7\x01\x02(\x1a\r\xe4\xbc\x9a\
    \xe8\xaf\x9d\xe7\xb1\xbb\xe5\x9e\x8b\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\
    \x04\xd7\x01\x02\x12\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xd7\x01\x13#\
    \n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xd7\x01&'\n\x1b\n\x04\x04\x05\x02\
    \x03\x12\x04\xd9\x01\x02\x15\x1a\r\xe9\x80\x9a\xe7\x9f\xa5\xe5\x86\x85\
    \xe5\xae\xb9\n\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\xd9\x01\x02\x08\n\r\
    \n\x05\x04\x05\x02\x03\x01\x12\x04\xd9\x01\t\x10\n\r\n\x05\x04\x05\x02\
    \x03\x03\x12\x04\xd9\x01\x13\x14\n\x1b\n\x04\x04\x05\x02\x04\x12\x04\xdb\
    \x01\x02$\x1a\r\xe9\x80\x9a\xe7\x9f\xa5\xe7\xb1\xbb\xe5\x9e\x8b\n\n\r\n\
    \x05\x04\x05\x02\x04\x06\x12\x04\xdb\x01\x02\x13\n\r\n\x05\x04\x05\x02\
    \x04\x01\x12\x04\xdb\x01\x14\x1f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\
    \xdb\x01\"#\n$\n\x04\x04\x05\x02\x05\x12\x04\xdd\x01\x02\x17\x1a\x16\xe9\
    \x80\x9a\xe7\x9f\xa5\xe7\x9a\x84\xe6\x9b\xb4\xe6\x96\xb0\xe6\x97\xb6\xe9\
    \x97\xb4\n\n\r\n\x05\x04\x05\x02\x05\x05\x12\x04\xdd\x01\x02\x07\n\r\n\
    \x05\x04\x05\x02\x05\x01\x12\x04\xdd\x01\x08\x12\n\r\n\x05\x04\x05\x02\
    \x05\x03\x12\x04\xdd\x01\x15\x16\n\x15\n\x04\x04\x05\x02\x06\x12\x04\xdf\
    \x01\x02\x11\x1a\x07\xe6\x8e\x92\xe5\xba\x8f\n\n\r\n\x05\x04\x05\x02\x06\
    \x05\x12\x04\xdf\x01\x02\x07\n\r\n\x05\x04\x05\x02\x06\x01\x12\x04\xdf\
    \x01\x08\x0c\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\xdf\x01\x0f\x10b\x06p\
    roto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(RequestHeader::generated_message_descriptor_data());
            messages.push(ToastActionData::generated_message_descriptor_data());
            messages.push(AlertActionData::generated_message_descriptor_data());
            messages.push(ResponseHeader::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            messages.push(Notice::generated_message_descriptor_data());
            messages.push(message::Sender::generated_message_descriptor_data());
            messages.push(message::Option::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(Platform::generated_enum_descriptor_data());
            enums.push(ResponseCode::generated_enum_descriptor_data());
            enums.push(ResponseActionType::generated_enum_descriptor_data());
            enums.push(WebsocketCustomCloseCode::generated_enum_descriptor_data());
            enums.push(ConversationType::generated_enum_descriptor_data());
            enums.push(NoticeContentType::generated_enum_descriptor_data());
            enums.push(MessageContentType::generated_enum_descriptor_data());
            enums.push(ConversationSettingKey::generated_enum_descriptor_data());
            enums.push(toast_action_data::Level::generated_enum_descriptor_data());
            enums.push(alert_action_data::ButtonType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
