// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `conversation.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GroupCreateReq)
pub struct GroupCreateReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GroupCreateReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GroupCreateReq.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GroupCreateReq.avatar)
    pub avatar: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GroupCreateReq.memberList)
    pub memberList: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GroupCreateReq.infoMap)
    pub infoMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.GroupCreateReq.extraMap)
    pub extraMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GroupCreateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupCreateReq {
    fn default() -> &'a GroupCreateReq {
        <GroupCreateReq as ::protobuf::Message>::default_instance()
    }
}

impl GroupCreateReq {
    pub fn new() -> GroupCreateReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GroupCreateReq| { &m.header },
            |m: &mut GroupCreateReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GroupCreateReq| { &m.name },
            |m: &mut GroupCreateReq| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar",
            |m: &GroupCreateReq| { &m.avatar },
            |m: &mut GroupCreateReq| { &mut m.avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memberList",
            |m: &GroupCreateReq| { &m.memberList },
            |m: &mut GroupCreateReq| { &mut m.memberList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "infoMap",
            |m: &GroupCreateReq| { &m.infoMap },
            |m: &mut GroupCreateReq| { &mut m.infoMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extraMap",
            |m: &GroupCreateReq| { &m.extraMap },
            |m: &mut GroupCreateReq| { &mut m.extraMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupCreateReq>(
            "GroupCreateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupCreateReq {
    const NAME: &'static str = "GroupCreateReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.avatar = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.memberList.push(is.read_string()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.infoMap.insert(key, value);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extraMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.memberList {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for (k, v) in &self.infoMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.avatar.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.memberList {
            os.write_string(4, &v)?;
        };
        for (k, v) in &self.infoMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupCreateReq {
        GroupCreateReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.name = ::std::option::Option::None;
        self.avatar = ::std::option::Option::None;
        self.memberList.clear();
        self.infoMap.clear();
        self.extraMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupCreateReq {
        static instance: ::protobuf::rt::Lazy<GroupCreateReq> = ::protobuf::rt::Lazy::new();
        instance.get(GroupCreateReq::new)
    }
}

impl ::protobuf::MessageFull for GroupCreateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupCreateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupCreateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupCreateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GroupCreateResp)
pub struct GroupCreateResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GroupCreateResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GroupCreateResp.groupId)
    pub groupId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GroupCreateResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupCreateResp {
    fn default() -> &'a GroupCreateResp {
        <GroupCreateResp as ::protobuf::Message>::default_instance()
    }
}

impl GroupCreateResp {
    pub fn new() -> GroupCreateResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GroupCreateResp| { &m.header },
            |m: &mut GroupCreateResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupId",
            |m: &GroupCreateResp| { &m.groupId },
            |m: &mut GroupCreateResp| { &mut m.groupId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupCreateResp>(
            "GroupCreateResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupCreateResp {
    const NAME: &'static str = "GroupCreateResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.groupId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.groupId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.groupId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.groupId.is_empty() {
            os.write_string(2, &self.groupId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupCreateResp {
        GroupCreateResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.groupId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupCreateResp {
        static instance: GroupCreateResp = GroupCreateResp {
            header: ::protobuf::MessageField::none(),
            groupId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupCreateResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupCreateResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupCreateResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupCreateResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CountJoinGroupReq 统计加入的群组数量
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CountJoinGroupReq)
pub struct CountJoinGroupReq {
    // message fields
    // @@protoc_insertion_point(field:pb.CountJoinGroupReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CountJoinGroupReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CountJoinGroupReq {
    fn default() -> &'a CountJoinGroupReq {
        <CountJoinGroupReq as ::protobuf::Message>::default_instance()
    }
}

impl CountJoinGroupReq {
    pub fn new() -> CountJoinGroupReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &CountJoinGroupReq| { &m.header },
            |m: &mut CountJoinGroupReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountJoinGroupReq>(
            "CountJoinGroupReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CountJoinGroupReq {
    const NAME: &'static str = "CountJoinGroupReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CountJoinGroupReq {
        CountJoinGroupReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CountJoinGroupReq {
        static instance: CountJoinGroupReq = CountJoinGroupReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CountJoinGroupReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CountJoinGroupReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CountJoinGroupReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountJoinGroupReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CountJoinGroupResp)
pub struct CountJoinGroupResp {
    // message fields
    // @@protoc_insertion_point(field:pb.CountJoinGroupResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.CountJoinGroupResp.count)
    pub count: i64,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CountJoinGroupResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CountJoinGroupResp {
    fn default() -> &'a CountJoinGroupResp {
        <CountJoinGroupResp as ::protobuf::Message>::default_instance()
    }
}

impl CountJoinGroupResp {
    pub fn new() -> CountJoinGroupResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &CountJoinGroupResp| { &m.header },
            |m: &mut CountJoinGroupResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &CountJoinGroupResp| { &m.count },
            |m: &mut CountJoinGroupResp| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountJoinGroupResp>(
            "CountJoinGroupResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CountJoinGroupResp {
    const NAME: &'static str = "CountJoinGroupResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.count = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.count != 0 {
            os.write_int64(2, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CountJoinGroupResp {
        CountJoinGroupResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CountJoinGroupResp {
        static instance: CountJoinGroupResp = CountJoinGroupResp {
            header: ::protobuf::MessageField::none(),
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CountJoinGroupResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CountJoinGroupResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CountJoinGroupResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountJoinGroupResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CountCreateGroupReq 统计创建的群组数量
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CountCreateGroupReq)
pub struct CountCreateGroupReq {
    // message fields
    // @@protoc_insertion_point(field:pb.CountCreateGroupReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CountCreateGroupReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CountCreateGroupReq {
    fn default() -> &'a CountCreateGroupReq {
        <CountCreateGroupReq as ::protobuf::Message>::default_instance()
    }
}

impl CountCreateGroupReq {
    pub fn new() -> CountCreateGroupReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &CountCreateGroupReq| { &m.header },
            |m: &mut CountCreateGroupReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountCreateGroupReq>(
            "CountCreateGroupReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CountCreateGroupReq {
    const NAME: &'static str = "CountCreateGroupReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CountCreateGroupReq {
        CountCreateGroupReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CountCreateGroupReq {
        static instance: CountCreateGroupReq = CountCreateGroupReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CountCreateGroupReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CountCreateGroupReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CountCreateGroupReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountCreateGroupReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CountCreateGroupResp)
pub struct CountCreateGroupResp {
    // message fields
    // @@protoc_insertion_point(field:pb.CountCreateGroupResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.CountCreateGroupResp.count)
    pub count: i64,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CountCreateGroupResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CountCreateGroupResp {
    fn default() -> &'a CountCreateGroupResp {
        <CountCreateGroupResp as ::protobuf::Message>::default_instance()
    }
}

impl CountCreateGroupResp {
    pub fn new() -> CountCreateGroupResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &CountCreateGroupResp| { &m.header },
            |m: &mut CountCreateGroupResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &CountCreateGroupResp| { &m.count },
            |m: &mut CountCreateGroupResp| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountCreateGroupResp>(
            "CountCreateGroupResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CountCreateGroupResp {
    const NAME: &'static str = "CountCreateGroupResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.count = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.count != 0 {
            os.write_int64(2, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CountCreateGroupResp {
        CountCreateGroupResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CountCreateGroupResp {
        static instance: CountCreateGroupResp = CountCreateGroupResp {
            header: ::protobuf::MessageField::none(),
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CountCreateGroupResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CountCreateGroupResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CountCreateGroupResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountCreateGroupResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GroupSubscribeReq)
pub struct GroupSubscribeReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GroupSubscribeReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GroupSubscribeReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupSubscribeReq {
    fn default() -> &'a GroupSubscribeReq {
        <GroupSubscribeReq as ::protobuf::Message>::default_instance()
    }
}

impl GroupSubscribeReq {
    pub fn new() -> GroupSubscribeReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GroupSubscribeReq| { &m.header },
            |m: &mut GroupSubscribeReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupSubscribeReq>(
            "GroupSubscribeReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupSubscribeReq {
    const NAME: &'static str = "GroupSubscribeReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupSubscribeReq {
        GroupSubscribeReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupSubscribeReq {
        static instance: GroupSubscribeReq = GroupSubscribeReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupSubscribeReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupSubscribeReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupSubscribeReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupSubscribeReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GroupSubscribeResp)
pub struct GroupSubscribeResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GroupSubscribeResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GroupSubscribeResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupSubscribeResp {
    fn default() -> &'a GroupSubscribeResp {
        <GroupSubscribeResp as ::protobuf::Message>::default_instance()
    }
}

impl GroupSubscribeResp {
    pub fn new() -> GroupSubscribeResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GroupSubscribeResp| { &m.header },
            |m: &mut GroupSubscribeResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupSubscribeResp>(
            "GroupSubscribeResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupSubscribeResp {
    const NAME: &'static str = "GroupSubscribeResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupSubscribeResp {
        GroupSubscribeResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupSubscribeResp {
        static instance: GroupSubscribeResp = GroupSubscribeResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupSubscribeResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupSubscribeResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupSubscribeResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupSubscribeResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// ListGroupSubscribersReq 列出群组订阅者
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListGroupSubscribersReq)
pub struct ListGroupSubscribersReq {
    // message fields
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// GroupId 群组id
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.groupId)
    pub groupId: ::std::string::String,
    /// Cursor 游标
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.cursor)
    pub cursor: i64,
    /// Limit 限制
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.limit)
    pub limit: i64,
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.filter)
    pub filter: ::protobuf::MessageField<list_group_subscribers_req::Filter>,
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.option)
    pub option: ::protobuf::MessageField<list_group_subscribers_req::Option>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListGroupSubscribersReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListGroupSubscribersReq {
    fn default() -> &'a ListGroupSubscribersReq {
        <ListGroupSubscribersReq as ::protobuf::Message>::default_instance()
    }
}

impl ListGroupSubscribersReq {
    pub fn new() -> ListGroupSubscribersReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &ListGroupSubscribersReq| { &m.header },
            |m: &mut ListGroupSubscribersReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groupId",
            |m: &ListGroupSubscribersReq| { &m.groupId },
            |m: &mut ListGroupSubscribersReq| { &mut m.groupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ListGroupSubscribersReq| { &m.cursor },
            |m: &mut ListGroupSubscribersReq| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ListGroupSubscribersReq| { &m.limit },
            |m: &mut ListGroupSubscribersReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_group_subscribers_req::Filter>(
            "filter",
            |m: &ListGroupSubscribersReq| { &m.filter },
            |m: &mut ListGroupSubscribersReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_group_subscribers_req::Option>(
            "option",
            |m: &ListGroupSubscribersReq| { &m.option },
            |m: &mut ListGroupSubscribersReq| { &mut m.option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListGroupSubscribersReq>(
            "ListGroupSubscribersReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListGroupSubscribersReq {
    const NAME: &'static str = "ListGroupSubscribersReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.groupId = is.read_string()?;
                },
                24 => {
                    self.cursor = is.read_int64()?;
                },
                32 => {
                    self.limit = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.groupId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.groupId);
        }
        if self.cursor != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.cursor);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.limit);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.groupId.is_empty() {
            os.write_string(2, &self.groupId)?;
        }
        if self.cursor != 0 {
            os.write_int64(3, self.cursor)?;
        }
        if self.limit != 0 {
            os.write_int64(4, self.limit)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListGroupSubscribersReq {
        ListGroupSubscribersReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.groupId.clear();
        self.cursor = 0;
        self.limit = 0;
        self.filter.clear();
        self.option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListGroupSubscribersReq {
        static instance: ListGroupSubscribersReq = ListGroupSubscribersReq {
            header: ::protobuf::MessageField::none(),
            groupId: ::std::string::String::new(),
            cursor: 0,
            limit: 0,
            filter: ::protobuf::MessageField::none(),
            option: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListGroupSubscribersReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListGroupSubscribersReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListGroupSubscribersReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupSubscribersReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListGroupSubscribersReq`
pub mod list_group_subscribers_req {
    /// Filter 过滤器
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListGroupSubscribersReq.Filter)
    pub struct Filter {
        // message fields
        /// subscribeTimeGte 订阅时间大于等于
        // @@protoc_insertion_point(field:pb.ListGroupSubscribersReq.Filter.subscribeTimeGte)
        pub subscribeTimeGte: i64,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListGroupSubscribersReq.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "subscribeTimeGte",
                |m: &Filter| { &m.subscribeTimeGte },
                |m: &mut Filter| { &mut m.subscribeTimeGte },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "ListGroupSubscribersReq.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.subscribeTimeGte = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.subscribeTimeGte != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.subscribeTimeGte);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.subscribeTimeGte != 0 {
                os.write_int64(1, self.subscribeTimeGte)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.subscribeTimeGte = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                subscribeTimeGte: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Filter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListGroupSubscribersReq.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Option 选项
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListGroupSubscribersReq.Option)
    pub struct Option {
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListGroupSubscribersReq.Option.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Option {
        fn default() -> &'a Option {
            <Option as ::protobuf::Message>::default_instance()
        }
    }

    impl Option {
        pub fn new() -> Option {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
                "ListGroupSubscribersReq.Option",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Option {
        const NAME: &'static str = "Option";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Option {
            Option::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Option {
            static instance: Option = Option {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Option {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListGroupSubscribersReq.Option").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Option {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Option {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListGroupSubscribersResp)
pub struct ListGroupSubscribersResp {
    // message fields
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.ListGroupSubscribersResp.subscriberList)
    pub subscriberList: ::std::vec::Vec<list_group_subscribers_resp::Subscriber>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListGroupSubscribersResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListGroupSubscribersResp {
    fn default() -> &'a ListGroupSubscribersResp {
        <ListGroupSubscribersResp as ::protobuf::Message>::default_instance()
    }
}

impl ListGroupSubscribersResp {
    pub fn new() -> ListGroupSubscribersResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &ListGroupSubscribersResp| { &m.header },
            |m: &mut ListGroupSubscribersResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriberList",
            |m: &ListGroupSubscribersResp| { &m.subscriberList },
            |m: &mut ListGroupSubscribersResp| { &mut m.subscriberList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListGroupSubscribersResp>(
            "ListGroupSubscribersResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListGroupSubscribersResp {
    const NAME: &'static str = "ListGroupSubscribersResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.subscriberList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subscriberList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.subscriberList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListGroupSubscribersResp {
        ListGroupSubscribersResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.subscriberList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListGroupSubscribersResp {
        static instance: ListGroupSubscribersResp = ListGroupSubscribersResp {
            header: ::protobuf::MessageField::none(),
            subscriberList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListGroupSubscribersResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListGroupSubscribersResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListGroupSubscribersResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupSubscribersResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListGroupSubscribersResp`
pub mod list_group_subscribers_resp {
    /// Cursor 游标
    /// List 列表
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListGroupSubscribersResp.Subscriber)
    pub struct Subscriber {
        // message fields
        /// UserId 用户id
        // @@protoc_insertion_point(field:pb.ListGroupSubscribersResp.Subscriber.userId)
        pub userId: ::std::string::String,
        /// SubscribeTime 订阅时间
        // @@protoc_insertion_point(field:pb.ListGroupSubscribersResp.Subscriber.subscribeTime)
        pub subscribeTime: i64,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListGroupSubscribersResp.Subscriber.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Subscriber {
        fn default() -> &'a Subscriber {
            <Subscriber as ::protobuf::Message>::default_instance()
        }
    }

    impl Subscriber {
        pub fn new() -> Subscriber {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userId",
                |m: &Subscriber| { &m.userId },
                |m: &mut Subscriber| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "subscribeTime",
                |m: &Subscriber| { &m.subscribeTime },
                |m: &mut Subscriber| { &mut m.subscribeTime },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscriber>(
                "ListGroupSubscribersResp.Subscriber",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Subscriber {
        const NAME: &'static str = "Subscriber";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.userId = is.read_string()?;
                    },
                    16 => {
                        self.subscribeTime = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.userId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.userId);
            }
            if self.subscribeTime != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.subscribeTime);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.userId.is_empty() {
                os.write_string(1, &self.userId)?;
            }
            if self.subscribeTime != 0 {
                os.write_int64(2, self.subscribeTime)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Subscriber {
            Subscriber::new()
        }

        fn clear(&mut self) {
            self.userId.clear();
            self.subscribeTime = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Subscriber {
            static instance: Subscriber = Subscriber {
                userId: ::std::string::String::new(),
                subscribeTime: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Subscriber {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListGroupSubscribersResp.Subscriber").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Subscriber {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Subscriber {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.FriendApplyReq)
pub struct FriendApplyReq {
    // message fields
    // @@protoc_insertion_point(field:pb.FriendApplyReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.FriendApplyReq.toUserId)
    pub toUserId: ::std::string::String,
    /// Message 附加消息
    // @@protoc_insertion_point(field:pb.FriendApplyReq.message)
    pub message: ::std::option::Option<::std::string::String>,
    /// Answer 附加回答
    // @@protoc_insertion_point(field:pb.FriendApplyReq.answer)
    pub answer: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.FriendApplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendApplyReq {
    fn default() -> &'a FriendApplyReq {
        <FriendApplyReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendApplyReq {
    pub fn new() -> FriendApplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &FriendApplyReq| { &m.header },
            |m: &mut FriendApplyReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toUserId",
            |m: &FriendApplyReq| { &m.toUserId },
            |m: &mut FriendApplyReq| { &mut m.toUserId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &FriendApplyReq| { &m.message },
            |m: &mut FriendApplyReq| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "answer",
            |m: &FriendApplyReq| { &m.answer },
            |m: &mut FriendApplyReq| { &mut m.answer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendApplyReq>(
            "FriendApplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendApplyReq {
    const NAME: &'static str = "FriendApplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.toUserId = is.read_string()?;
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.answer = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.toUserId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.toUserId);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.answer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.toUserId.is_empty() {
            os.write_string(2, &self.toUserId)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.answer.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendApplyReq {
        FriendApplyReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.toUserId.clear();
        self.message = ::std::option::Option::None;
        self.answer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendApplyReq {
        static instance: FriendApplyReq = FriendApplyReq {
            header: ::protobuf::MessageField::none(),
            toUserId: ::std::string::String::new(),
            message: ::std::option::Option::None,
            answer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendApplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendApplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendApplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendApplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.FriendApplyResp)
pub struct FriendApplyResp {
    // message fields
    // @@protoc_insertion_point(field:pb.FriendApplyResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.FriendApplyResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendApplyResp {
    fn default() -> &'a FriendApplyResp {
        <FriendApplyResp as ::protobuf::Message>::default_instance()
    }
}

impl FriendApplyResp {
    pub fn new() -> FriendApplyResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &FriendApplyResp| { &m.header },
            |m: &mut FriendApplyResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendApplyResp>(
            "FriendApplyResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendApplyResp {
    const NAME: &'static str = "FriendApplyResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendApplyResp {
        FriendApplyResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendApplyResp {
        static instance: FriendApplyResp = FriendApplyResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendApplyResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendApplyResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendApplyResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendApplyResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.FriendApplyHandleReq)
pub struct FriendApplyHandleReq {
    // message fields
    // @@protoc_insertion_point(field:pb.FriendApplyHandleReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.FriendApplyHandleReq.applyId)
    pub applyId: ::std::string::String,
    /// Agree 是否同意
    // @@protoc_insertion_point(field:pb.FriendApplyHandleReq.agree)
    pub agree: bool,
    /// 同意后发送的第一条消息
    // @@protoc_insertion_point(field:pb.FriendApplyHandleReq.firstMessage)
    pub firstMessage: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.FriendApplyHandleReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendApplyHandleReq {
    fn default() -> &'a FriendApplyHandleReq {
        <FriendApplyHandleReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendApplyHandleReq {
    pub fn new() -> FriendApplyHandleReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &FriendApplyHandleReq| { &m.header },
            |m: &mut FriendApplyHandleReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "applyId",
            |m: &FriendApplyHandleReq| { &m.applyId },
            |m: &mut FriendApplyHandleReq| { &mut m.applyId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "agree",
            |m: &FriendApplyHandleReq| { &m.agree },
            |m: &mut FriendApplyHandleReq| { &mut m.agree },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstMessage",
            |m: &FriendApplyHandleReq| { &m.firstMessage },
            |m: &mut FriendApplyHandleReq| { &mut m.firstMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendApplyHandleReq>(
            "FriendApplyHandleReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendApplyHandleReq {
    const NAME: &'static str = "FriendApplyHandleReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.applyId = is.read_string()?;
                },
                24 => {
                    self.agree = is.read_bool()?;
                },
                34 => {
                    self.firstMessage = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.applyId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.applyId);
        }
        if self.agree != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.firstMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.applyId.is_empty() {
            os.write_string(2, &self.applyId)?;
        }
        if self.agree != false {
            os.write_bool(3, self.agree)?;
        }
        if let Some(v) = self.firstMessage.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendApplyHandleReq {
        FriendApplyHandleReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.applyId.clear();
        self.agree = false;
        self.firstMessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendApplyHandleReq {
        static instance: FriendApplyHandleReq = FriendApplyHandleReq {
            header: ::protobuf::MessageField::none(),
            applyId: ::std::string::String::new(),
            agree: false,
            firstMessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendApplyHandleReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendApplyHandleReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendApplyHandleReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendApplyHandleReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.FriendApplyHandleResp)
pub struct FriendApplyHandleResp {
    // message fields
    // @@protoc_insertion_point(field:pb.FriendApplyHandleResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.FriendApplyHandleResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendApplyHandleResp {
    fn default() -> &'a FriendApplyHandleResp {
        <FriendApplyHandleResp as ::protobuf::Message>::default_instance()
    }
}

impl FriendApplyHandleResp {
    pub fn new() -> FriendApplyHandleResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &FriendApplyHandleResp| { &m.header },
            |m: &mut FriendApplyHandleResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendApplyHandleResp>(
            "FriendApplyHandleResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendApplyHandleResp {
    const NAME: &'static str = "FriendApplyHandleResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendApplyHandleResp {
        FriendApplyHandleResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendApplyHandleResp {
        static instance: FriendApplyHandleResp = FriendApplyHandleResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendApplyHandleResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendApplyHandleResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendApplyHandleResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendApplyHandleResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListFriendApplyReq)
pub struct ListFriendApplyReq {
    // message fields
    // @@protoc_insertion_point(field:pb.ListFriendApplyReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// Cursor 游标
    // @@protoc_insertion_point(field:pb.ListFriendApplyReq.cursor)
    pub cursor: i64,
    /// Limit 限制
    // @@protoc_insertion_point(field:pb.ListFriendApplyReq.limit)
    pub limit: i64,
    // @@protoc_insertion_point(field:pb.ListFriendApplyReq.filter)
    pub filter: ::protobuf::MessageField<list_friend_apply_req::Filter>,
    // @@protoc_insertion_point(field:pb.ListFriendApplyReq.option)
    pub option: ::protobuf::MessageField<list_friend_apply_req::Option>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListFriendApplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListFriendApplyReq {
    fn default() -> &'a ListFriendApplyReq {
        <ListFriendApplyReq as ::protobuf::Message>::default_instance()
    }
}

impl ListFriendApplyReq {
    pub fn new() -> ListFriendApplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &ListFriendApplyReq| { &m.header },
            |m: &mut ListFriendApplyReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ListFriendApplyReq| { &m.cursor },
            |m: &mut ListFriendApplyReq| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ListFriendApplyReq| { &m.limit },
            |m: &mut ListFriendApplyReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_friend_apply_req::Filter>(
            "filter",
            |m: &ListFriendApplyReq| { &m.filter },
            |m: &mut ListFriendApplyReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_friend_apply_req::Option>(
            "option",
            |m: &ListFriendApplyReq| { &m.option },
            |m: &mut ListFriendApplyReq| { &mut m.option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListFriendApplyReq>(
            "ListFriendApplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListFriendApplyReq {
    const NAME: &'static str = "ListFriendApplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.cursor = is.read_int64()?;
                },
                24 => {
                    self.limit = is.read_int64()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.cursor != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.cursor);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.limit);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.cursor != 0 {
            os.write_int64(2, self.cursor)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListFriendApplyReq {
        ListFriendApplyReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.cursor = 0;
        self.limit = 0;
        self.filter.clear();
        self.option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListFriendApplyReq {
        static instance: ListFriendApplyReq = ListFriendApplyReq {
            header: ::protobuf::MessageField::none(),
            cursor: 0,
            limit: 0,
            filter: ::protobuf::MessageField::none(),
            option: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListFriendApplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListFriendApplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListFriendApplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFriendApplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListFriendApplyReq`
pub mod list_friend_apply_req {
    /// Filter 过滤器
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListFriendApplyReq.Filter)
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:pb.ListFriendApplyReq.Filter.status)
        pub status: ::std::option::Option<::protobuf::EnumOrUnknown<super::FriendApplyStatus>>,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListFriendApplyReq.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "status",
                |m: &Filter| { &m.status },
                |m: &mut Filter| { &mut m.status },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "ListFriendApplyReq.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.status {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.status {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.status = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                status: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Filter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListFriendApplyReq.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Option 选项
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListFriendApplyReq.Option)
    pub struct Option {
        // message fields
        // @@protoc_insertion_point(field:pb.ListFriendApplyReq.Option.includeApplyByMe)
        pub includeApplyByMe: bool,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListFriendApplyReq.Option.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Option {
        fn default() -> &'a Option {
            <Option as ::protobuf::Message>::default_instance()
        }
    }

    impl Option {
        pub fn new() -> Option {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "includeApplyByMe",
                |m: &Option| { &m.includeApplyByMe },
                |m: &mut Option| { &mut m.includeApplyByMe },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
                "ListFriendApplyReq.Option",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Option {
        const NAME: &'static str = "Option";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.includeApplyByMe = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.includeApplyByMe != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.includeApplyByMe != false {
                os.write_bool(1, self.includeApplyByMe)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Option {
            Option::new()
        }

        fn clear(&mut self) {
            self.includeApplyByMe = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Option {
            static instance: Option = Option {
                includeApplyByMe: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Option {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListFriendApplyReq.Option").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Option {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Option {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListFriendApplyResp)
pub struct ListFriendApplyResp {
    // message fields
    // @@protoc_insertion_point(field:pb.ListFriendApplyResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    /// Cursor 游标
    // @@protoc_insertion_point(field:pb.ListFriendApplyResp.cursor)
    pub cursor: i64,
    // @@protoc_insertion_point(field:pb.ListFriendApplyResp.friendApplyList)
    pub friendApplyList: ::std::vec::Vec<list_friend_apply_resp::FriendApply>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListFriendApplyResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListFriendApplyResp {
    fn default() -> &'a ListFriendApplyResp {
        <ListFriendApplyResp as ::protobuf::Message>::default_instance()
    }
}

impl ListFriendApplyResp {
    pub fn new() -> ListFriendApplyResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &ListFriendApplyResp| { &m.header },
            |m: &mut ListFriendApplyResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ListFriendApplyResp| { &m.cursor },
            |m: &mut ListFriendApplyResp| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friendApplyList",
            |m: &ListFriendApplyResp| { &m.friendApplyList },
            |m: &mut ListFriendApplyResp| { &mut m.friendApplyList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListFriendApplyResp>(
            "ListFriendApplyResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListFriendApplyResp {
    const NAME: &'static str = "ListFriendApplyResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.cursor = is.read_int64()?;
                },
                26 => {
                    self.friendApplyList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.cursor != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.cursor);
        }
        for value in &self.friendApplyList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.cursor != 0 {
            os.write_int64(2, self.cursor)?;
        }
        for v in &self.friendApplyList {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListFriendApplyResp {
        ListFriendApplyResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.cursor = 0;
        self.friendApplyList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListFriendApplyResp {
        static instance: ListFriendApplyResp = ListFriendApplyResp {
            header: ::protobuf::MessageField::none(),
            cursor: 0,
            friendApplyList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListFriendApplyResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListFriendApplyResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListFriendApplyResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFriendApplyResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListFriendApplyResp`
pub mod list_friend_apply_resp {
    /// List 列表
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListFriendApplyResp.FriendApply)
    pub struct FriendApply {
        // message fields
        /// ApplyId 申请id
        // @@protoc_insertion_point(field:pb.ListFriendApplyResp.FriendApply.applyId)
        pub applyId: ::std::string::String,
        /// FromUserId 申请人id
        // @@protoc_insertion_point(field:pb.ListFriendApplyResp.FriendApply.fromUserId)
        pub fromUserId: ::std::string::String,
        /// ToUserId 被申请人id
        // @@protoc_insertion_point(field:pb.ListFriendApplyResp.FriendApply.toUserId)
        pub toUserId: ::std::string::String,
        /// Message 附加消息
        // @@protoc_insertion_point(field:pb.ListFriendApplyResp.FriendApply.message)
        pub message: ::std::string::String,
        /// Answer 附加回答
        // @@protoc_insertion_point(field:pb.ListFriendApplyResp.FriendApply.answer)
        pub answer: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListFriendApplyResp.FriendApply.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FriendApply {
        fn default() -> &'a FriendApply {
            <FriendApply as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendApply {
        pub fn new() -> FriendApply {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "applyId",
                |m: &FriendApply| { &m.applyId },
                |m: &mut FriendApply| { &mut m.applyId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fromUserId",
                |m: &FriendApply| { &m.fromUserId },
                |m: &mut FriendApply| { &mut m.fromUserId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "toUserId",
                |m: &FriendApply| { &m.toUserId },
                |m: &mut FriendApply| { &mut m.toUserId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "message",
                |m: &FriendApply| { &m.message },
                |m: &mut FriendApply| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "answer",
                |m: &FriendApply| { &m.answer },
                |m: &mut FriendApply| { &mut m.answer },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendApply>(
                "ListFriendApplyResp.FriendApply",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FriendApply {
        const NAME: &'static str = "FriendApply";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.applyId = is.read_string()?;
                    },
                    18 => {
                        self.fromUserId = is.read_string()?;
                    },
                    26 => {
                        self.toUserId = is.read_string()?;
                    },
                    34 => {
                        self.message = is.read_string()?;
                    },
                    42 => {
                        self.answer = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.applyId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.applyId);
            }
            if !self.fromUserId.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.fromUserId);
            }
            if !self.toUserId.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.toUserId);
            }
            if !self.message.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.message);
            }
            if !self.answer.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.answer);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.applyId.is_empty() {
                os.write_string(1, &self.applyId)?;
            }
            if !self.fromUserId.is_empty() {
                os.write_string(2, &self.fromUserId)?;
            }
            if !self.toUserId.is_empty() {
                os.write_string(3, &self.toUserId)?;
            }
            if !self.message.is_empty() {
                os.write_string(4, &self.message)?;
            }
            if !self.answer.is_empty() {
                os.write_string(5, &self.answer)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FriendApply {
            FriendApply::new()
        }

        fn clear(&mut self) {
            self.applyId.clear();
            self.fromUserId.clear();
            self.toUserId.clear();
            self.message.clear();
            self.answer.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FriendApply {
            static instance: FriendApply = FriendApply {
                applyId: ::std::string::String::new(),
                fromUserId: ::std::string::String::new(),
                toUserId: ::std::string::String::new(),
                message: ::std::string::String::new(),
                answer: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FriendApply {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListFriendApplyResp.FriendApply").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FriendApply {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendApply {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// CountFriendReq 统计好友数量
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CountFriendReq)
pub struct CountFriendReq {
    // message fields
    // @@protoc_insertion_point(field:pb.CountFriendReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CountFriendReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CountFriendReq {
    fn default() -> &'a CountFriendReq {
        <CountFriendReq as ::protobuf::Message>::default_instance()
    }
}

impl CountFriendReq {
    pub fn new() -> CountFriendReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &CountFriendReq| { &m.header },
            |m: &mut CountFriendReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountFriendReq>(
            "CountFriendReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CountFriendReq {
    const NAME: &'static str = "CountFriendReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CountFriendReq {
        CountFriendReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CountFriendReq {
        static instance: CountFriendReq = CountFriendReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CountFriendReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CountFriendReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CountFriendReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountFriendReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CountFriendResp)
pub struct CountFriendResp {
    // message fields
    // @@protoc_insertion_point(field:pb.CountFriendResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.CountFriendResp.count)
    pub count: i64,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CountFriendResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CountFriendResp {
    fn default() -> &'a CountFriendResp {
        <CountFriendResp as ::protobuf::Message>::default_instance()
    }
}

impl CountFriendResp {
    pub fn new() -> CountFriendResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &CountFriendResp| { &m.header },
            |m: &mut CountFriendResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &CountFriendResp| { &m.count },
            |m: &mut CountFriendResp| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CountFriendResp>(
            "CountFriendResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CountFriendResp {
    const NAME: &'static str = "CountFriendResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.count = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.count != 0 {
            os.write_int64(2, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CountFriendResp {
        CountFriendResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CountFriendResp {
        static instance: CountFriendResp = CountFriendResp {
            header: ::protobuf::MessageField::none(),
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CountFriendResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CountFriendResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CountFriendResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountFriendResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ConversationSettingUpdateReq)
pub struct ConversationSettingUpdateReq {
    // message fields
    // @@protoc_insertion_point(field:pb.ConversationSettingUpdateReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ConversationSettingUpdateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConversationSettingUpdateReq {
    fn default() -> &'a ConversationSettingUpdateReq {
        <ConversationSettingUpdateReq as ::protobuf::Message>::default_instance()
    }
}

impl ConversationSettingUpdateReq {
    pub fn new() -> ConversationSettingUpdateReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &ConversationSettingUpdateReq| { &m.header },
            |m: &mut ConversationSettingUpdateReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConversationSettingUpdateReq>(
            "ConversationSettingUpdateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConversationSettingUpdateReq {
    const NAME: &'static str = "ConversationSettingUpdateReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConversationSettingUpdateReq {
        ConversationSettingUpdateReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConversationSettingUpdateReq {
        static instance: ConversationSettingUpdateReq = ConversationSettingUpdateReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConversationSettingUpdateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConversationSettingUpdateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConversationSettingUpdateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConversationSettingUpdateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ConversationSettingUpdateResp)
pub struct ConversationSettingUpdateResp {
    // message fields
    // @@protoc_insertion_point(field:pb.ConversationSettingUpdateResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ConversationSettingUpdateResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConversationSettingUpdateResp {
    fn default() -> &'a ConversationSettingUpdateResp {
        <ConversationSettingUpdateResp as ::protobuf::Message>::default_instance()
    }
}

impl ConversationSettingUpdateResp {
    pub fn new() -> ConversationSettingUpdateResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &ConversationSettingUpdateResp| { &m.header },
            |m: &mut ConversationSettingUpdateResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConversationSettingUpdateResp>(
            "ConversationSettingUpdateResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConversationSettingUpdateResp {
    const NAME: &'static str = "ConversationSettingUpdateResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConversationSettingUpdateResp {
        ConversationSettingUpdateResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConversationSettingUpdateResp {
        static instance: ConversationSettingUpdateResp = ConversationSettingUpdateResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConversationSettingUpdateResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConversationSettingUpdateResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConversationSettingUpdateResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConversationSettingUpdateResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListJoinedConversationsReq)
pub struct ListJoinedConversationsReq {
    // message fields
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.conversationType)
    pub conversationType: ::protobuf::EnumOrUnknown<super::common::ConversationType>,
    /// Cursor 游标
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.cursor)
    pub cursor: i64,
    /// Limit 限制
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.limit)
    pub limit: i64,
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.filter)
    pub filter: ::protobuf::MessageField<list_joined_conversations_req::Filter>,
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.option)
    pub option: ::protobuf::MessageField<list_joined_conversations_req::Option>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListJoinedConversationsReq {
    fn default() -> &'a ListJoinedConversationsReq {
        <ListJoinedConversationsReq as ::protobuf::Message>::default_instance()
    }
}

impl ListJoinedConversationsReq {
    pub fn new() -> ListJoinedConversationsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &ListJoinedConversationsReq| { &m.header },
            |m: &mut ListJoinedConversationsReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conversationType",
            |m: &ListJoinedConversationsReq| { &m.conversationType },
            |m: &mut ListJoinedConversationsReq| { &mut m.conversationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ListJoinedConversationsReq| { &m.cursor },
            |m: &mut ListJoinedConversationsReq| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ListJoinedConversationsReq| { &m.limit },
            |m: &mut ListJoinedConversationsReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_joined_conversations_req::Filter>(
            "filter",
            |m: &ListJoinedConversationsReq| { &m.filter },
            |m: &mut ListJoinedConversationsReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_joined_conversations_req::Option>(
            "option",
            |m: &ListJoinedConversationsReq| { &m.option },
            |m: &mut ListJoinedConversationsReq| { &mut m.option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListJoinedConversationsReq>(
            "ListJoinedConversationsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListJoinedConversationsReq {
    const NAME: &'static str = "ListJoinedConversationsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.conversationType = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.cursor = is.read_int64()?;
                },
                32 => {
                    self.limit = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.conversationType != ::protobuf::EnumOrUnknown::new(super::common::ConversationType::Single) {
            my_size += ::protobuf::rt::int32_size(2, self.conversationType.value());
        }
        if self.cursor != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.cursor);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.limit);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.conversationType != ::protobuf::EnumOrUnknown::new(super::common::ConversationType::Single) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.conversationType))?;
        }
        if self.cursor != 0 {
            os.write_int64(3, self.cursor)?;
        }
        if self.limit != 0 {
            os.write_int64(4, self.limit)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListJoinedConversationsReq {
        ListJoinedConversationsReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.conversationType = ::protobuf::EnumOrUnknown::new(super::common::ConversationType::Single);
        self.cursor = 0;
        self.limit = 0;
        self.filter.clear();
        self.option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListJoinedConversationsReq {
        static instance: ListJoinedConversationsReq = ListJoinedConversationsReq {
            header: ::protobuf::MessageField::none(),
            conversationType: ::protobuf::EnumOrUnknown::from_i32(0),
            cursor: 0,
            limit: 0,
            filter: ::protobuf::MessageField::none(),
            option: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListJoinedConversationsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListJoinedConversationsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListJoinedConversationsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListJoinedConversationsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListJoinedConversationsReq`
pub mod list_joined_conversations_req {
    /// Filter 过滤器
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListJoinedConversationsReq.Filter)
    pub struct Filter {
        // message fields
        /// 使用setting中的字段过滤
        // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Filter.settingList)
        pub settingList: ::std::vec::Vec<filter::SettingKV>,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsReq.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "settingList",
                |m: &Filter| { &m.settingList },
                |m: &mut Filter| { &mut m.settingList },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "ListJoinedConversationsReq.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.settingList.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.settingList {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.settingList {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.settingList.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                settingList: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Filter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListJoinedConversationsReq.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Filter`
    pub mod filter {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:pb.ListJoinedConversationsReq.Filter.SettingKV)
        pub struct SettingKV {
            // message fields
            // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Filter.SettingKV.key)
            pub key: ::protobuf::EnumOrUnknown<super::super::super::common::ConversationSettingKey>,
            // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Filter.SettingKV.value)
            pub value: ::std::string::String,
            // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Filter.SettingKV.operator)
            pub operator: ::protobuf::EnumOrUnknown<setting_kv::Operator>,
            // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Filter.SettingKV.orNotExists)
            pub orNotExists: bool,
            // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Filter.SettingKV.orExists)
            pub orExists: bool,
            // special fields
            // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsReq.Filter.SettingKV.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SettingKV {
            fn default() -> &'a SettingKV {
                <SettingKV as ::protobuf::Message>::default_instance()
            }
        }

        impl SettingKV {
            pub fn new() -> SettingKV {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "key",
                    |m: &SettingKV| { &m.key },
                    |m: &mut SettingKV| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "value",
                    |m: &SettingKV| { &m.value },
                    |m: &mut SettingKV| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "operator",
                    |m: &SettingKV| { &m.operator },
                    |m: &mut SettingKV| { &mut m.operator },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "orNotExists",
                    |m: &SettingKV| { &m.orNotExists },
                    |m: &mut SettingKV| { &mut m.orNotExists },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "orExists",
                    |m: &SettingKV| { &m.orExists },
                    |m: &mut SettingKV| { &mut m.orExists },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SettingKV>(
                    "ListJoinedConversationsReq.Filter.SettingKV",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SettingKV {
            const NAME: &'static str = "SettingKV";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.key = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.value = is.read_string()?;
                        },
                        24 => {
                            self.operator = is.read_enum_or_unknown()?;
                        },
                        32 => {
                            self.orNotExists = is.read_bool()?;
                        },
                        40 => {
                            self.orExists = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.key != ::protobuf::EnumOrUnknown::new(super::super::super::common::ConversationSettingKey::IsPinned) {
                    my_size += ::protobuf::rt::int32_size(1, self.key.value());
                }
                if !self.value.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.value);
                }
                if self.operator != ::protobuf::EnumOrUnknown::new(setting_kv::Operator::Equal) {
                    my_size += ::protobuf::rt::int32_size(3, self.operator.value());
                }
                if self.orNotExists != false {
                    my_size += 1 + 1;
                }
                if self.orExists != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.key != ::protobuf::EnumOrUnknown::new(super::super::super::common::ConversationSettingKey::IsPinned) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.key))?;
                }
                if !self.value.is_empty() {
                    os.write_string(2, &self.value)?;
                }
                if self.operator != ::protobuf::EnumOrUnknown::new(setting_kv::Operator::Equal) {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.operator))?;
                }
                if self.orNotExists != false {
                    os.write_bool(4, self.orNotExists)?;
                }
                if self.orExists != false {
                    os.write_bool(5, self.orExists)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SettingKV {
                SettingKV::new()
            }

            fn clear(&mut self) {
                self.key = ::protobuf::EnumOrUnknown::new(super::super::super::common::ConversationSettingKey::IsPinned);
                self.value.clear();
                self.operator = ::protobuf::EnumOrUnknown::new(setting_kv::Operator::Equal);
                self.orNotExists = false;
                self.orExists = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SettingKV {
                static instance: SettingKV = SettingKV {
                    key: ::protobuf::EnumOrUnknown::from_i32(0),
                    value: ::std::string::String::new(),
                    operator: ::protobuf::EnumOrUnknown::from_i32(0),
                    orNotExists: false,
                    orExists: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SettingKV {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ListJoinedConversationsReq.Filter.SettingKV").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SettingKV {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SettingKV {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `SettingKV`
        pub mod setting_kv {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:pb.ListJoinedConversationsReq.Filter.SettingKV.Operator)
            pub enum Operator {
                // @@protoc_insertion_point(enum_value:pb.ListJoinedConversationsReq.Filter.SettingKV.Operator.Equal)
                Equal = 0,
                // @@protoc_insertion_point(enum_value:pb.ListJoinedConversationsReq.Filter.SettingKV.Operator.NotEqual)
                NotEqual = 1,
            }

            impl ::protobuf::Enum for Operator {
                const NAME: &'static str = "Operator";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<Operator> {
                    match value {
                        0 => ::std::option::Option::Some(Operator::Equal),
                        1 => ::std::option::Option::Some(Operator::NotEqual),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [Operator] = &[
                    Operator::Equal,
                    Operator::NotEqual,
                ];
            }

            impl ::protobuf::EnumFull for Operator {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("ListJoinedConversationsReq.Filter.SettingKV.Operator").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for Operator {
                fn default() -> Self {
                    Operator::Equal
                }
            }

            impl Operator {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Operator>("ListJoinedConversationsReq.Filter.SettingKV.Operator")
                }
            }
        }
    }

    /// Option 选项
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListJoinedConversationsReq.Option)
    pub struct Option {
        // message fields
        /// IncludeSelfMemberInfo 是否包含自己的成员信息
        // @@protoc_insertion_point(field:pb.ListJoinedConversationsReq.Option.includeSelfMemberInfo)
        pub includeSelfMemberInfo: bool,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsReq.Option.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Option {
        fn default() -> &'a Option {
            <Option as ::protobuf::Message>::default_instance()
        }
    }

    impl Option {
        pub fn new() -> Option {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "includeSelfMemberInfo",
                |m: &Option| { &m.includeSelfMemberInfo },
                |m: &mut Option| { &mut m.includeSelfMemberInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
                "ListJoinedConversationsReq.Option",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Option {
        const NAME: &'static str = "Option";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.includeSelfMemberInfo = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.includeSelfMemberInfo != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.includeSelfMemberInfo != false {
                os.write_bool(2, self.includeSelfMemberInfo)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Option {
            Option::new()
        }

        fn clear(&mut self) {
            self.includeSelfMemberInfo = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Option {
            static instance: Option = Option {
                includeSelfMemberInfo: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Option {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListJoinedConversationsReq.Option").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Option {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Option {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListJoinedConversationsResp)
pub struct ListJoinedConversationsResp {
    // message fields
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.ListJoinedConversationsResp.conversationList)
    pub conversationList: ::std::vec::Vec<list_joined_conversations_resp::Conversation>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListJoinedConversationsResp {
    fn default() -> &'a ListJoinedConversationsResp {
        <ListJoinedConversationsResp as ::protobuf::Message>::default_instance()
    }
}

impl ListJoinedConversationsResp {
    pub fn new() -> ListJoinedConversationsResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &ListJoinedConversationsResp| { &m.header },
            |m: &mut ListJoinedConversationsResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conversationList",
            |m: &ListJoinedConversationsResp| { &m.conversationList },
            |m: &mut ListJoinedConversationsResp| { &mut m.conversationList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListJoinedConversationsResp>(
            "ListJoinedConversationsResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListJoinedConversationsResp {
    const NAME: &'static str = "ListJoinedConversationsResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                26 => {
                    self.conversationList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.conversationList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.conversationList {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListJoinedConversationsResp {
        ListJoinedConversationsResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.conversationList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListJoinedConversationsResp {
        static instance: ListJoinedConversationsResp = ListJoinedConversationsResp {
            header: ::protobuf::MessageField::none(),
            conversationList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListJoinedConversationsResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListJoinedConversationsResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListJoinedConversationsResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListJoinedConversationsResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListJoinedConversationsResp`
pub mod list_joined_conversations_resp {
    /// List 列表
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListJoinedConversationsResp.Conversation)
    pub struct Conversation {
        // message fields
        /// ConversationId 会话id
        // @@protoc_insertion_point(field:pb.ListJoinedConversationsResp.Conversation.conversationId)
        pub conversationId: ::std::string::String,
        // @@protoc_insertion_point(field:pb.ListJoinedConversationsResp.Conversation.conversationType)
        pub conversationType: ::protobuf::EnumOrUnknown<super::super::common::ConversationType>,
        // @@protoc_insertion_point(field:pb.ListJoinedConversationsResp.Conversation.selfMemberInfo)
        pub selfMemberInfo: ::protobuf::MessageField<conversation::SelfMemberInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsResp.Conversation.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Conversation {
        fn default() -> &'a Conversation {
            <Conversation as ::protobuf::Message>::default_instance()
        }
    }

    impl Conversation {
        pub fn new() -> Conversation {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "conversationId",
                |m: &Conversation| { &m.conversationId },
                |m: &mut Conversation| { &mut m.conversationId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "conversationType",
                |m: &Conversation| { &m.conversationType },
                |m: &mut Conversation| { &mut m.conversationType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, conversation::SelfMemberInfo>(
                "selfMemberInfo",
                |m: &Conversation| { &m.selfMemberInfo },
                |m: &mut Conversation| { &mut m.selfMemberInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Conversation>(
                "ListJoinedConversationsResp.Conversation",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Conversation {
        const NAME: &'static str = "Conversation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.conversationId = is.read_string()?;
                    },
                    16 => {
                        self.conversationType = is.read_enum_or_unknown()?;
                    },
                    250 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.selfMemberInfo)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.conversationId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.conversationId);
            }
            if self.conversationType != ::protobuf::EnumOrUnknown::new(super::super::common::ConversationType::Single) {
                my_size += ::protobuf::rt::int32_size(2, self.conversationType.value());
            }
            if let Some(v) = self.selfMemberInfo.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.conversationId.is_empty() {
                os.write_string(1, &self.conversationId)?;
            }
            if self.conversationType != ::protobuf::EnumOrUnknown::new(super::super::common::ConversationType::Single) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.conversationType))?;
            }
            if let Some(v) = self.selfMemberInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Conversation {
            Conversation::new()
        }

        fn clear(&mut self) {
            self.conversationId.clear();
            self.conversationType = ::protobuf::EnumOrUnknown::new(super::super::common::ConversationType::Single);
            self.selfMemberInfo.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Conversation {
            static instance: Conversation = Conversation {
                conversationId: ::std::string::String::new(),
                conversationType: ::protobuf::EnumOrUnknown::from_i32(0),
                selfMemberInfo: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Conversation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListJoinedConversationsResp.Conversation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Conversation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Conversation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Conversation`
    pub mod conversation {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:pb.ListJoinedConversationsResp.Conversation.SelfMemberInfo)
        pub struct SelfMemberInfo {
            // message fields
            // @@protoc_insertion_point(field:pb.ListJoinedConversationsResp.Conversation.SelfMemberInfo.joinTime)
            pub joinTime: i64,
            // special fields
            // @@protoc_insertion_point(special_field:pb.ListJoinedConversationsResp.Conversation.SelfMemberInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SelfMemberInfo {
            fn default() -> &'a SelfMemberInfo {
                <SelfMemberInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl SelfMemberInfo {
            pub fn new() -> SelfMemberInfo {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "joinTime",
                    |m: &SelfMemberInfo| { &m.joinTime },
                    |m: &mut SelfMemberInfo| { &mut m.joinTime },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelfMemberInfo>(
                    "ListJoinedConversationsResp.Conversation.SelfMemberInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SelfMemberInfo {
            const NAME: &'static str = "SelfMemberInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.joinTime = is.read_int64()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.joinTime != 0 {
                    my_size += ::protobuf::rt::int64_size(1, self.joinTime);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.joinTime != 0 {
                    os.write_int64(1, self.joinTime)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SelfMemberInfo {
                SelfMemberInfo::new()
            }

            fn clear(&mut self) {
                self.joinTime = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SelfMemberInfo {
                static instance: SelfMemberInfo = SelfMemberInfo {
                    joinTime: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SelfMemberInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ListJoinedConversationsResp.Conversation.SelfMemberInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SelfMemberInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SelfMemberInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SubscriptionSubscribeReq)
pub struct SubscriptionSubscribeReq {
    // message fields
    // @@protoc_insertion_point(field:pb.SubscriptionSubscribeReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SubscriptionSubscribeReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionSubscribeReq {
    fn default() -> &'a SubscriptionSubscribeReq {
        <SubscriptionSubscribeReq as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionSubscribeReq {
    pub fn new() -> SubscriptionSubscribeReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &SubscriptionSubscribeReq| { &m.header },
            |m: &mut SubscriptionSubscribeReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionSubscribeReq>(
            "SubscriptionSubscribeReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionSubscribeReq {
    const NAME: &'static str = "SubscriptionSubscribeReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionSubscribeReq {
        SubscriptionSubscribeReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionSubscribeReq {
        static instance: SubscriptionSubscribeReq = SubscriptionSubscribeReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionSubscribeReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionSubscribeReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionSubscribeReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionSubscribeReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SubscriptionSubscribeResp)
pub struct SubscriptionSubscribeResp {
    // message fields
    // @@protoc_insertion_point(field:pb.SubscriptionSubscribeResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SubscriptionSubscribeResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionSubscribeResp {
    fn default() -> &'a SubscriptionSubscribeResp {
        <SubscriptionSubscribeResp as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionSubscribeResp {
    pub fn new() -> SubscriptionSubscribeResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &SubscriptionSubscribeResp| { &m.header },
            |m: &mut SubscriptionSubscribeResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionSubscribeResp>(
            "SubscriptionSubscribeResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionSubscribeResp {
    const NAME: &'static str = "SubscriptionSubscribeResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionSubscribeResp {
        SubscriptionSubscribeResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionSubscribeResp {
        static instance: SubscriptionSubscribeResp = SubscriptionSubscribeResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionSubscribeResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionSubscribeResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionSubscribeResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionSubscribeResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SubscriptionAfterOnlineReq)
pub struct SubscriptionAfterOnlineReq {
    // message fields
    // @@protoc_insertion_point(field:pb.SubscriptionAfterOnlineReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SubscriptionAfterOnlineReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionAfterOnlineReq {
    fn default() -> &'a SubscriptionAfterOnlineReq {
        <SubscriptionAfterOnlineReq as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionAfterOnlineReq {
    pub fn new() -> SubscriptionAfterOnlineReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &SubscriptionAfterOnlineReq| { &m.header },
            |m: &mut SubscriptionAfterOnlineReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionAfterOnlineReq>(
            "SubscriptionAfterOnlineReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionAfterOnlineReq {
    const NAME: &'static str = "SubscriptionAfterOnlineReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionAfterOnlineReq {
        SubscriptionAfterOnlineReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionAfterOnlineReq {
        static instance: SubscriptionAfterOnlineReq = SubscriptionAfterOnlineReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionAfterOnlineReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionAfterOnlineReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionAfterOnlineReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionAfterOnlineReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SubscriptionAfterOnlineResp)
pub struct SubscriptionAfterOnlineResp {
    // message fields
    // @@protoc_insertion_point(field:pb.SubscriptionAfterOnlineResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SubscriptionAfterOnlineResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionAfterOnlineResp {
    fn default() -> &'a SubscriptionAfterOnlineResp {
        <SubscriptionAfterOnlineResp as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionAfterOnlineResp {
    pub fn new() -> SubscriptionAfterOnlineResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &SubscriptionAfterOnlineResp| { &m.header },
            |m: &mut SubscriptionAfterOnlineResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionAfterOnlineResp>(
            "SubscriptionAfterOnlineResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionAfterOnlineResp {
    const NAME: &'static str = "SubscriptionAfterOnlineResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionAfterOnlineResp {
        SubscriptionAfterOnlineResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionAfterOnlineResp {
        static instance: SubscriptionAfterOnlineResp = SubscriptionAfterOnlineResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionAfterOnlineResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionAfterOnlineResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionAfterOnlineResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionAfterOnlineResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// SubscriptionAfterOffline 订阅号在做用户下线后的操作
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SubscriptionAfterOfflineReq)
pub struct SubscriptionAfterOfflineReq {
    // message fields
    // @@protoc_insertion_point(field:pb.SubscriptionAfterOfflineReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.SubscriptionAfterOfflineReq.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SubscriptionAfterOfflineReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionAfterOfflineReq {
    fn default() -> &'a SubscriptionAfterOfflineReq {
        <SubscriptionAfterOfflineReq as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionAfterOfflineReq {
    pub fn new() -> SubscriptionAfterOfflineReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &SubscriptionAfterOfflineReq| { &m.header },
            |m: &mut SubscriptionAfterOfflineReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &SubscriptionAfterOfflineReq| { &m.userId },
            |m: &mut SubscriptionAfterOfflineReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionAfterOfflineReq>(
            "SubscriptionAfterOfflineReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionAfterOfflineReq {
    const NAME: &'static str = "SubscriptionAfterOfflineReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionAfterOfflineReq {
        SubscriptionAfterOfflineReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionAfterOfflineReq {
        static instance: SubscriptionAfterOfflineReq = SubscriptionAfterOfflineReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionAfterOfflineReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionAfterOfflineReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionAfterOfflineReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionAfterOfflineReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.SubscriptionAfterOfflineResp)
pub struct SubscriptionAfterOfflineResp {
    // message fields
    // @@protoc_insertion_point(field:pb.SubscriptionAfterOfflineResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.SubscriptionAfterOfflineResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionAfterOfflineResp {
    fn default() -> &'a SubscriptionAfterOfflineResp {
        <SubscriptionAfterOfflineResp as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionAfterOfflineResp {
    pub fn new() -> SubscriptionAfterOfflineResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &SubscriptionAfterOfflineResp| { &m.header },
            |m: &mut SubscriptionAfterOfflineResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionAfterOfflineResp>(
            "SubscriptionAfterOfflineResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionAfterOfflineResp {
    const NAME: &'static str = "SubscriptionAfterOfflineResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionAfterOfflineResp {
        SubscriptionAfterOfflineResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionAfterOfflineResp {
        static instance: SubscriptionAfterOfflineResp = SubscriptionAfterOfflineResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionAfterOfflineResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionAfterOfflineResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionAfterOfflineResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionAfterOfflineResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserSubscription 用户订阅的订阅号
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserSubscription)
pub struct UserSubscription {
    // message fields
    // @@protoc_insertion_point(field:pb.UserSubscription.subscriptionId)
    pub subscriptionId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UserSubscription.Subscriber)
    pub Subscriber: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UserSubscription.subscribeTime)
    pub subscribeTime: i64,
    // @@protoc_insertion_point(field:pb.UserSubscription.extraMap)
    pub extraMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserSubscription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserSubscription {
    fn default() -> &'a UserSubscription {
        <UserSubscription as ::protobuf::Message>::default_instance()
    }
}

impl UserSubscription {
    pub fn new() -> UserSubscription {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriptionId",
            |m: &UserSubscription| { &m.subscriptionId },
            |m: &mut UserSubscription| { &mut m.subscriptionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Subscriber",
            |m: &UserSubscription| { &m.Subscriber },
            |m: &mut UserSubscription| { &mut m.Subscriber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscribeTime",
            |m: &UserSubscription| { &m.subscribeTime },
            |m: &mut UserSubscription| { &mut m.subscribeTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extraMap",
            |m: &UserSubscription| { &m.extraMap },
            |m: &mut UserSubscription| { &mut m.extraMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserSubscription>(
            "UserSubscription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserSubscription {
    const NAME: &'static str = "UserSubscription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subscriptionId = is.read_string()?;
                },
                18 => {
                    self.Subscriber = is.read_string()?;
                },
                24 => {
                    self.subscribeTime = is.read_int64()?;
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extraMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.subscriptionId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscriptionId);
        }
        if !self.Subscriber.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Subscriber);
        }
        if self.subscribeTime != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.subscribeTime);
        }
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.subscriptionId.is_empty() {
            os.write_string(1, &self.subscriptionId)?;
        }
        if !self.Subscriber.is_empty() {
            os.write_string(2, &self.Subscriber)?;
        }
        if self.subscribeTime != 0 {
            os.write_int64(3, self.subscribeTime)?;
        }
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserSubscription {
        UserSubscription::new()
    }

    fn clear(&mut self) {
        self.subscriptionId.clear();
        self.Subscriber.clear();
        self.subscribeTime = 0;
        self.extraMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserSubscription {
        static instance: ::protobuf::rt::Lazy<UserSubscription> = ::protobuf::rt::Lazy::new();
        instance.get(UserSubscription::new)
    }
}

impl ::protobuf::MessageFull for UserSubscription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserSubscription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSubscription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpsertUserSubscriptionReq)
pub struct UpsertUserSubscriptionReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UpsertUserSubscriptionReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// SubscriptionId 订阅号id
    // @@protoc_insertion_point(field:pb.UpsertUserSubscriptionReq.subscriptionId)
    pub subscriptionId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UpsertUserSubscriptionReq.userSubscription)
    pub userSubscription: ::protobuf::MessageField<UserSubscription>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpsertUserSubscriptionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpsertUserSubscriptionReq {
    fn default() -> &'a UpsertUserSubscriptionReq {
        <UpsertUserSubscriptionReq as ::protobuf::Message>::default_instance()
    }
}

impl UpsertUserSubscriptionReq {
    pub fn new() -> UpsertUserSubscriptionReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UpsertUserSubscriptionReq| { &m.header },
            |m: &mut UpsertUserSubscriptionReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriptionId",
            |m: &UpsertUserSubscriptionReq| { &m.subscriptionId },
            |m: &mut UpsertUserSubscriptionReq| { &mut m.subscriptionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserSubscription>(
            "userSubscription",
            |m: &UpsertUserSubscriptionReq| { &m.userSubscription },
            |m: &mut UpsertUserSubscriptionReq| { &mut m.userSubscription },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpsertUserSubscriptionReq>(
            "UpsertUserSubscriptionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpsertUserSubscriptionReq {
    const NAME: &'static str = "UpsertUserSubscriptionReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.subscriptionId = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userSubscription)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.subscriptionId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscriptionId);
        }
        if let Some(v) = self.userSubscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.subscriptionId.is_empty() {
            os.write_string(2, &self.subscriptionId)?;
        }
        if let Some(v) = self.userSubscription.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpsertUserSubscriptionReq {
        UpsertUserSubscriptionReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.subscriptionId.clear();
        self.userSubscription.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpsertUserSubscriptionReq {
        static instance: UpsertUserSubscriptionReq = UpsertUserSubscriptionReq {
            header: ::protobuf::MessageField::none(),
            subscriptionId: ::std::string::String::new(),
            userSubscription: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpsertUserSubscriptionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpsertUserSubscriptionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpsertUserSubscriptionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpsertUserSubscriptionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpsertUserSubscriptionResp)
pub struct UpsertUserSubscriptionResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UpsertUserSubscriptionResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpsertUserSubscriptionResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpsertUserSubscriptionResp {
    fn default() -> &'a UpsertUserSubscriptionResp {
        <UpsertUserSubscriptionResp as ::protobuf::Message>::default_instance()
    }
}

impl UpsertUserSubscriptionResp {
    pub fn new() -> UpsertUserSubscriptionResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UpsertUserSubscriptionResp| { &m.header },
            |m: &mut UpsertUserSubscriptionResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpsertUserSubscriptionResp>(
            "UpsertUserSubscriptionResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpsertUserSubscriptionResp {
    const NAME: &'static str = "UpsertUserSubscriptionResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpsertUserSubscriptionResp {
        UpsertUserSubscriptionResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpsertUserSubscriptionResp {
        static instance: UpsertUserSubscriptionResp = UpsertUserSubscriptionResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpsertUserSubscriptionResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpsertUserSubscriptionResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpsertUserSubscriptionResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpsertUserSubscriptionResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.DeleteUserSubscriptionReq)
pub struct DeleteUserSubscriptionReq {
    // message fields
    // @@protoc_insertion_point(field:pb.DeleteUserSubscriptionReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// SubscriptionId 订阅号id
    // @@protoc_insertion_point(field:pb.DeleteUserSubscriptionReq.subscriptionId)
    pub subscriptionId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.DeleteUserSubscriptionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteUserSubscriptionReq {
    fn default() -> &'a DeleteUserSubscriptionReq {
        <DeleteUserSubscriptionReq as ::protobuf::Message>::default_instance()
    }
}

impl DeleteUserSubscriptionReq {
    pub fn new() -> DeleteUserSubscriptionReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &DeleteUserSubscriptionReq| { &m.header },
            |m: &mut DeleteUserSubscriptionReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriptionId",
            |m: &DeleteUserSubscriptionReq| { &m.subscriptionId },
            |m: &mut DeleteUserSubscriptionReq| { &mut m.subscriptionId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteUserSubscriptionReq>(
            "DeleteUserSubscriptionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteUserSubscriptionReq {
    const NAME: &'static str = "DeleteUserSubscriptionReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.subscriptionId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.subscriptionId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscriptionId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.subscriptionId.is_empty() {
            os.write_string(2, &self.subscriptionId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteUserSubscriptionReq {
        DeleteUserSubscriptionReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.subscriptionId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteUserSubscriptionReq {
        static instance: DeleteUserSubscriptionReq = DeleteUserSubscriptionReq {
            header: ::protobuf::MessageField::none(),
            subscriptionId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteUserSubscriptionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteUserSubscriptionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteUserSubscriptionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteUserSubscriptionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.DeleteUserSubscriptionResp)
pub struct DeleteUserSubscriptionResp {
    // message fields
    // @@protoc_insertion_point(field:pb.DeleteUserSubscriptionResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.DeleteUserSubscriptionResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteUserSubscriptionResp {
    fn default() -> &'a DeleteUserSubscriptionResp {
        <DeleteUserSubscriptionResp as ::protobuf::Message>::default_instance()
    }
}

impl DeleteUserSubscriptionResp {
    pub fn new() -> DeleteUserSubscriptionResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &DeleteUserSubscriptionResp| { &m.header },
            |m: &mut DeleteUserSubscriptionResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteUserSubscriptionResp>(
            "DeleteUserSubscriptionResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteUserSubscriptionResp {
    const NAME: &'static str = "DeleteUserSubscriptionResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteUserSubscriptionResp {
        DeleteUserSubscriptionResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteUserSubscriptionResp {
        static instance: DeleteUserSubscriptionResp = DeleteUserSubscriptionResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteUserSubscriptionResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteUserSubscriptionResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteUserSubscriptionResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteUserSubscriptionResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListSubscriptionSubscribersReq)
pub struct ListSubscriptionSubscribersReq {
    // message fields
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    /// SubscriptionId 订阅号id
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.subscriptionId)
    pub subscriptionId: ::std::string::String,
    /// Cursor 游标
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.cursor)
    pub cursor: i64,
    /// Limit 限制
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.limit)
    pub limit: i64,
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.filter)
    pub filter: ::protobuf::MessageField<list_subscription_subscribers_req::Filter>,
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.option)
    pub option: ::protobuf::MessageField<list_subscription_subscribers_req::Option>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListSubscriptionSubscribersReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionSubscribersReq {
    fn default() -> &'a ListSubscriptionSubscribersReq {
        <ListSubscriptionSubscribersReq as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionSubscribersReq {
    pub fn new() -> ListSubscriptionSubscribersReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &ListSubscriptionSubscribersReq| { &m.header },
            |m: &mut ListSubscriptionSubscribersReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscriptionId",
            |m: &ListSubscriptionSubscribersReq| { &m.subscriptionId },
            |m: &mut ListSubscriptionSubscribersReq| { &mut m.subscriptionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ListSubscriptionSubscribersReq| { &m.cursor },
            |m: &mut ListSubscriptionSubscribersReq| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ListSubscriptionSubscribersReq| { &m.limit },
            |m: &mut ListSubscriptionSubscribersReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_subscription_subscribers_req::Filter>(
            "filter",
            |m: &ListSubscriptionSubscribersReq| { &m.filter },
            |m: &mut ListSubscriptionSubscribersReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_subscription_subscribers_req::Option>(
            "option",
            |m: &ListSubscriptionSubscribersReq| { &m.option },
            |m: &mut ListSubscriptionSubscribersReq| { &mut m.option },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSubscriptionSubscribersReq>(
            "ListSubscriptionSubscribersReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSubscriptionSubscribersReq {
    const NAME: &'static str = "ListSubscriptionSubscribersReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.subscriptionId = is.read_string()?;
                },
                24 => {
                    self.cursor = is.read_int64()?;
                },
                32 => {
                    self.limit = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.subscriptionId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscriptionId);
        }
        if self.cursor != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.cursor);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.limit);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.subscriptionId.is_empty() {
            os.write_string(2, &self.subscriptionId)?;
        }
        if self.cursor != 0 {
            os.write_int64(3, self.cursor)?;
        }
        if self.limit != 0 {
            os.write_int64(4, self.limit)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSubscriptionSubscribersReq {
        ListSubscriptionSubscribersReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.subscriptionId.clear();
        self.cursor = 0;
        self.limit = 0;
        self.filter.clear();
        self.option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSubscriptionSubscribersReq {
        static instance: ListSubscriptionSubscribersReq = ListSubscriptionSubscribersReq {
            header: ::protobuf::MessageField::none(),
            subscriptionId: ::std::string::String::new(),
            cursor: 0,
            limit: 0,
            filter: ::protobuf::MessageField::none(),
            option: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSubscriptionSubscribersReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSubscriptionSubscribersReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSubscriptionSubscribersReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionSubscribersReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListSubscriptionSubscribersReq`
pub mod list_subscription_subscribers_req {
    /// Filter 过滤器
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListSubscriptionSubscribersReq.Filter)
    pub struct Filter {
        // message fields
        /// subscribeTimeGte 订阅时间大于等于
        // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersReq.Filter.subscribeTimeGte)
        pub subscribeTimeGte: i64,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListSubscriptionSubscribersReq.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "subscribeTimeGte",
                |m: &Filter| { &m.subscribeTimeGte },
                |m: &mut Filter| { &mut m.subscribeTimeGte },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
                "ListSubscriptionSubscribersReq.Filter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.subscribeTimeGte = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.subscribeTimeGte != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.subscribeTimeGte);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.subscribeTimeGte != 0 {
                os.write_int64(1, self.subscribeTimeGte)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.subscribeTimeGte = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                subscribeTimeGte: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Filter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListSubscriptionSubscribersReq.Filter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Option 选项
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListSubscriptionSubscribersReq.Option)
    pub struct Option {
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListSubscriptionSubscribersReq.Option.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Option {
        fn default() -> &'a Option {
            <Option as ::protobuf::Message>::default_instance()
        }
    }

    impl Option {
        pub fn new() -> Option {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
                "ListSubscriptionSubscribersReq.Option",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Option {
        const NAME: &'static str = "Option";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Option {
            Option::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Option {
            static instance: Option = Option {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Option {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListSubscriptionSubscribersReq.Option").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Option {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Option {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ListSubscriptionSubscribersResp)
pub struct ListSubscriptionSubscribersResp {
    // message fields
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersResp.subscriberList)
    pub subscriberList: ::std::vec::Vec<list_subscription_subscribers_resp::Subscriber>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ListSubscriptionSubscribersResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionSubscribersResp {
    fn default() -> &'a ListSubscriptionSubscribersResp {
        <ListSubscriptionSubscribersResp as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionSubscribersResp {
    pub fn new() -> ListSubscriptionSubscribersResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &ListSubscriptionSubscribersResp| { &m.header },
            |m: &mut ListSubscriptionSubscribersResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscriberList",
            |m: &ListSubscriptionSubscribersResp| { &m.subscriberList },
            |m: &mut ListSubscriptionSubscribersResp| { &mut m.subscriberList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSubscriptionSubscribersResp>(
            "ListSubscriptionSubscribersResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSubscriptionSubscribersResp {
    const NAME: &'static str = "ListSubscriptionSubscribersResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.subscriberList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subscriberList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.subscriberList {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSubscriptionSubscribersResp {
        ListSubscriptionSubscribersResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.subscriberList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSubscriptionSubscribersResp {
        static instance: ListSubscriptionSubscribersResp = ListSubscriptionSubscribersResp {
            header: ::protobuf::MessageField::none(),
            subscriberList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSubscriptionSubscribersResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSubscriptionSubscribersResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSubscriptionSubscribersResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionSubscribersResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListSubscriptionSubscribersResp`
pub mod list_subscription_subscribers_resp {
    /// Cursor 游标
    /// List 列表
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.ListSubscriptionSubscribersResp.Subscriber)
    pub struct Subscriber {
        // message fields
        /// UserId 用户id
        // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersResp.Subscriber.userId)
        pub userId: ::std::string::String,
        /// SubscribeTime 订阅时间
        // @@protoc_insertion_point(field:pb.ListSubscriptionSubscribersResp.Subscriber.subscribeTime)
        pub subscribeTime: i64,
        // special fields
        // @@protoc_insertion_point(special_field:pb.ListSubscriptionSubscribersResp.Subscriber.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Subscriber {
        fn default() -> &'a Subscriber {
            <Subscriber as ::protobuf::Message>::default_instance()
        }
    }

    impl Subscriber {
        pub fn new() -> Subscriber {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "userId",
                |m: &Subscriber| { &m.userId },
                |m: &mut Subscriber| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "subscribeTime",
                |m: &Subscriber| { &m.subscribeTime },
                |m: &mut Subscriber| { &mut m.subscribeTime },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscriber>(
                "ListSubscriptionSubscribersResp.Subscriber",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Subscriber {
        const NAME: &'static str = "Subscriber";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.userId = is.read_string()?;
                    },
                    16 => {
                        self.subscribeTime = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.userId.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.userId);
            }
            if self.subscribeTime != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.subscribeTime);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.userId.is_empty() {
                os.write_string(1, &self.userId)?;
            }
            if self.subscribeTime != 0 {
                os.write_int64(2, self.subscribeTime)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Subscriber {
            Subscriber::new()
        }

        fn clear(&mut self) {
            self.userId.clear();
            self.subscribeTime = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Subscriber {
            static instance: Subscriber = Subscriber {
                userId: ::std::string::String::new(),
                subscribeTime: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Subscriber {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListSubscriptionSubscribersResp.Subscriber").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Subscriber {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Subscriber {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// FriendApplyStatus 好友申请状态
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.FriendApplyStatus)
pub enum FriendApplyStatus {
    // @@protoc_insertion_point(enum_value:pb.FriendApplyStatus.Applying)
    Applying = 0,
    // @@protoc_insertion_point(enum_value:pb.FriendApplyStatus.Accepted)
    Accepted = 1,
    // @@protoc_insertion_point(enum_value:pb.FriendApplyStatus.Rejected)
    Rejected = 2,
}

impl ::protobuf::Enum for FriendApplyStatus {
    const NAME: &'static str = "FriendApplyStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FriendApplyStatus> {
        match value {
            0 => ::std::option::Option::Some(FriendApplyStatus::Applying),
            1 => ::std::option::Option::Some(FriendApplyStatus::Accepted),
            2 => ::std::option::Option::Some(FriendApplyStatus::Rejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FriendApplyStatus] = &[
        FriendApplyStatus::Applying,
        FriendApplyStatus::Accepted,
        FriendApplyStatus::Rejected,
    ];
}

impl ::protobuf::EnumFull for FriendApplyStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FriendApplyStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FriendApplyStatus {
    fn default() -> Self {
        FriendApplyStatus::Applying
    }
}

impl FriendApplyStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FriendApplyStatus>("FriendApplyStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12conversation.proto\x12\x02pb\x1a\x0ccommon.proto\"\x97\x03\n\x0eGr\
    oupCreateReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeader\
    R\x06header\x12\x17\n\x04name\x18\x02\x20\x01(\tH\0R\x04name\x88\x01\x01\
    \x12\x1b\n\x06avatar\x18\x03\x20\x01(\tH\x01R\x06avatar\x88\x01\x01\x12\
    \x1e\n\nmemberList\x18\x04\x20\x03(\tR\nmemberList\x129\n\x07infoMap\x18\
    \x05\x20\x03(\x0b2\x1f.pb.GroupCreateReq.InfoMapEntryR\x07infoMap\x12<\n\
    \x08extraMap\x18\x06\x20\x03(\x0b2\x20.pb.GroupCreateReq.ExtraMapEntryR\
    \x08extraMap\x1a:\n\x0cInfoMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a;\n\
    \rExtraMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x07\n\x05_nameB\t\n\
    \x07_avatar\"W\n\x0fGroupCreateResp\x12*\n\x06header\x18\x01\x20\x01(\
    \x0b2\x12.pb.ResponseHeaderR\x06header\x12\x18\n\x07groupId\x18\x02\x20\
    \x01(\tR\x07groupId\">\n\x11CountJoinGroupReq\x12)\n\x06header\x18\x01\
    \x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\"V\n\x12CountJoinGroupRes\
    p\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06heade\
    r\x12\x14\n\x05count\x18\x02\x20\x01(\x03R\x05count\"@\n\x13CountCreateG\
    roupReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06\
    header\"X\n\x14CountCreateGroupResp\x12*\n\x06header\x18\x01\x20\x01(\
    \x0b2\x12.pb.ResponseHeaderR\x06header\x12\x14\n\x05count\x18\x02\x20\
    \x01(\x03R\x05count\">\n\x11GroupSubscribeReq\x12)\n\x06header\x18\x01\
    \x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\"@\n\x12GroupSubscribeRes\
    p\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06heade\
    r\"\xc4\x02\n\x17ListGroupSubscribersReq\x12)\n\x06header\x18\x01\x20\
    \x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\x18\n\x07groupId\x18\x02\
    \x20\x01(\tR\x07groupId\x12\x16\n\x06cursor\x18\x03\x20\x01(\x03R\x06cur\
    sor\x12\x14\n\x05limit\x18\x04\x20\x01(\x03R\x05limit\x12:\n\x06filter\
    \x18\x05\x20\x01(\x0b2\".pb.ListGroupSubscribersReq.FilterR\x06filter\
    \x12:\n\x06option\x18\x06\x20\x01(\x0b2\".pb.ListGroupSubscribersReq.Opt\
    ionR\x06option\x1a4\n\x06Filter\x12*\n\x10subscribeTimeGte\x18\x01\x20\
    \x01(\x03R\x10subscribeTimeGte\x1a\x08\n\x06Option\"\xe3\x01\n\x18ListGr\
    oupSubscribersResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Respons\
    eHeaderR\x06header\x12O\n\x0esubscriberList\x18\x02\x20\x03(\x0b2'.pb.Li\
    stGroupSubscribersResp.SubscriberR\x0esubscriberList\x1aJ\n\nSubscriber\
    \x12\x16\n\x06userId\x18\x01\x20\x01(\tR\x06userId\x12$\n\rsubscribeTime\
    \x18\x02\x20\x01(\x03R\rsubscribeTime\"\xaa\x01\n\x0eFriendApplyReq\x12)\
    \n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\
    \x1a\n\x08toUserId\x18\x02\x20\x01(\tR\x08toUserId\x12\x1d\n\x07message\
    \x18\x03\x20\x01(\tH\0R\x07message\x88\x01\x01\x12\x1b\n\x06answer\x18\
    \x04\x20\x01(\tH\x01R\x06answer\x88\x01\x01B\n\n\x08_messageB\t\n\x07_an\
    swer\"=\n\x0fFriendApplyResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.\
    pb.ResponseHeaderR\x06header\"\xab\x01\n\x14FriendApplyHandleReq\x12)\n\
    \x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\x18\
    \n\x07applyId\x18\x02\x20\x01(\tR\x07applyId\x12\x14\n\x05agree\x18\x03\
    \x20\x01(\x08R\x05agree\x12'\n\x0cfirstMessage\x18\x04\x20\x01(\tH\0R\
    \x0cfirstMessage\x88\x01\x01B\x0f\n\r_firstMessage\"C\n\x15FriendApplyHa\
    ndleResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\
    \x06header\"\xda\x02\n\x12ListFriendApplyReq\x12)\n\x06header\x18\x01\
    \x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\x16\n\x06cursor\x18\
    \x02\x20\x01(\x03R\x06cursor\x12\x14\n\x05limit\x18\x03\x20\x01(\x03R\
    \x05limit\x125\n\x06filter\x18\x04\x20\x01(\x0b2\x1d.pb.ListFriendApplyR\
    eq.FilterR\x06filter\x125\n\x06option\x18\x05\x20\x01(\x0b2\x1d.pb.ListF\
    riendApplyReq.OptionR\x06option\x1aG\n\x06Filter\x122\n\x06status\x18\
    \x01\x20\x01(\x0e2\x15.pb.FriendApplyStatusH\0R\x06status\x88\x01\x01B\t\
    \n\x07_status\x1a4\n\x06Option\x12*\n\x10includeApplyByMe\x18\x01\x20\
    \x01(\x08R\x10includeApplyByMe\"\xc0\x02\n\x13ListFriendApplyResp\x12*\n\
    \x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12\
    \x16\n\x06cursor\x18\x02\x20\x01(\x03R\x06cursor\x12M\n\x0ffriendApplyLi\
    st\x18\x03\x20\x03(\x0b2#.pb.ListFriendApplyResp.FriendApplyR\x0ffriendA\
    pplyList\x1a\x95\x01\n\x0bFriendApply\x12\x18\n\x07applyId\x18\x01\x20\
    \x01(\tR\x07applyId\x12\x1e\n\nfromUserId\x18\x02\x20\x01(\tR\nfromUserI\
    d\x12\x1a\n\x08toUserId\x18\x03\x20\x01(\tR\x08toUserId\x12\x18\n\x07mes\
    sage\x18\x04\x20\x01(\tR\x07message\x12\x16\n\x06answer\x18\x05\x20\x01(\
    \tR\x06answer\";\n\x0eCountFriendReq\x12)\n\x06header\x18\x01\x20\x01(\
    \x0b2\x11.pb.RequestHeaderR\x06header\"S\n\x0fCountFriendResp\x12*\n\x06\
    header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12\x14\n\
    \x05count\x18\x02\x20\x01(\x03R\x05count\"I\n\x1cConversationSettingUpda\
    teReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06he\
    ader\"K\n\x1dConversationSettingUpdateResp\x12*\n\x06header\x18\x01\x20\
    \x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"\xde\x05\n\x1aListJoinedCon\
    versationsReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeade\
    rR\x06header\x12@\n\x10conversationType\x18\x02\x20\x01(\x0e2\x14.pb.Con\
    versationTypeR\x10conversationType\x12\x16\n\x06cursor\x18\x03\x20\x01(\
    \x03R\x06cursor\x12\x14\n\x05limit\x18\x04\x20\x01(\x03R\x05limit\x12=\n\
    \x06filter\x18\x05\x20\x01(\x0b2%.pb.ListJoinedConversationsReq.FilterR\
    \x06filter\x12=\n\x06option\x18\x06\x20\x01(\x0b2%.pb.ListJoinedConversa\
    tionsReq.OptionR\x06option\x1a\xe6\x02\n\x06Filter\x12Q\n\x0bsettingList\
    \x18\x01\x20\x03(\x0b2/.pb.ListJoinedConversationsReq.Filter.SettingKVR\
    \x0bsettingList\x1a\x88\x02\n\tSettingKV\x12,\n\x03key\x18\x01\x20\x01(\
    \x0e2\x1a.pb.ConversationSettingKeyR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value\x12T\n\x08operator\x18\x03\x20\x01(\x0e28.pb.ListJ\
    oinedConversationsReq.Filter.SettingKV.OperatorR\x08operator\x12\x20\n\
    \x0borNotExists\x18\x04\x20\x01(\x08R\x0borNotExists\x12\x1a\n\x08orExis\
    ts\x18\x05\x20\x01(\x08R\x08orExists\"#\n\x08Operator\x12\t\n\x05Equal\
    \x10\0\x12\x0c\n\x08NotEqual\x10\x01\x1a>\n\x06Option\x124\n\x15includeS\
    elfMemberInfo\x18\x02\x20\x01(\x08R\x15includeSelfMemberInfo\"\xc9\x03\n\
    \x1bListJoinedConversationsResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\
    \x12.pb.ResponseHeaderR\x06header\x12X\n\x10conversationList\x18\x03\x20\
    \x03(\x0b2,.pb.ListJoinedConversationsResp.ConversationR\x10conversation\
    List\x1a\xa3\x02\n\x0cConversation\x12&\n\x0econversationId\x18\x01\x20\
    \x01(\tR\x0econversationId\x12@\n\x10conversationType\x18\x02\x20\x01(\
    \x0e2\x14.pb.ConversationTypeR\x10conversationType\x12h\n\x0eselfMemberI\
    nfo\x18\x1f\x20\x01(\x0b2;.pb.ListJoinedConversationsResp.Conversation.S\
    elfMemberInfoH\0R\x0eselfMemberInfo\x88\x01\x01\x1a,\n\x0eSelfMemberInfo\
    \x12\x1a\n\x08joinTime\x18\x01\x20\x01(\x03R\x08joinTimeB\x11\n\x0f_self\
    MemberInfo\"E\n\x18SubscriptionSubscribeReq\x12)\n\x06header\x18\x01\x20\
    \x01(\x0b2\x11.pb.RequestHeaderR\x06header\"G\n\x19SubscriptionSubscribe\
    Resp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06he\
    ader\"G\n\x1aSubscriptionAfterOnlineReq\x12)\n\x06header\x18\x01\x20\x01\
    (\x0b2\x11.pb.RequestHeaderR\x06header\"I\n\x1bSubscriptionAfterOnlineRe\
    sp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06head\
    er\"`\n\x1bSubscriptionAfterOfflineReq\x12)\n\x06header\x18\x01\x20\x01(\
    \x0b2\x11.pb.RequestHeaderR\x06header\x12\x16\n\x06userId\x18\x02\x20\
    \x01(\tR\x06userId\"J\n\x1cSubscriptionAfterOfflineResp\x12*\n\x06header\
    \x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"\xfd\x01\n\x10U\
    serSubscription\x12&\n\x0esubscriptionId\x18\x01\x20\x01(\tR\x0esubscrip\
    tionId\x12\x1e\n\nSubscriber\x18\x02\x20\x01(\tR\nSubscriber\x12$\n\rsub\
    scribeTime\x18\x03\x20\x01(\x03R\rsubscribeTime\x12>\n\x08extraMap\x18\
    \x06\x20\x03(\x0b2\".pb.UserSubscription.ExtraMapEntryR\x08extraMap\x1a;\
    \n\rExtraMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb0\x01\n\x19UpsertUs\
    erSubscriptionReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestH\
    eaderR\x06header\x12&\n\x0esubscriptionId\x18\x02\x20\x01(\tR\x0esubscri\
    ptionId\x12@\n\x10userSubscription\x18\x03\x20\x01(\x0b2\x14.pb.UserSubs\
    criptionR\x10userSubscription\"H\n\x1aUpsertUserSubscriptionResp\x12*\n\
    \x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"n\n\
    \x19DeleteUserSubscriptionReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11\
    .pb.RequestHeaderR\x06header\x12&\n\x0esubscriptionId\x18\x02\x20\x01(\t\
    R\x0esubscriptionId\"H\n\x1aDeleteUserSubscriptionResp\x12*\n\x06header\
    \x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"\xe7\x02\n\x1eL\
    istSubscriptionSubscribersReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11\
    .pb.RequestHeaderR\x06header\x12&\n\x0esubscriptionId\x18\x02\x20\x01(\t\
    R\x0esubscriptionId\x12\x16\n\x06cursor\x18\x03\x20\x01(\x03R\x06cursor\
    \x12\x14\n\x05limit\x18\x04\x20\x01(\x03R\x05limit\x12A\n\x06filter\x18\
    \x05\x20\x01(\x0b2).pb.ListSubscriptionSubscribersReq.FilterR\x06filter\
    \x12A\n\x06option\x18\x06\x20\x01(\x0b2).pb.ListSubscriptionSubscribersR\
    eq.OptionR\x06option\x1a4\n\x06Filter\x12*\n\x10subscribeTimeGte\x18\x01\
    \x20\x01(\x03R\x10subscribeTimeGte\x1a\x08\n\x06Option\"\xf1\x01\n\x1fLi\
    stSubscriptionSubscribersResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12\
    .pb.ResponseHeaderR\x06header\x12V\n\x0esubscriberList\x18\x02\x20\x03(\
    \x0b2..pb.ListSubscriptionSubscribersResp.SubscriberR\x0esubscriberList\
    \x1aJ\n\nSubscriber\x12\x16\n\x06userId\x18\x01\x20\x01(\tR\x06userId\
    \x12$\n\rsubscribeTime\x18\x02\x20\x01(\x03R\rsubscribeTime*=\n\x11Frien\
    dApplyStatus\x12\x0c\n\x08Applying\x10\0\x12\x0c\n\x08Accepted\x10\x01\
    \x12\x0c\n\x08Rejected\x10\x022\xec\x02\n\x0cgroupService\x128\n\x0bGrou\
    pCreate\x12\x12.pb.GroupCreateReq\x1a\x13.pb.GroupCreateResp\"\0\x12A\n\
    \x0eCountJoinGroup\x12\x15.pb.CountJoinGroupReq\x1a\x16.pb.CountJoinGrou\
    pResp\"\0\x12G\n\x10CountCreateGroup\x12\x17.pb.CountCreateGroupReq\x1a\
    \x18.pb.CountCreateGroupResp\"\0\x12A\n\x0eGroupSubscribe\x12\x15.pb.Gro\
    upSubscribeReq\x1a\x16.pb.GroupSubscribeResp\"\0\x12S\n\x14ListGroupSubs\
    cribers\x12\x1b.pb.ListGroupSubscribersReq\x1a\x1c.pb.ListGroupSubscribe\
    rsResp\"\02\x95\x02\n\rfriendService\x128\n\x0bFriendApply\x12\x12.pb.Fr\
    iendApplyReq\x1a\x13.pb.FriendApplyResp\"\0\x12J\n\x11FriendApplyHandle\
    \x12\x18.pb.FriendApplyHandleReq\x1a\x19.pb.FriendApplyHandleResp\"\0\
    \x12D\n\x0fListFriendApply\x12\x16.pb.ListFriendApplyReq\x1a\x17.pb.List\
    FriendApplyResp\"\0\x128\n\x0bCountFriend\x12\x12.pb.CountFriendReq\x1a\
    \x13.pb.CountFriendResp\"\02\xd7\x01\n\x13conversationService\x12b\n\x19\
    ConversationSettingUpdate\x12\x20.pb.ConversationSettingUpdateReq\x1a!.p\
    b.ConversationSettingUpdateResp\"\0\x12\\\n\x17ListJoinedConversations\
    \x12\x1e.pb.ListJoinedConversationsReq\x1a\x1f.pb.ListJoinedConversation\
    sResp\"\02\xcc\x04\n\x13subscriptionService\x12V\n\x15SubscriptionSubscr\
    ibe\x12\x1c.pb.SubscriptionSubscribeReq\x1a\x1d.pb.SubscriptionSubscribe\
    Resp\"\0\x12\\\n\x17SubscriptionAfterOnline\x12\x1e.pb.SubscriptionAfter\
    OnlineReq\x1a\x1f.pb.SubscriptionAfterOnlineResp\"\0\x12_\n\x18Subscript\
    ionAfterOffline\x12\x1f.pb.SubscriptionAfterOfflineReq\x1a\x20.pb.Subscr\
    iptionAfterOfflineResp\"\0\x12Y\n\x16UpsertUserSubscription\x12\x1d.pb.U\
    psertUserSubscriptionReq\x1a\x1e.pb.UpsertUserSubscriptionResp\"\0\x12Y\
    \n\x16DeleteUserSubscription\x12\x1d.pb.DeleteUserSubscriptionReq\x1a\
    \x1e.pb.DeleteUserSubscriptionResp\"\0\x12h\n\x1bListSubscriptionSubscri\
    bers\x12\".pb.ListSubscriptionSubscribersReq\x1a#.pb.ListSubscriptionSub\
    scribersResp\"\0B\x06Z\x04./pbJ\xd6]\n\x07\x12\x05\0\0\xfa\x02\x01\n\x08\
    \n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x0b\n\x08\n\x01\
    \x08\x12\x03\x02\0\x1b\n\t\n\x02\x08\x0b\x12\x03\x02\0\x1b\n\t\n\x02\x03\
    \0\x12\x03\x03\0\x16\n%\n\x02\x04\0\x12\x04\x07\0\x0e\x012\x19GroupCreat\
    e\x20\xe5\x88\x9b\xe5\xbb\xba\xe7\xbe\xa4\xe7\xbb\x84\n\n\n\n\x03\x04\0\
    \x01\x12\x03\x07\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\x08\x02\x1b\n\
    \x0c\n\x05\x04\0\x02\0\x06\x12\x03\x08\x02\x0f\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x08\x10\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x08\x19\x1a\
    \n\x0b\n\x04\x04\0\x02\x01\x12\x03\t\x02\x1b\n\x0c\n\x05\x04\0\x02\x01\
    \x04\x12\x03\t\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\t\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03\t\x12\x16\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03\t\x19\x1a\n\x0b\n\x04\x04\0\x02\x02\x12\x03\n\x02\x1d\n\x0c\
    \n\x05\x04\0\x02\x02\x04\x12\x03\n\x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\
    \x12\x03\n\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\n\x12\x18\n\x0c\
    \n\x05\x04\0\x02\x02\x03\x12\x03\n\x1b\x1c\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\x0b\x02!\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x0b\x02\n\n\x0c\n\
    \x05\x04\0\x02\x03\x05\x12\x03\x0b\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\x01\
    \x12\x03\x0b\x12\x1c\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0b\x1f\x20\n\
    \x0b\n\x04\x04\0\x02\x04\x12\x03\x0c\x02\"\n\x0c\n\x05\x04\0\x02\x04\x06\
    \x12\x03\x0c\x02\x15\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x0c\x16\x1d\n\
    \x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x0c\x20!\n\x0b\n\x04\x04\0\x02\x05\
    \x12\x03\r\x02#\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\r\x02\x15\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x03\r\x16\x1e\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03\r!\"\n\n\n\x02\x04\x01\x12\x04\x10\0\x13\x01\n\n\n\x03\x04\x01\
    \x01\x12\x03\x10\x08\x17\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x11\x02\x1c\n\
    \x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x11\x02\x10\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x11\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x11\x1a\
    \x1b\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x12\x02\x15\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x03\x12\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\
    \x12\t\x10\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x12\x13\x14\n:\n\x02\
    \x04\x02\x12\x04\x16\0\x18\x01\x1a.CountJoinGroupReq\x20\xe7\xbb\x9f\xe8\
    \xae\xa1\xe5\x8a\xa0\xe5\x85\xa5\xe7\x9a\x84\xe7\xbe\xa4\xe7\xbb\x84\xe6\
    \x95\xb0\xe9\x87\x8f\n\n\n\n\x03\x04\x02\x01\x12\x03\x16\x08\x19\n\x0b\n\
    \x04\x04\x02\x02\0\x12\x03\x17\x02\x1b\n\x0c\n\x05\x04\x02\x02\0\x06\x12\
    \x03\x17\x02\x0f\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x17\x10\x16\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03\x17\x19\x1a\n\n\n\x02\x04\x03\x12\x04\
    \x1a\0\x1d\x01\n\n\n\x03\x04\x03\x01\x12\x03\x1a\x08\x1a\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03\x1b\x02\x1c\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03\x1b\
    \x02\x10\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x1b\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03\x1b\x1a\x1b\n\x0b\n\x04\x04\x03\x02\x01\x12\
    \x03\x1c\x02\x12\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\x1c\x02\x07\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x1c\x08\r\n\x0c\n\x05\x04\x03\x02\
    \x01\x03\x12\x03\x1c\x10\x11\n<\n\x02\x04\x04\x12\x04\x20\0\"\x01\x1a0Co\
    untCreateGroupReq\x20\xe7\xbb\x9f\xe8\xae\xa1\xe5\x88\x9b\xe5\xbb\xba\
    \xe7\x9a\x84\xe7\xbe\xa4\xe7\xbb\x84\xe6\x95\xb0\xe9\x87\x8f\n\n\n\n\x03\
    \x04\x04\x01\x12\x03\x20\x08\x1b\n\x0b\n\x04\x04\x04\x02\0\x12\x03!\x02\
    \x1b\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03!\x02\x0f\n\x0c\n\x05\x04\x04\
    \x02\0\x01\x12\x03!\x10\x16\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03!\x19\
    \x1a\n\n\n\x02\x04\x05\x12\x04$\0'\x01\n\n\n\x03\x04\x05\x01\x12\x03$\
    \x08\x1c\n\x0b\n\x04\x04\x05\x02\0\x12\x03%\x02\x1c\n\x0c\n\x05\x04\x05\
    \x02\0\x06\x12\x03%\x02\x10\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03%\x11\
    \x17\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03%\x1a\x1b\n\x0b\n\x04\x04\x05\
    \x02\x01\x12\x03&\x02\x12\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03&\x02\
    \x07\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03&\x08\r\n\x0c\n\x05\x04\x05\
    \x02\x01\x03\x12\x03&\x10\x11\n(\n\x02\x04\x06\x12\x04+\0-\x012\x1cGroup\
    Subscribe\x20\xe7\xbe\xa4\xe7\xbb\x84\xe8\xae\xa2\xe9\x98\x85\n\n\n\n\
    \x03\x04\x06\x01\x12\x03+\x08\x19\n\x0b\n\x04\x04\x06\x02\0\x12\x03,\x02\
    \x1b\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03,\x02\x0f\n\x0c\n\x05\x04\x06\
    \x02\0\x01\x12\x03,\x10\x16\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03,\x19\
    \x1a\n\n\n\x02\x04\x07\x12\x04/\01\x01\n\n\n\x03\x04\x07\x01\x12\x03/\
    \x08\x1a\n\x0b\n\x04\x04\x07\x02\0\x12\x030\x02\x1c\n\x0c\n\x05\x04\x07\
    \x02\0\x06\x12\x030\x02\x10\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x030\x11\
    \x17\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x030\x1a\x1b\n:\n\x02\x04\x08\x12\
    \x044\0F\x01\x1a.ListGroupSubscribersReq\x20\xe5\x88\x97\xe5\x87\xba\xe7\
    \xbe\xa4\xe7\xbb\x84\xe8\xae\xa2\xe9\x98\x85\xe8\x80\x85\n\n\n\n\x03\x04\
    \x08\x01\x12\x034\x08\x1f\n\x0b\n\x04\x04\x08\x02\0\x12\x035\x02\x1b\n\
    \x0c\n\x05\x04\x08\x02\0\x06\x12\x035\x02\x0f\n\x0c\n\x05\x04\x08\x02\0\
    \x01\x12\x035\x10\x16\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x035\x19\x1a\n\
    \x1e\n\x04\x04\x08\x02\x01\x12\x037\x02\x15\x1a\x11GroupId\x20\xe7\xbe\
    \xa4\xe7\xbb\x84id\n\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x037\x02\x08\n\
    \x0c\n\x05\x04\x08\x02\x01\x01\x12\x037\t\x10\n\x0c\n\x05\x04\x08\x02\
    \x01\x03\x12\x037\x13\x14\n\x1b\n\x04\x04\x08\x02\x02\x12\x039\x02\x13\
    \x1a\x0eCursor\x20\xe6\xb8\xb8\xe6\xa0\x87\n\n\x0c\n\x05\x04\x08\x02\x02\
    \x05\x12\x039\x02\x07\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x039\x08\x0e\n\
    \x0c\n\x05\x04\x08\x02\x02\x03\x12\x039\x11\x12\n\x1a\n\x04\x04\x08\x02\
    \x03\x12\x03;\x02\x12\x1a\rLimit\x20\xe9\x99\x90\xe5\x88\xb6\n\n\x0c\n\
    \x05\x04\x08\x02\x03\x05\x12\x03;\x02\x07\n\x0c\n\x05\x04\x08\x02\x03\
    \x01\x12\x03;\x08\r\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03;\x10\x11\n\
    \x1f\n\x04\x04\x08\x03\0\x12\x04=\x02@\x03\x1a\x11Filter\x20\xe8\xbf\x87\
    \xe6\xbb\xa4\xe5\x99\xa8\n\n\x0c\n\x05\x04\x08\x03\0\x01\x12\x03=\n\x10\
    \n9\n\x06\x04\x08\x03\0\x02\0\x12\x03?\x04\x1f\x1a*subscribeTimeGte\x20\
    \xe8\xae\xa2\xe9\x98\x85\xe6\x97\xb6\xe9\x97\xb4\xe5\xa4\xa7\xe4\xba\x8e\
    \xe7\xad\x89\xe4\xba\x8e\n\n\x0e\n\x07\x04\x08\x03\0\x02\0\x05\x12\x03?\
    \x04\t\n\x0e\n\x07\x04\x08\x03\0\x02\0\x01\x12\x03?\n\x1a\n\x0e\n\x07\
    \x04\x08\x03\0\x02\0\x03\x12\x03?\x1d\x1e\n\x1c\n\x04\x04\x08\x03\x01\
    \x12\x04B\x02C\x03\x1a\x0eOption\x20\xe9\x80\x89\xe9\xa1\xb9\n\n\x0c\n\
    \x05\x04\x08\x03\x01\x01\x12\x03B\n\x10\n\x0b\n\x04\x04\x08\x02\x04\x12\
    \x03D\x02\x14\n\x0c\n\x05\x04\x08\x02\x04\x06\x12\x03D\x02\x08\n\x0c\n\
    \x05\x04\x08\x02\x04\x01\x12\x03D\t\x0f\n\x0c\n\x05\x04\x08\x02\x04\x03\
    \x12\x03D\x12\x13\n\x0b\n\x04\x04\x08\x02\x05\x12\x03E\x02\x14\n\x0c\n\
    \x05\x04\x08\x02\x05\x06\x12\x03E\x02\x08\n\x0c\n\x05\x04\x08\x02\x05\
    \x01\x12\x03E\t\x0f\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03E\x12\x13\n\n\
    \n\x02\x04\t\x12\x04H\0S\x01\n\n\n\x03\x04\t\x01\x12\x03H\x08\x20\n\x0b\
    \n\x04\x04\t\x02\0\x12\x03I\x02\x1c\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03I\
    \x02\x10\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03I\x11\x17\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03I\x1a\x1b\n(\n\x04\x04\t\x03\0\x12\x04L\x02Q\x03\x1a\
    \x1aCursor\x20\xe6\xb8\xb8\xe6\xa0\x87\nList\x20\xe5\x88\x97\xe8\xa1\xa8\
    \n\n\x0c\n\x05\x04\t\x03\0\x01\x12\x03L\n\x14\n\x1f\n\x06\x04\t\x03\0\
    \x02\0\x12\x03N\x04\x16\x1a\x10UserId\x20\xe7\x94\xa8\xe6\x88\xb7id\n\n\
    \x0e\n\x07\x04\t\x03\0\x02\0\x05\x12\x03N\x04\n\n\x0e\n\x07\x04\t\x03\0\
    \x02\0\x01\x12\x03N\x0b\x11\n\x0e\n\x07\x04\t\x03\0\x02\0\x03\x12\x03N\
    \x14\x15\n*\n\x06\x04\t\x03\0\x02\x01\x12\x03P\x04\x1c\x1a\x1bSubscribeT\
    ime\x20\xe8\xae\xa2\xe9\x98\x85\xe6\x97\xb6\xe9\x97\xb4\n\n\x0e\n\x07\
    \x04\t\x03\0\x02\x01\x05\x12\x03P\x04\t\n\x0e\n\x07\x04\t\x03\0\x02\x01\
    \x01\x12\x03P\n\x17\n\x0e\n\x07\x04\t\x03\0\x02\x01\x03\x12\x03P\x1a\x1b\
    \n\x0b\n\x04\x04\t\x02\x01\x12\x03R\x02)\n\x0c\n\x05\x04\t\x02\x01\x04\
    \x12\x03R\x02\n\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03R\x0b\x15\n\x0c\n\
    \x05\x04\t\x02\x01\x01\x12\x03R\x16$\n\x0c\n\x05\x04\t\x02\x01\x03\x12\
    \x03R'(\n\n\n\x02\x06\0\x12\x04U\0`\x01\n\n\n\x03\x06\0\x01\x12\x03U\x08\
    \x14\n&\n\x04\x06\0\x02\0\x12\x03W\x02>\x1a\x19GroupCreate\x20\xe5\x88\
    \x9b\xe5\xbb\xba\xe7\xbe\xa4\xe7\xbb\x84\n\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03W\x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03W\x12\x20\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03W+:\n8\n\x04\x06\0\x02\x01\x12\x03Y\x02G\x1a\
    +CountJoinGroup\x20\xe7\xbb\x9f\xe8\xae\xa1\xe5\x8a\xa0\xe5\x85\xa5\xe7\
    \x9a\x84\xe7\xbe\xa4\xe7\xbb\x84\xe6\x95\xb0\xe9\x87\x8f\n\n\x0c\n\x05\
    \x06\0\x02\x01\x01\x12\x03Y\x06\x14\n\x0c\n\x05\x06\0\x02\x01\x02\x12\
    \x03Y\x15&\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03Y1C\n:\n\x04\x06\0\x02\
    \x02\x12\x03[\x02M\x1a-CountCreateGroup\x20\xe7\xbb\x9f\xe8\xae\xa1\xe5\
    \x88\x9b\xe5\xbb\xba\xe7\x9a\x84\xe7\xbe\xa4\xe7\xbb\x84\xe6\x95\xb0\xe9\
    \x87\x8f\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03[\x06\x16\n\x0c\n\x05\
    \x06\0\x02\x02\x02\x12\x03[\x17*\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03[5\
    I\n)\n\x04\x06\0\x02\x03\x12\x03]\x02G\x1a\x1cGroupSubscribe\x20\xe7\xbe\
    \xa4\xe7\xbb\x84\xe8\xae\xa2\xe9\x98\x85\n\n\x0c\n\x05\x06\0\x02\x03\x01\
    \x12\x03]\x06\x14\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03]\x15&\n\x0c\n\
    \x05\x06\0\x02\x03\x03\x12\x03]1C\n8\n\x04\x06\0\x02\x04\x12\x03_\x02Y\
    \x1a+ListGroupSubscribers\x20\xe5\x88\x97\xe5\x87\xba\xe7\xbe\xa4\xe7\
    \xbb\x84\xe8\xae\xa2\xe9\x98\x85\xe8\x80\x85\n\n\x0c\n\x05\x06\0\x02\x04\
    \x01\x12\x03_\x06\x1a\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03_\x1b2\n\x0c\
    \n\x05\x06\0\x02\x04\x03\x12\x03_=U\n1\n\x02\x05\0\x12\x04c\0j\x01\x1a%F\
    riendApplyStatus\x20\xe5\xa5\xbd\xe5\x8f\x8b\xe7\x94\xb3\xe8\xaf\xb7\xe7\
    \x8a\xb6\xe6\x80\x81\n\n\n\n\x03\x05\0\x01\x12\x03c\x05\x16\n\x20\n\x04\
    \x05\0\x02\0\x12\x03e\x02\x0f\x1a\x13Applying\x20\xe7\x94\xb3\xe8\xaf\
    \xb7\xe4\xb8\xad\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03e\x02\n\n\x0c\n\
    \x05\x05\0\x02\0\x02\x12\x03e\r\x0e\n\x20\n\x04\x05\0\x02\x01\x12\x03g\
    \x02\x0f\x1a\x13Accepted\x20\xe5\xb7\xb2\xe5\x90\x8c\xe6\x84\x8f\n\n\x0c\
    \n\x05\x05\0\x02\x01\x01\x12\x03g\x02\n\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03g\r\x0e\n\x20\n\x04\x05\0\x02\x02\x12\x03i\x02\x0f\x1a\x13Reject\
    ed\x20\xe5\xb7\xb2\xe6\x8b\x92\xe7\xbb\x9d\n\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03i\x02\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03i\r\x0e\n+\n\
    \x02\x04\n\x12\x04n\0u\x012\x1fFriendApply\x20\xe7\x94\xb3\xe8\xaf\xb7\
    \xe6\xb7\xbb\xe5\x8a\xa0\xe5\xa5\xbd\xe5\x8f\x8b\n\n\n\n\x03\x04\n\x01\
    \x12\x03n\x08\x16\n\x0b\n\x04\x04\n\x02\0\x12\x03o\x02\x1b\n\x0c\n\x05\
    \x04\n\x02\0\x06\x12\x03o\x02\x0f\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03o\
    \x10\x16\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03o\x19\x1a\n\x0b\n\x04\x04\n\
    \x02\x01\x12\x03p\x02\x16\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03p\x02\x08\
    \n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03p\t\x11\n\x0c\n\x05\x04\n\x02\x01\
    \x03\x12\x03p\x14\x15\n\"\n\x04\x04\n\x02\x02\x12\x03r\x02\x1e\x1a\x15Me\
    ssage\x20\xe9\x99\x84\xe5\x8a\xa0\xe6\xb6\x88\xe6\x81\xaf\n\n\x0c\n\x05\
    \x04\n\x02\x02\x04\x12\x03r\x02\n\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03r\
    \x0b\x11\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03r\x12\x19\n\x0c\n\x05\x04\
    \n\x02\x02\x03\x12\x03r\x1c\x1d\n!\n\x04\x04\n\x02\x03\x12\x03t\x02\x1d\
    \x1a\x14Answer\x20\xe9\x99\x84\xe5\x8a\xa0\xe5\x9b\x9e\xe7\xad\x94\n\n\
    \x0c\n\x05\x04\n\x02\x03\x04\x12\x03t\x02\n\n\x0c\n\x05\x04\n\x02\x03\
    \x05\x12\x03t\x0b\x11\n\x0c\n\x05\x04\n\x02\x03\x01\x12\x03t\x12\x18\n\
    \x0c\n\x05\x04\n\x02\x03\x03\x12\x03t\x1b\x1c\n\n\n\x02\x04\x0b\x12\x04w\
    \0y\x01\n\n\n\x03\x04\x0b\x01\x12\x03w\x08\x17\n\x0b\n\x04\x04\x0b\x02\0\
    \x12\x03x\x02\x1c\n\x0c\n\x05\x04\x0b\x02\0\x06\x12\x03x\x02\x10\n\x0c\n\
    \x05\x04\x0b\x02\0\x01\x12\x03x\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x03\
    \x12\x03x\x1a\x1b\n2\n\x02\x04\x0c\x12\x05}\0\x84\x01\x012%FriendApplyHa\
    ndle\x20\xe5\xa4\x84\xe7\x90\x86\xe5\xa5\xbd\xe5\x8f\x8b\xe7\x94\xb3\xe8\
    \xaf\xb7\n\n\n\n\x03\x04\x0c\x01\x12\x03}\x08\x1c\n\x0b\n\x04\x04\x0c\
    \x02\0\x12\x03~\x02\x1b\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03~\x02\x0f\n\
    \x0c\n\x05\x04\x0c\x02\0\x01\x12\x03~\x10\x16\n\x0c\n\x05\x04\x0c\x02\0\
    \x03\x12\x03~\x19\x1a\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03\x7f\x02\x15\n\
    \x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\x04\x0c\
    \x02\x01\x01\x12\x03\x7f\t\x10\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03\
    \x7f\x13\x14\n!\n\x04\x04\x0c\x02\x02\x12\x04\x81\x01\x02\x11\x1a\x13Agr\
    ee\x20\xe6\x98\xaf\xe5\x90\xa6\xe5\x90\x8c\xe6\x84\x8f\n\n\r\n\x05\x04\
    \x0c\x02\x02\x05\x12\x04\x81\x01\x02\x06\n\r\n\x05\x04\x0c\x02\x02\x01\
    \x12\x04\x81\x01\x07\x0c\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x81\x01\
    \x0f\x10\n0\n\x04\x04\x0c\x02\x03\x12\x04\x83\x01\x02#\x1a\"\xe5\x90\x8c\
    \xe6\x84\x8f\xe5\x90\x8e\xe5\x8f\x91\xe9\x80\x81\xe7\x9a\x84\xe7\xac\xac\
    \xe4\xb8\x80\xe6\x9d\xa1\xe6\xb6\x88\xe6\x81\xaf\n\n\r\n\x05\x04\x0c\x02\
    \x03\x04\x12\x04\x83\x01\x02\n\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\x83\
    \x01\x0b\x11\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x83\x01\x12\x1e\n\r\n\
    \x05\x04\x0c\x02\x03\x03\x12\x04\x83\x01!\"\n\x0c\n\x02\x04\r\x12\x06\
    \x86\x01\0\x88\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x86\x01\x08\x1d\n\
    \x0c\n\x04\x04\r\x02\0\x12\x04\x87\x01\x02\x1c\n\r\n\x05\x04\r\x02\0\x06\
    \x12\x04\x87\x01\x02\x10\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x87\x01\x11\
    \x17\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x87\x01\x1a\x1b\n>\n\x02\x04\x0e\
    \x12\x06\x8c\x01\0\x9c\x01\x0120ListFriendApply\x20\xe5\x88\x97\xe5\x87\
    \xba\xe5\xa5\xbd\xe5\x8f\x8b\xe7\x94\xb3\xe8\xaf\xb7\x20\xe7\xbb\x99app\
    \xe7\x94\xa8\xe7\x9a\x84\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x8c\x01\x08\
    \x1a\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x8d\x01\x02\x1b\n\r\n\x05\x04\x0e\
    \x02\0\x06\x12\x04\x8d\x01\x02\x0f\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \x8d\x01\x10\x16\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x8d\x01\x19\x1a\n\
    \x1c\n\x04\x04\x0e\x02\x01\x12\x04\x8f\x01\x02\x13\x1a\x0eCursor\x20\xe6\
    \xb8\xb8\xe6\xa0\x87\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x8f\x01\x02\
    \x07\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x8f\x01\x08\x0e\n\r\n\x05\x04\
    \x0e\x02\x01\x03\x12\x04\x8f\x01\x11\x12\n\x1b\n\x04\x04\x0e\x02\x02\x12\
    \x04\x91\x01\x02\x12\x1a\rLimit\x20\xe9\x99\x90\xe5\x88\xb6\n\n\r\n\x05\
    \x04\x0e\x02\x02\x05\x12\x04\x91\x01\x02\x07\n\r\n\x05\x04\x0e\x02\x02\
    \x01\x12\x04\x91\x01\x08\r\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x91\x01\
    \x10\x11\n!\n\x04\x04\x0e\x03\0\x12\x06\x93\x01\x02\x95\x01\x03\x1a\x11F\
    ilter\x20\xe8\xbf\x87\xe6\xbb\xa4\xe5\x99\xa8\n\n\r\n\x05\x04\x0e\x03\0\
    \x01\x12\x04\x93\x01\n\x10\n\x0e\n\x06\x04\x0e\x03\0\x02\0\x12\x04\x94\
    \x01\x04*\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x04\x12\x04\x94\x01\x04\x0c\n\
    \x0f\n\x07\x04\x0e\x03\0\x02\0\x06\x12\x04\x94\x01\r\x1e\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\0\x01\x12\x04\x94\x01\x1f%\n\x0f\n\x07\x04\x0e\x03\0\x02\
    \0\x03\x12\x04\x94\x01()\n\x1e\n\x04\x04\x0e\x03\x01\x12\x06\x97\x01\x02\
    \x99\x01\x03\x1a\x0eOption\x20\xe9\x80\x89\xe9\xa1\xb9\n\n\r\n\x05\x04\
    \x0e\x03\x01\x01\x12\x04\x97\x01\n\x10\n)\n\x06\x04\x0e\x03\x01\x02\0\
    \x12\x04\x98\x01\x04\x1e\"\x19\xe5\x8c\x85\xe5\x90\xab\xe6\x88\x91\xe5\
    \x8f\x91\xe5\x87\xba\xe7\x9a\x84\xe7\x94\xb3\xe8\xaf\xb7\n\n\x0f\n\x07\
    \x04\x0e\x03\x01\x02\0\x05\x12\x04\x98\x01\x04\x08\n\x0f\n\x07\x04\x0e\
    \x03\x01\x02\0\x01\x12\x04\x98\x01\t\x19\n\x0f\n\x07\x04\x0e\x03\x01\x02\
    \0\x03\x12\x04\x98\x01\x1c\x1d\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\x9a\
    \x01\x02\x14\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\x9a\x01\x02\x08\n\r\n\
    \x05\x04\x0e\x02\x03\x01\x12\x04\x9a\x01\t\x0f\n\r\n\x05\x04\x0e\x02\x03\
    \x03\x12\x04\x9a\x01\x12\x13\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\x9b\x01\
    \x02\x14\n\r\n\x05\x04\x0e\x02\x04\x06\x12\x04\x9b\x01\x02\x08\n\r\n\x05\
    \x04\x0e\x02\x04\x01\x12\x04\x9b\x01\t\x0f\n\r\n\x05\x04\x0e\x02\x04\x03\
    \x12\x04\x9b\x01\x12\x13\n\x0c\n\x02\x04\x0f\x12\x06\x9e\x01\0\xb0\x01\
    \x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x9e\x01\x08\x1b\n\x0c\n\x04\x04\x0f\
    \x02\0\x12\x04\x9f\x01\x02\x1c\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x9f\
    \x01\x02\x10\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x9f\x01\x11\x17\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\x9f\x01\x1a\x1b\n\x1c\n\x04\x04\x0f\x02\
    \x01\x12\x04\xa1\x01\x02\x13\x1a\x0eCursor\x20\xe6\xb8\xb8\xe6\xa0\x87\n\
    \n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xa1\x01\x02\x07\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\xa1\x01\x08\x0e\n\r\n\x05\x04\x0f\x02\x01\x03\x12\
    \x04\xa1\x01\x11\x12\n\x1c\n\x04\x04\x0f\x03\0\x12\x06\xa3\x01\x02\xae\
    \x01\x03\x1a\x0cList\x20\xe5\x88\x97\xe8\xa1\xa8\n\n\r\n\x05\x04\x0f\x03\
    \0\x01\x12\x04\xa3\x01\n\x15\n!\n\x06\x04\x0f\x03\0\x02\0\x12\x04\xa5\
    \x01\x04\x17\x1a\x11ApplyId\x20\xe7\x94\xb3\xe8\xaf\xb7id\n\n\x0f\n\x07\
    \x04\x0f\x03\0\x02\0\x05\x12\x04\xa5\x01\x04\n\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\0\x01\x12\x04\xa5\x01\x0b\x12\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x03\
    \x12\x04\xa5\x01\x15\x16\n'\n\x06\x04\x0f\x03\0\x02\x01\x12\x04\xa7\x01\
    \x04\x1a\x1a\x17FromUserId\x20\xe7\x94\xb3\xe8\xaf\xb7\xe4\xba\xbaid\n\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\x01\x05\x12\x04\xa7\x01\x04\n\n\x0f\n\x07\
    \x04\x0f\x03\0\x02\x01\x01\x12\x04\xa7\x01\x0b\x15\n\x0f\n\x07\x04\x0f\
    \x03\0\x02\x01\x03\x12\x04\xa7\x01\x18\x19\n(\n\x06\x04\x0f\x03\0\x02\
    \x02\x12\x04\xa9\x01\x04\x18\x1a\x18ToUserId\x20\xe8\xa2\xab\xe7\x94\xb3\
    \xe8\xaf\xb7\xe4\xba\xbaid\n\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x05\x12\
    \x04\xa9\x01\x04\n\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x01\x12\x04\xa9\x01\
    \x0b\x13\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x03\x12\x04\xa9\x01\x16\x17\n\
    %\n\x06\x04\x0f\x03\0\x02\x03\x12\x04\xab\x01\x04\x17\x1a\x15Message\x20\
    \xe9\x99\x84\xe5\x8a\xa0\xe6\xb6\x88\xe6\x81\xaf\n\n\x0f\n\x07\x04\x0f\
    \x03\0\x02\x03\x05\x12\x04\xab\x01\x04\n\n\x0f\n\x07\x04\x0f\x03\0\x02\
    \x03\x01\x12\x04\xab\x01\x0b\x12\n\x0f\n\x07\x04\x0f\x03\0\x02\x03\x03\
    \x12\x04\xab\x01\x15\x16\n$\n\x06\x04\x0f\x03\0\x02\x04\x12\x04\xad\x01\
    \x04\x16\x1a\x14Answer\x20\xe9\x99\x84\xe5\x8a\xa0\xe5\x9b\x9e\xe7\xad\
    \x94\n\n\x0f\n\x07\x04\x0f\x03\0\x02\x04\x05\x12\x04\xad\x01\x04\n\n\x0f\
    \n\x07\x04\x0f\x03\0\x02\x04\x01\x12\x04\xad\x01\x0b\x11\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x04\x03\x12\x04\xad\x01\x14\x15\n\x0c\n\x04\x04\x0f\x02\
    \x02\x12\x04\xaf\x01\x02+\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xaf\x01\
    \x02\n\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xaf\x01\x0b\x16\n\r\n\x05\
    \x04\x0f\x02\x02\x01\x12\x04\xaf\x01\x17&\n\r\n\x05\x04\x0f\x02\x02\x03\
    \x12\x04\xaf\x01)*\n0\n\x02\x04\x10\x12\x06\xb3\x01\0\xb5\x01\x01\x1a\"C\
    ountFriendReq\x20\xe7\xbb\x9f\xe8\xae\xa1\xe5\xa5\xbd\xe5\x8f\x8b\xe6\
    \x95\xb0\xe9\x87\x8f\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xb3\x01\x08\x16\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xb4\x01\x02\x1b\n\r\n\x05\x04\x10\x02\0\
    \x06\x12\x04\xb4\x01\x02\x0f\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb4\x01\
    \x10\x16\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb4\x01\x19\x1a\n\x0c\n\x02\
    \x04\x11\x12\x06\xb7\x01\0\xba\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xb7\x01\x08\x17\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xb8\x01\x02\x1c\n\r\n\
    \x05\x04\x11\x02\0\x06\x12\x04\xb8\x01\x02\x10\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb8\x01\
    \x1a\x1b\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xb9\x01\x02\x12\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\xb9\x01\x02\x07\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xb9\x01\x08\r\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb9\x01\
    \x10\x11\n\x0c\n\x02\x06\x01\x12\x06\xbc\x01\0\xc5\x01\x01\n\x0b\n\x03\
    \x06\x01\x01\x12\x04\xbc\x01\x08\x15\n'\n\x04\x06\x01\x02\0\x12\x04\xbe\
    \x01\x02>\x1a\x19FriendApply\x20\xe6\xb7\xbb\xe5\x8a\xa0\xe5\xa5\xbd\xe5\
    \x8f\x8b\n\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\xbe\x01\x06\x11\n\r\n\x05\
    \x06\x01\x02\0\x02\x12\x04\xbe\x01\x12\x20\n\r\n\x05\x06\x01\x02\0\x03\
    \x12\x04\xbe\x01+:\n3\n\x04\x06\x01\x02\x01\x12\x04\xc0\x01\x02P\x1a%Fri\
    endApplyHandle\x20\xe5\xa4\x84\xe7\x90\x86\xe5\xa5\xbd\xe5\x8f\x8b\xe7\
    \x94\xb3\xe8\xaf\xb7\n\n\r\n\x05\x06\x01\x02\x01\x01\x12\x04\xc0\x01\x06\
    \x17\n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\xc0\x01\x18,\n\r\n\x05\x06\
    \x01\x02\x01\x03\x12\x04\xc0\x017L\n1\n\x04\x06\x01\x02\x02\x12\x04\xc2\
    \x01\x02J\x1a#ListFriendApply\x20\xe5\x88\x97\xe5\x87\xba\xe5\xa5\xbd\
    \xe5\x8f\x8b\xe7\x94\xb3\xe8\xaf\xb7\n\n\r\n\x05\x06\x01\x02\x02\x01\x12\
    \x04\xc2\x01\x06\x15\n\r\n\x05\x06\x01\x02\x02\x02\x12\x04\xc2\x01\x16(\
    \n\r\n\x05\x06\x01\x02\x02\x03\x12\x04\xc2\x013F\n-\n\x04\x06\x01\x02\
    \x03\x12\x04\xc4\x01\x02>\x1a\x1fCountFriend\x20\xe7\xbb\x9f\xe8\xae\xa1\
    \xe5\xa5\xbd\xe5\x8f\x8b\xe6\x95\xb0\xe9\x87\x8f\n\n\r\n\x05\x06\x01\x02\
    \x03\x01\x12\x04\xc4\x01\x06\x11\n\r\n\x05\x06\x01\x02\x03\x02\x12\x04\
    \xc4\x01\x12\x20\n\r\n\x05\x06\x01\x02\x03\x03\x12\x04\xc4\x01+:\n\x0c\n\
    \x02\x04\x12\x12\x06\xc7\x01\0\xc9\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\xc7\x01\x08$\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xc8\x01\x02\x1b\n\r\
    \n\x05\x04\x12\x02\0\x06\x12\x04\xc8\x01\x02\x0f\n\r\n\x05\x04\x12\x02\0\
    \x01\x12\x04\xc8\x01\x10\x16\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc8\x01\
    \x19\x1a\n\x0c\n\x02\x04\x13\x12\x06\xcb\x01\0\xcd\x01\x01\n\x0b\n\x03\
    \x04\x13\x01\x12\x04\xcb\x01\x08%\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xcc\
    \x01\x02\x1c\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xcc\x01\x02\x10\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xcc\x01\x11\x17\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xcc\x01\x1a\x1b\n<\n\x02\x04\x14\x12\x06\xd1\x01\0\xf2\x01\
    \x012.ListJoinedConversations\x20\xe5\x88\x97\xe5\x87\xba\xe5\x8a\xa0\
    \xe5\x85\xa5\xe7\x9a\x84\xe4\xbc\x9a\xe8\xaf\x9d\n\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xd1\x01\x08\"\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xd2\x01\x02\
    \x1b\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xd2\x01\x02\x0f\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xd2\x01\x10\x16\n\r\n\x05\x04\x14\x02\0\x03\x12\
    \x04\xd2\x01\x19\x1a\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xd3\x01\x02(\n\
    \r\n\x05\x04\x14\x02\x01\x06\x12\x04\xd3\x01\x02\x12\n\r\n\x05\x04\x14\
    \x02\x01\x01\x12\x04\xd3\x01\x13#\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xd3\x01&'\n\x1c\n\x04\x04\x14\x02\x02\x12\x04\xd6\x01\x02\x13\x1a\x0eCu\
    rsor\x20\xe6\xb8\xb8\xe6\xa0\x87\n\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\
    \xd6\x01\x02\x07\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xd6\x01\x08\x0e\n\
    \r\n\x05\x04\x14\x02\x02\x03\x12\x04\xd6\x01\x11\x12\n\x1b\n\x04\x04\x14\
    \x02\x03\x12\x04\xd8\x01\x02\x12\x1a\rLimit\x20\xe9\x99\x90\xe5\x88\xb6\
    \n\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xd8\x01\x02\x07\n\r\n\x05\x04\
    \x14\x02\x03\x01\x12\x04\xd8\x01\x08\r\n\r\n\x05\x04\x14\x02\x03\x03\x12\
    \x04\xd8\x01\x10\x11\n!\n\x04\x04\x14\x03\0\x12\x06\xda\x01\x02\xea\x01\
    \x03\x1a\x11Filter\x20\xe8\xbf\x87\xe6\xbb\xa4\xe5\x99\xa8\n\n\r\n\x05\
    \x04\x14\x03\0\x01\x12\x04\xda\x01\n\x10\n\x10\n\x06\x04\x14\x03\0\x03\0\
    \x12\x06\xdb\x01\x04\xe7\x01\x05\n\x0f\n\x07\x04\x14\x03\0\x03\0\x01\x12\
    \x04\xdb\x01\x0c\x15\n\x12\n\x08\x04\x14\x03\0\x03\0\x04\0\x12\x06\xdc\
    \x01\x06\xe1\x01\x07\n\x11\n\t\x04\x14\x03\0\x03\0\x04\0\x01\x12\x04\xdc\
    \x01\x0b\x13\n\x1c\n\n\x04\x14\x03\0\x03\0\x04\0\x02\0\x12\x04\xde\x01\
    \x08\x12\x1a\x08\x20\xe7\xad\x89\xe4\xba\x8e\n\n\x13\n\x0b\x04\x14\x03\0\
    \x03\0\x04\0\x02\0\x01\x12\x04\xde\x01\x08\r\n\x13\n\x0b\x04\x14\x03\0\
    \x03\0\x04\0\x02\0\x02\x12\x04\xde\x01\x10\x11\n\x1f\n\n\x04\x14\x03\0\
    \x03\0\x04\0\x02\x01\x12\x04\xe0\x01\x08\x15\x1a\x0b\x20\xe4\xb8\x8d\xe7\
    \xad\x89\xe4\xba\x8e\n\n\x13\n\x0b\x04\x14\x03\0\x03\0\x04\0\x02\x01\x01\
    \x12\x04\xe0\x01\x08\x10\n\x13\n\x0b\x04\x14\x03\0\x03\0\x04\0\x02\x01\
    \x02\x12\x04\xe0\x01\x13\x14\n\x10\n\x08\x04\x14\x03\0\x03\0\x02\0\x12\
    \x04\xe2\x01\x06%\n\x11\n\t\x04\x14\x03\0\x03\0\x02\0\x06\x12\x04\xe2\
    \x01\x06\x1c\n\x11\n\t\x04\x14\x03\0\x03\0\x02\0\x01\x12\x04\xe2\x01\x1d\
    \x20\n\x11\n\t\x04\x14\x03\0\x03\0\x02\0\x03\x12\x04\xe2\x01#$\n\x10\n\
    \x08\x04\x14\x03\0\x03\0\x02\x01\x12\x04\xe3\x01\x06\x17\n\x11\n\t\x04\
    \x14\x03\0\x03\0\x02\x01\x05\x12\x04\xe3\x01\x06\x0c\n\x11\n\t\x04\x14\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xe3\x01\r\x12\n\x11\n\t\x04\x14\x03\0\
    \x03\0\x02\x01\x03\x12\x04\xe3\x01\x15\x16\n\x10\n\x08\x04\x14\x03\0\x03\
    \0\x02\x02\x12\x04\xe4\x01\x06\x1c\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x02\
    \x06\x12\x04\xe4\x01\x06\x0e\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x02\x01\
    \x12\x04\xe4\x01\x0f\x17\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x02\x03\x12\
    \x04\xe4\x01\x1a\x1b\n\x10\n\x08\x04\x14\x03\0\x03\0\x02\x03\x12\x04\xe5\
    \x01\x06\x1b\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x03\x05\x12\x04\xe5\x01\
    \x06\n\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x03\x01\x12\x04\xe5\x01\x0b\x16\
    \n\x11\n\t\x04\x14\x03\0\x03\0\x02\x03\x03\x12\x04\xe5\x01\x19\x1a\n\x10\
    \n\x08\x04\x14\x03\0\x03\0\x02\x04\x12\x04\xe6\x01\x06\x18\n\x11\n\t\x04\
    \x14\x03\0\x03\0\x02\x04\x05\x12\x04\xe6\x01\x06\n\n\x11\n\t\x04\x14\x03\
    \0\x03\0\x02\x04\x01\x12\x04\xe6\x01\x0b\x13\n\x11\n\t\x04\x14\x03\0\x03\
    \0\x02\x04\x03\x12\x04\xe6\x01\x16\x17\n0\n\x06\x04\x14\x03\0\x02\0\x12\
    \x04\xe9\x01\x04'\x1a\x20\xe4\xbd\xbf\xe7\x94\xa8setting\xe4\xb8\xad\xe7\
    \x9a\x84\xe5\xad\x97\xe6\xae\xb5\xe8\xbf\x87\xe6\xbb\xa4\n\n\x0f\n\x07\
    \x04\x14\x03\0\x02\0\x04\x12\x04\xe9\x01\x04\x0c\n\x0f\n\x07\x04\x14\x03\
    \0\x02\0\x06\x12\x04\xe9\x01\r\x16\n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\
    \x12\x04\xe9\x01\x17\"\n\x0f\n\x07\x04\x14\x03\0\x02\0\x03\x12\x04\xe9\
    \x01%&\n\x1e\n\x04\x04\x14\x03\x01\x12\x06\xec\x01\x02\xef\x01\x03\x1a\
    \x0eOption\x20\xe9\x80\x89\xe9\xa1\xb9\n\n\r\n\x05\x04\x14\x03\x01\x01\
    \x12\x04\xec\x01\n\x10\nH\n\x06\x04\x14\x03\x01\x02\0\x12\x04\xee\x01\
    \x04#\x1a8IncludeSelfMemberInfo\x20\xe6\x98\xaf\xe5\x90\xa6\xe5\x8c\x85\
    \xe5\x90\xab\xe8\x87\xaa\xe5\xb7\xb1\xe7\x9a\x84\xe6\x88\x90\xe5\x91\x98\
    \xe4\xbf\xa1\xe6\x81\xaf\n\n\x0f\n\x07\x04\x14\x03\x01\x02\0\x05\x12\x04\
    \xee\x01\x04\x08\n\x0f\n\x07\x04\x14\x03\x01\x02\0\x01\x12\x04\xee\x01\t\
    \x1e\n\x0f\n\x07\x04\x14\x03\x01\x02\0\x03\x12\x04\xee\x01!\"\n\x0c\n\
    \x04\x04\x14\x02\x04\x12\x04\xf0\x01\x02\x14\n\r\n\x05\x04\x14\x02\x04\
    \x06\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xf0\
    \x01\t\x0f\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xf0\x01\x12\x13\n\x0c\n\
    \x04\x04\x14\x02\x05\x12\x04\xf1\x01\x02\x14\n\r\n\x05\x04\x14\x02\x05\
    \x06\x12\x04\xf1\x01\x02\x08\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\xf1\
    \x01\t\x0f\n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\xf1\x01\x12\x13\n\x0c\n\
    \x02\x04\x15\x12\x06\xf4\x01\0\x81\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xf4\x01\x08#\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xf5\x01\x02\x1c\n\r\
    \n\x05\x04\x15\x02\0\x06\x12\x04\xf5\x01\x02\x10\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xf5\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xf5\x01\
    \x1a\x1b\n\x1c\n\x04\x04\x15\x03\0\x12\x06\xf7\x01\x02\xff\x01\x03\x1a\
    \x0cList\x20\xe5\x88\x97\xe8\xa1\xa8\n\n\r\n\x05\x04\x15\x03\0\x01\x12\
    \x04\xf7\x01\n\x16\n(\n\x06\x04\x15\x03\0\x02\0\x12\x04\xf9\x01\x04\x1e\
    \x1a\x18ConversationId\x20\xe4\xbc\x9a\xe8\xaf\x9did\n\n\x0f\n\x07\x04\
    \x15\x03\0\x02\0\x05\x12\x04\xf9\x01\x04\n\n\x0f\n\x07\x04\x15\x03\0\x02\
    \0\x01\x12\x04\xf9\x01\x0b\x19\n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\x12\
    \x04\xf9\x01\x1c\x1d\n\x0e\n\x06\x04\x15\x03\0\x02\x01\x12\x04\xfa\x01\
    \x04*\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x06\x12\x04\xfa\x01\x04\x14\n\
    \x0f\n\x07\x04\x15\x03\0\x02\x01\x01\x12\x04\xfa\x01\x15%\n\x0f\n\x07\
    \x04\x15\x03\0\x02\x01\x03\x12\x04\xfa\x01()\n\x10\n\x06\x04\x15\x03\0\
    \x03\0\x12\x06\xfb\x01\x04\xfd\x01\x05\n\x0f\n\x07\x04\x15\x03\0\x03\0\
    \x01\x12\x04\xfb\x01\x0c\x1a\n\x10\n\x08\x04\x15\x03\0\x03\0\x02\0\x12\
    \x04\xfc\x01\x06\x19\n\x11\n\t\x04\x15\x03\0\x03\0\x02\0\x05\x12\x04\xfc\
    \x01\x06\x0b\n\x11\n\t\x04\x15\x03\0\x03\0\x02\0\x01\x12\x04\xfc\x01\x0c\
    \x14\n\x11\n\t\x04\x15\x03\0\x03\0\x02\0\x03\x12\x04\xfc\x01\x17\x18\n\
    \x0e\n\x06\x04\x15\x03\0\x02\x02\x12\x04\xfe\x01\x040\n\x0f\n\x07\x04\
    \x15\x03\0\x02\x02\x04\x12\x04\xfe\x01\x04\x0c\n\x0f\n\x07\x04\x15\x03\0\
    \x02\x02\x06\x12\x04\xfe\x01\r\x1b\n\x0f\n\x07\x04\x15\x03\0\x02\x02\x01\
    \x12\x04\xfe\x01\x1c*\n\x0f\n\x07\x04\x15\x03\0\x02\x02\x03\x12\x04\xfe\
    \x01-/\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x80\x02\x02-\n\r\n\x05\x04\
    \x15\x02\x01\x04\x12\x04\x80\x02\x02\n\n\r\n\x05\x04\x15\x02\x01\x06\x12\
    \x04\x80\x02\x0b\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x80\x02\x18(\
    \n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x80\x02+,\n\x0c\n\x02\x06\x02\x12\
    \x06\x84\x02\0\x89\x02\x01\n\x0b\n\x03\x06\x02\x01\x12\x04\x84\x02\x08\
    \x1b\n;\n\x04\x06\x02\x02\0\x12\x04\x86\x02\x02h\x1a-ConversationSetting\
    Update\x20\xe6\x9b\xb4\xe6\x96\xb0\xe4\xbc\x9a\xe8\xaf\x9d\xe8\xae\xbe\
    \xe7\xbd\xae\n\n\r\n\x05\x06\x02\x02\0\x01\x12\x04\x86\x02\x06\x1f\n\r\n\
    \x05\x06\x02\x02\0\x02\x12\x04\x86\x02\x20<\n\r\n\x05\x06\x02\x02\0\x03\
    \x12\x04\x86\x02Gd\n<\n\x04\x06\x02\x02\x01\x12\x04\x88\x02\x02b\x1a.Lis\
    tJoinedConversations\x20\xe5\x88\x97\xe5\x87\xba\xe5\x8a\xa0\xe5\x85\xa5\
    \xe7\x9a\x84\xe4\xbc\x9a\xe8\xaf\x9d\n\n\r\n\x05\x06\x02\x02\x01\x01\x12\
    \x04\x88\x02\x06\x1d\n\r\n\x05\x06\x02\x02\x01\x02\x12\x04\x88\x02\x1e8\
    \n\r\n\x05\x06\x02\x02\x01\x03\x12\x04\x88\x02C^\n4\n\x02\x04\x16\x12\
    \x06\x8d\x02\0\x8f\x02\x012&SubscriptionSubscribe\x20\xe8\xae\xa2\xe9\
    \x98\x85\xe5\x8f\xb7\xe8\xae\xa2\xe9\x98\x85\n\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\x8d\x02\x08\x20\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x8e\x02\x02\
    \x1b\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x8e\x02\x02\x0f\n\r\n\x05\x04\
    \x16\x02\0\x01\x12\x04\x8e\x02\x10\x16\n\r\n\x05\x04\x16\x02\0\x03\x12\
    \x04\x8e\x02\x19\x1a\n\x0c\n\x02\x04\x17\x12\x06\x91\x02\0\x93\x02\x01\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\x91\x02\x08!\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\x92\x02\x02\x1c\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\x92\x02\x02\
    \x10\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x92\x02\x11\x17\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\x92\x02\x1a\x1b\nN\n\x02\x04\x18\x12\x06\x97\x02\
    \0\x99\x02\x012@SubscriptionAfterOnline\x20\xe8\xae\xa2\xe9\x98\x85\xe5\
    \x8f\xb7\xe5\x9c\xa8\xe5\x81\x9a\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8a\xe7\
    \xba\xbf\xe5\x90\x8e\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\n\n\x0b\n\x03\
    \x04\x18\x01\x12\x04\x97\x02\x08\"\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x98\
    \x02\x02\x1b\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x98\x02\x02\x0f\n\r\n\
    \x05\x04\x18\x02\0\x01\x12\x04\x98\x02\x10\x16\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\x98\x02\x19\x1a\n\x0c\n\x02\x04\x19\x12\x06\x9b\x02\0\x9d\
    \x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\x9b\x02\x08#\n\x0c\n\x04\x04\
    \x19\x02\0\x12\x04\x9c\x02\x02\x1c\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\
    \x9c\x02\x02\x10\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x9c\x02\x11\x17\n\r\
    \n\x05\x04\x19\x02\0\x03\x12\x04\x9c\x02\x1a\x1b\nO\n\x02\x04\x1a\x12\
    \x06\xa0\x02\0\xa3\x02\x01\x1aASubscriptionAfterOffline\x20\xe8\xae\xa2\
    \xe9\x98\x85\xe5\x8f\xb7\xe5\x9c\xa8\xe5\x81\x9a\xe7\x94\xa8\xe6\x88\xb7\
    \xe4\xb8\x8b\xe7\xba\xbf\xe5\x90\x8e\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\
    \n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xa0\x02\x08#\n\x0c\n\x04\x04\x1a\x02\
    \0\x12\x04\xa1\x02\x02\x1b\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xa1\x02\
    \x02\x0f\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xa1\x02\x10\x16\n\r\n\x05\
    \x04\x1a\x02\0\x03\x12\x04\xa1\x02\x19\x1a\n\x0c\n\x04\x04\x1a\x02\x01\
    \x12\x04\xa2\x02\x02\x14\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xa2\x02\
    \x02\x08\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xa2\x02\t\x0f\n\r\n\x05\
    \x04\x1a\x02\x01\x03\x12\x04\xa2\x02\x12\x13\n\x0c\n\x02\x04\x1b\x12\x06\
    \xa5\x02\0\xa7\x02\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xa5\x02\x08$\n\
    \x0c\n\x04\x04\x1b\x02\0\x12\x04\xa6\x02\x02\x1c\n\r\n\x05\x04\x1b\x02\0\
    \x06\x12\x04\xa6\x02\x02\x10\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xa6\x02\
    \x11\x17\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xa6\x02\x1a\x1b\n8\n\x02\
    \x04\x1c\x12\x06\xaa\x02\0\xaf\x02\x01\x1a*UserSubscription\x20\xe7\x94\
    \xa8\xe6\x88\xb7\xe8\xae\xa2\xe9\x98\x85\xe7\x9a\x84\xe8\xae\xa2\xe9\x98\
    \x85\xe5\x8f\xb7\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xaa\x02\x08\x18\n\x0c\
    \n\x04\x04\x1c\x02\0\x12\x04\xab\x02\x02\x1c\n\r\n\x05\x04\x1c\x02\0\x05\
    \x12\x04\xab\x02\x02\x08\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xab\x02\t\
    \x17\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xab\x02\x1a\x1b\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xac\x02\x02\x18\n\r\n\x05\x04\x1c\x02\x01\x05\x12\
    \x04\xac\x02\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xac\x02\t\x13\
    \n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xac\x02\x16\x17\n\x0c\n\x04\x04\
    \x1c\x02\x02\x12\x04\xad\x02\x02\x1a\n\r\n\x05\x04\x1c\x02\x02\x05\x12\
    \x04\xad\x02\x02\x07\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xad\x02\x08\
    \x15\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xad\x02\x18\x19\n\x0c\n\x04\
    \x04\x1c\x02\x03\x12\x04\xae\x02\x02#\n\r\n\x05\x04\x1c\x02\x03\x06\x12\
    \x04\xae\x02\x02\x15\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xae\x02\x16\
    \x1e\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xae\x02!\"\nD\n\x02\x04\x1d\
    \x12\x06\xb3\x02\0\xb8\x02\x0126UpsertUserSubscription\x20\xe6\x9b\xb4\
    \xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xa2\xe9\x98\x85\xe7\x9a\x84\
    \xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\
    \xb3\x02\x08!\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xb4\x02\x02\x1b\n\r\n\
    \x05\x04\x1d\x02\0\x06\x12\x04\xb4\x02\x02\x0f\n\r\n\x05\x04\x1d\x02\0\
    \x01\x12\x04\xb4\x02\x10\x16\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xb4\x02\
    \x19\x1a\n)\n\x04\x04\x1d\x02\x01\x12\x04\xb6\x02\x02\x1c\x1a\x1bSubscri\
    ptionId\x20\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7id\n\n\r\n\x05\x04\x1d\
    \x02\x01\x05\x12\x04\xb6\x02\x02\x08\n\r\n\x05\x04\x1d\x02\x01\x01\x12\
    \x04\xb6\x02\t\x17\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xb6\x02\x1a\x1b\
    \n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xb7\x02\x02(\n\r\n\x05\x04\x1d\x02\
    \x02\x06\x12\x04\xb7\x02\x02\x12\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\
    \xb7\x02\x13#\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xb7\x02&'\n\x0c\n\
    \x02\x04\x1e\x12\x06\xba\x02\0\xbc\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xba\x02\x08\"\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xbb\x02\x02\x1c\n\r\
    \n\x05\x04\x1e\x02\0\x06\x12\x04\xbb\x02\x02\x10\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\xbb\x02\x11\x17\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xbb\x02\
    \x1a\x1b\nD\n\x02\x04\x1f\x12\x06\xc0\x02\0\xc4\x02\x0126DeleteUserSubsc\
    ription\x20\xe5\x88\xa0\xe9\x99\xa4\xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xa2\
    \xe9\x98\x85\xe7\x9a\x84\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7\n\n\x0b\n\
    \x03\x04\x1f\x01\x12\x04\xc0\x02\x08!\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\
    \xc1\x02\x02\x1b\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xc1\x02\x02\x0f\n\r\
    \n\x05\x04\x1f\x02\0\x01\x12\x04\xc1\x02\x10\x16\n\r\n\x05\x04\x1f\x02\0\
    \x03\x12\x04\xc1\x02\x19\x1a\n)\n\x04\x04\x1f\x02\x01\x12\x04\xc3\x02\
    \x02\x1c\x1a\x1bSubscriptionId\x20\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7id\
    \n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xc3\x02\x02\x08\n\r\n\x05\x04\
    \x1f\x02\x01\x01\x12\x04\xc3\x02\t\x17\n\r\n\x05\x04\x1f\x02\x01\x03\x12\
    \x04\xc3\x02\x1a\x1b\n\x0c\n\x02\x04\x20\x12\x06\xc6\x02\0\xc8\x02\x01\n\
    \x0b\n\x03\x04\x20\x01\x12\x04\xc6\x02\x08\"\n\x0c\n\x04\x04\x20\x02\0\
    \x12\x04\xc7\x02\x02\x1c\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\xc7\x02\x02\
    \x10\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04\
    \x20\x02\0\x03\x12\x04\xc7\x02\x1a\x1b\nC\n\x02\x04!\x12\x06\xcc\x02\0\
    \xde\x02\x0125ListSubscriptionSubscribers\x20\xe5\x88\x97\xe5\x87\xba\
    \xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7\xe8\xae\xa2\xe9\x98\x85\xe8\x80\x85\
    \n\n\x0b\n\x03\x04!\x01\x12\x04\xcc\x02\x08&\n\x0c\n\x04\x04!\x02\0\x12\
    \x04\xcd\x02\x02\x1b\n\r\n\x05\x04!\x02\0\x06\x12\x04\xcd\x02\x02\x0f\n\
    \r\n\x05\x04!\x02\0\x01\x12\x04\xcd\x02\x10\x16\n\r\n\x05\x04!\x02\0\x03\
    \x12\x04\xcd\x02\x19\x1a\n)\n\x04\x04!\x02\x01\x12\x04\xcf\x02\x02\x1c\
    \x1a\x1bSubscriptionId\x20\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7id\n\n\r\n\
    \x05\x04!\x02\x01\x05\x12\x04\xcf\x02\x02\x08\n\r\n\x05\x04!\x02\x01\x01\
    \x12\x04\xcf\x02\t\x17\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xcf\x02\x1a\
    \x1b\n\x1c\n\x04\x04!\x02\x02\x12\x04\xd1\x02\x02\x13\x1a\x0eCursor\x20\
    \xe6\xb8\xb8\xe6\xa0\x87\n\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xd1\x02\
    \x02\x07\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xd1\x02\x08\x0e\n\r\n\x05\
    \x04!\x02\x02\x03\x12\x04\xd1\x02\x11\x12\n\x1b\n\x04\x04!\x02\x03\x12\
    \x04\xd3\x02\x02\x12\x1a\rLimit\x20\xe9\x99\x90\xe5\x88\xb6\n\n\r\n\x05\
    \x04!\x02\x03\x05\x12\x04\xd3\x02\x02\x07\n\r\n\x05\x04!\x02\x03\x01\x12\
    \x04\xd3\x02\x08\r\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xd3\x02\x10\x11\n!\
    \n\x04\x04!\x03\0\x12\x06\xd5\x02\x02\xd8\x02\x03\x1a\x11Filter\x20\xe8\
    \xbf\x87\xe6\xbb\xa4\xe5\x99\xa8\n\n\r\n\x05\x04!\x03\0\x01\x12\x04\xd5\
    \x02\n\x10\n:\n\x06\x04!\x03\0\x02\0\x12\x04\xd7\x02\x04\x1f\x1a*subscri\
    beTimeGte\x20\xe8\xae\xa2\xe9\x98\x85\xe6\x97\xb6\xe9\x97\xb4\xe5\xa4\
    \xa7\xe4\xba\x8e\xe7\xad\x89\xe4\xba\x8e\n\n\x0f\n\x07\x04!\x03\0\x02\0\
    \x05\x12\x04\xd7\x02\x04\t\n\x0f\n\x07\x04!\x03\0\x02\0\x01\x12\x04\xd7\
    \x02\n\x1a\n\x0f\n\x07\x04!\x03\0\x02\0\x03\x12\x04\xd7\x02\x1d\x1e\n\
    \x1e\n\x04\x04!\x03\x01\x12\x06\xda\x02\x02\xdb\x02\x03\x1a\x0eOption\
    \x20\xe9\x80\x89\xe9\xa1\xb9\n\n\r\n\x05\x04!\x03\x01\x01\x12\x04\xda\
    \x02\n\x10\n\x0c\n\x04\x04!\x02\x04\x12\x04\xdc\x02\x02\x14\n\r\n\x05\
    \x04!\x02\x04\x06\x12\x04\xdc\x02\x02\x08\n\r\n\x05\x04!\x02\x04\x01\x12\
    \x04\xdc\x02\t\x0f\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xdc\x02\x12\x13\n\
    \x0c\n\x04\x04!\x02\x05\x12\x04\xdd\x02\x02\x14\n\r\n\x05\x04!\x02\x05\
    \x06\x12\x04\xdd\x02\x02\x08\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xdd\x02\
    \t\x0f\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xdd\x02\x12\x13\n\x0c\n\x02\
    \x04\"\x12\x06\xe0\x02\0\xeb\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xe0\
    \x02\x08'\n\x0c\n\x04\x04\"\x02\0\x12\x04\xe1\x02\x02\x1c\n\r\n\x05\x04\
    \"\x02\0\x06\x12\x04\xe1\x02\x02\x10\n\r\n\x05\x04\"\x02\0\x01\x12\x04\
    \xe1\x02\x11\x17\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xe1\x02\x1a\x1b\n*\n\
    \x04\x04\"\x03\0\x12\x06\xe4\x02\x02\xe9\x02\x03\x1a\x1aCursor\x20\xe6\
    \xb8\xb8\xe6\xa0\x87\nList\x20\xe5\x88\x97\xe8\xa1\xa8\n\n\r\n\x05\x04\"\
    \x03\0\x01\x12\x04\xe4\x02\n\x14\n\x20\n\x06\x04\"\x03\0\x02\0\x12\x04\
    \xe6\x02\x04\x16\x1a\x10UserId\x20\xe7\x94\xa8\xe6\x88\xb7id\n\n\x0f\n\
    \x07\x04\"\x03\0\x02\0\x05\x12\x04\xe6\x02\x04\n\n\x0f\n\x07\x04\"\x03\0\
    \x02\0\x01\x12\x04\xe6\x02\x0b\x11\n\x0f\n\x07\x04\"\x03\0\x02\0\x03\x12\
    \x04\xe6\x02\x14\x15\n+\n\x06\x04\"\x03\0\x02\x01\x12\x04\xe8\x02\x04\
    \x1c\x1a\x1bSubscribeTime\x20\xe8\xae\xa2\xe9\x98\x85\xe6\x97\xb6\xe9\
    \x97\xb4\n\n\x0f\n\x07\x04\"\x03\0\x02\x01\x05\x12\x04\xe8\x02\x04\t\n\
    \x0f\n\x07\x04\"\x03\0\x02\x01\x01\x12\x04\xe8\x02\n\x17\n\x0f\n\x07\x04\
    \"\x03\0\x02\x01\x03\x12\x04\xe8\x02\x1a\x1b\n\x0c\n\x04\x04\"\x02\x01\
    \x12\x04\xea\x02\x02)\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xea\x02\x02\n\
    \n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xea\x02\x0b\x15\n\r\n\x05\x04\"\x02\
    \x01\x01\x12\x04\xea\x02\x16$\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xea\
    \x02'(\n\x0c\n\x02\x06\x03\x12\x06\xed\x02\0\xfa\x02\x01\n\x0b\n\x03\x06\
    \x03\x01\x12\x04\xed\x02\x08\x1b\n4\n\x04\x06\x03\x02\0\x12\x04\xef\x02\
    \x02\\\x1a&SubscriptionSubscribe\x20\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7\
    \xe8\xae\xa2\xe9\x98\x85\n\n\r\n\x05\x06\x03\x02\0\x01\x12\x04\xef\x02\
    \x06\x1b\n\r\n\x05\x06\x03\x02\0\x02\x12\x04\xef\x02\x1c4\n\r\n\x05\x06\
    \x03\x02\0\x03\x12\x04\xef\x02?X\nN\n\x04\x06\x03\x02\x01\x12\x04\xf1\
    \x02\x02b\x1a@SubscriptionAfterOnline\x20\xe8\xae\xa2\xe9\x98\x85\xe5\
    \x8f\xb7\xe5\x9c\xa8\xe5\x81\x9a\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8a\xe7\
    \xba\xbf\xe5\x90\x8e\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\n\n\r\n\x05\x06\
    \x03\x02\x01\x01\x12\x04\xf1\x02\x06\x1d\n\r\n\x05\x06\x03\x02\x01\x02\
    \x12\x04\xf1\x02\x1e8\n\r\n\x05\x06\x03\x02\x01\x03\x12\x04\xf1\x02C^\nO\
    \n\x04\x06\x03\x02\x02\x12\x04\xf3\x02\x02e\x1aASubscriptionAfterOffline\
    \x20\xe8\xae\xa2\xe9\x98\x85\xe5\x8f\xb7\xe5\x9c\xa8\xe5\x81\x9a\xe7\x94\
    \xa8\xe6\x88\xb7\xe4\xb8\x8b\xe7\xba\xbf\xe5\x90\x8e\xe7\x9a\x84\xe6\x93\
    \x8d\xe4\xbd\x9c\n\n\r\n\x05\x06\x03\x02\x02\x01\x12\x04\xf3\x02\x06\x1e\
    \n\r\n\x05\x06\x03\x02\x02\x02\x12\x04\xf3\x02\x1f:\n\r\n\x05\x06\x03\
    \x02\x02\x03\x12\x04\xf3\x02Ea\nD\n\x04\x06\x03\x02\x03\x12\x04\xf5\x02\
    \x02_\x1a6UpsertUserSubscription\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\
    \xe6\x88\xb7\xe8\xae\xa2\xe9\x98\x85\xe7\x9a\x84\xe8\xae\xa2\xe9\x98\x85\
    \xe5\x8f\xb7\n\n\r\n\x05\x06\x03\x02\x03\x01\x12\x04\xf5\x02\x06\x1c\n\r\
    \n\x05\x06\x03\x02\x03\x02\x12\x04\xf5\x02\x1d6\n\r\n\x05\x06\x03\x02\
    \x03\x03\x12\x04\xf5\x02A[\nD\n\x04\x06\x03\x02\x04\x12\x04\xf7\x02\x02_\
    \x1a6DeleteUserSubscription\x20\xe5\x88\xa0\xe9\x99\xa4\xe7\x94\xa8\xe6\
    \x88\xb7\xe8\xae\xa2\xe9\x98\x85\xe7\x9a\x84\xe8\xae\xa2\xe9\x98\x85\xe5\
    \x8f\xb7\n\n\r\n\x05\x06\x03\x02\x04\x01\x12\x04\xf7\x02\x06\x1c\n\r\n\
    \x05\x06\x03\x02\x04\x02\x12\x04\xf7\x02\x1d6\n\r\n\x05\x06\x03\x02\x04\
    \x03\x12\x04\xf7\x02A[\nC\n\x04\x06\x03\x02\x05\x12\x04\xf9\x02\x02n\x1a\
    5ListSubscriptionSubscribers\x20\xe5\x88\x97\xe5\x87\xba\xe8\xae\xa2\xe9\
    \x98\x85\xe5\x8f\xb7\xe8\xae\xa2\xe9\x98\x85\xe8\x80\x85\n\n\r\n\x05\x06\
    \x03\x02\x05\x01\x12\x04\xf9\x02\x06!\n\r\n\x05\x06\x03\x02\x05\x02\x12\
    \x04\xf9\x02\"@\n\r\n\x05\x06\x03\x02\x05\x03\x12\x04\xf9\x02Kjb\x06prot\
    o3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(49);
            messages.push(GroupCreateReq::generated_message_descriptor_data());
            messages.push(GroupCreateResp::generated_message_descriptor_data());
            messages.push(CountJoinGroupReq::generated_message_descriptor_data());
            messages.push(CountJoinGroupResp::generated_message_descriptor_data());
            messages.push(CountCreateGroupReq::generated_message_descriptor_data());
            messages.push(CountCreateGroupResp::generated_message_descriptor_data());
            messages.push(GroupSubscribeReq::generated_message_descriptor_data());
            messages.push(GroupSubscribeResp::generated_message_descriptor_data());
            messages.push(ListGroupSubscribersReq::generated_message_descriptor_data());
            messages.push(ListGroupSubscribersResp::generated_message_descriptor_data());
            messages.push(FriendApplyReq::generated_message_descriptor_data());
            messages.push(FriendApplyResp::generated_message_descriptor_data());
            messages.push(FriendApplyHandleReq::generated_message_descriptor_data());
            messages.push(FriendApplyHandleResp::generated_message_descriptor_data());
            messages.push(ListFriendApplyReq::generated_message_descriptor_data());
            messages.push(ListFriendApplyResp::generated_message_descriptor_data());
            messages.push(CountFriendReq::generated_message_descriptor_data());
            messages.push(CountFriendResp::generated_message_descriptor_data());
            messages.push(ConversationSettingUpdateReq::generated_message_descriptor_data());
            messages.push(ConversationSettingUpdateResp::generated_message_descriptor_data());
            messages.push(ListJoinedConversationsReq::generated_message_descriptor_data());
            messages.push(ListJoinedConversationsResp::generated_message_descriptor_data());
            messages.push(SubscriptionSubscribeReq::generated_message_descriptor_data());
            messages.push(SubscriptionSubscribeResp::generated_message_descriptor_data());
            messages.push(SubscriptionAfterOnlineReq::generated_message_descriptor_data());
            messages.push(SubscriptionAfterOnlineResp::generated_message_descriptor_data());
            messages.push(SubscriptionAfterOfflineReq::generated_message_descriptor_data());
            messages.push(SubscriptionAfterOfflineResp::generated_message_descriptor_data());
            messages.push(UserSubscription::generated_message_descriptor_data());
            messages.push(UpsertUserSubscriptionReq::generated_message_descriptor_data());
            messages.push(UpsertUserSubscriptionResp::generated_message_descriptor_data());
            messages.push(DeleteUserSubscriptionReq::generated_message_descriptor_data());
            messages.push(DeleteUserSubscriptionResp::generated_message_descriptor_data());
            messages.push(ListSubscriptionSubscribersReq::generated_message_descriptor_data());
            messages.push(ListSubscriptionSubscribersResp::generated_message_descriptor_data());
            messages.push(list_group_subscribers_req::Filter::generated_message_descriptor_data());
            messages.push(list_group_subscribers_req::Option::generated_message_descriptor_data());
            messages.push(list_group_subscribers_resp::Subscriber::generated_message_descriptor_data());
            messages.push(list_friend_apply_req::Filter::generated_message_descriptor_data());
            messages.push(list_friend_apply_req::Option::generated_message_descriptor_data());
            messages.push(list_friend_apply_resp::FriendApply::generated_message_descriptor_data());
            messages.push(list_joined_conversations_req::Filter::generated_message_descriptor_data());
            messages.push(list_joined_conversations_req::Option::generated_message_descriptor_data());
            messages.push(list_joined_conversations_req::filter::SettingKV::generated_message_descriptor_data());
            messages.push(list_joined_conversations_resp::Conversation::generated_message_descriptor_data());
            messages.push(list_joined_conversations_resp::conversation::SelfMemberInfo::generated_message_descriptor_data());
            messages.push(list_subscription_subscribers_req::Filter::generated_message_descriptor_data());
            messages.push(list_subscription_subscribers_req::Option::generated_message_descriptor_data());
            messages.push(list_subscription_subscribers_resp::Subscriber::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(FriendApplyStatus::generated_enum_descriptor_data());
            enums.push(list_joined_conversations_req::filter::setting_kv::Operator::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
