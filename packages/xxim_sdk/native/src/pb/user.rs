// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `user.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

/// UserRegisterReq 用户注册请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserRegisterReq)
pub struct UserRegisterReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserRegisterReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.registerTime)
    pub registerTime: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.avatar)
    pub avatar: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.accountMap)
    pub accountMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.profileMap)
    pub profileMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.extraMap)
    pub extraMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserRegisterReq.verifyMap)
    pub verifyMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserRegisterReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserRegisterReq {
    fn default() -> &'a UserRegisterReq {
        <UserRegisterReq as ::protobuf::Message>::default_instance()
    }
}

impl UserRegisterReq {
    pub fn new() -> UserRegisterReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserRegisterReq| { &m.header },
            |m: &mut UserRegisterReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserRegisterReq| { &m.userId },
            |m: &mut UserRegisterReq| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registerTime",
            |m: &UserRegisterReq| { &m.registerTime },
            |m: &mut UserRegisterReq| { &mut m.registerTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nickname",
            |m: &UserRegisterReq| { &m.nickname },
            |m: &mut UserRegisterReq| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar",
            |m: &UserRegisterReq| { &m.avatar },
            |m: &mut UserRegisterReq| { &mut m.avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "accountMap",
            |m: &UserRegisterReq| { &m.accountMap },
            |m: &mut UserRegisterReq| { &mut m.accountMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "profileMap",
            |m: &UserRegisterReq| { &m.profileMap },
            |m: &mut UserRegisterReq| { &mut m.profileMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extraMap",
            |m: &UserRegisterReq| { &m.extraMap },
            |m: &mut UserRegisterReq| { &mut m.extraMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "verifyMap",
            |m: &UserRegisterReq| { &m.verifyMap },
            |m: &mut UserRegisterReq| { &mut m.verifyMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserRegisterReq>(
            "UserRegisterReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserRegisterReq {
    const NAME: &'static str = "UserRegisterReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                24 => {
                    self.registerTime = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.avatar = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.accountMap.insert(key, value);
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.profileMap.insert(key, value);
                },
                66 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extraMap.insert(key, value);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.verifyMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if let Some(v) = self.registerTime {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if let Some(v) = self.registerTime {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.avatar.as_ref() {
            os.write_string(5, v)?;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(66)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserRegisterReq {
        UserRegisterReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.registerTime = ::std::option::Option::None;
        self.nickname = ::std::option::Option::None;
        self.avatar = ::std::option::Option::None;
        self.accountMap.clear();
        self.profileMap.clear();
        self.extraMap.clear();
        self.verifyMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserRegisterReq {
        static instance: ::protobuf::rt::Lazy<UserRegisterReq> = ::protobuf::rt::Lazy::new();
        instance.get(UserRegisterReq::new)
    }
}

impl ::protobuf::MessageFull for UserRegisterReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserRegisterReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserRegisterReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserRegisterReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserRegisterResp 用户注册响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserRegisterResp)
pub struct UserRegisterResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserRegisterResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserRegisterResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserRegisterResp {
    fn default() -> &'a UserRegisterResp {
        <UserRegisterResp as ::protobuf::Message>::default_instance()
    }
}

impl UserRegisterResp {
    pub fn new() -> UserRegisterResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserRegisterResp| { &m.header },
            |m: &mut UserRegisterResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserRegisterResp>(
            "UserRegisterResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserRegisterResp {
    const NAME: &'static str = "UserRegisterResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserRegisterResp {
        UserRegisterResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserRegisterResp {
        static instance: UserRegisterResp = UserRegisterResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserRegisterResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserRegisterResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserRegisterResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserRegisterResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserDestroyReq 用户注销请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserDestroyReq)
pub struct UserDestroyReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserDestroyReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UserDestroyReq.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserDestroyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserDestroyReq {
    fn default() -> &'a UserDestroyReq {
        <UserDestroyReq as ::protobuf::Message>::default_instance()
    }
}

impl UserDestroyReq {
    pub fn new() -> UserDestroyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserDestroyReq| { &m.header },
            |m: &mut UserDestroyReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserDestroyReq| { &m.userId },
            |m: &mut UserDestroyReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDestroyReq>(
            "UserDestroyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserDestroyReq {
    const NAME: &'static str = "UserDestroyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserDestroyReq {
        UserDestroyReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserDestroyReq {
        static instance: UserDestroyReq = UserDestroyReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserDestroyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserDestroyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserDestroyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDestroyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserDestroyResp 用户注销响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserDestroyResp)
pub struct UserDestroyResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserDestroyResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserDestroyResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserDestroyResp {
    fn default() -> &'a UserDestroyResp {
        <UserDestroyResp as ::protobuf::Message>::default_instance()
    }
}

impl UserDestroyResp {
    pub fn new() -> UserDestroyResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserDestroyResp| { &m.header },
            |m: &mut UserDestroyResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDestroyResp>(
            "UserDestroyResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserDestroyResp {
    const NAME: &'static str = "UserDestroyResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserDestroyResp {
        UserDestroyResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserDestroyResp {
        static instance: UserDestroyResp = UserDestroyResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserDestroyResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserDestroyResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserDestroyResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDestroyResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAccessTokenReq 用户登录请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAccessTokenReq)
pub struct UserAccessTokenReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAccessTokenReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UserAccessTokenReq.accountMap)
    pub accountMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserAccessTokenReq.verifyMap)
    pub verifyMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.UserAccessTokenReq.expireTime)
    pub expireTime: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAccessTokenReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAccessTokenReq {
    fn default() -> &'a UserAccessTokenReq {
        <UserAccessTokenReq as ::protobuf::Message>::default_instance()
    }
}

impl UserAccessTokenReq {
    pub fn new() -> UserAccessTokenReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserAccessTokenReq| { &m.header },
            |m: &mut UserAccessTokenReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "accountMap",
            |m: &UserAccessTokenReq| { &m.accountMap },
            |m: &mut UserAccessTokenReq| { &mut m.accountMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "verifyMap",
            |m: &UserAccessTokenReq| { &m.verifyMap },
            |m: &mut UserAccessTokenReq| { &mut m.verifyMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expireTime",
            |m: &UserAccessTokenReq| { &m.expireTime },
            |m: &mut UserAccessTokenReq| { &mut m.expireTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAccessTokenReq>(
            "UserAccessTokenReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAccessTokenReq {
    const NAME: &'static str = "UserAccessTokenReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.accountMap.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.verifyMap.insert(key, value);
                },
                32 => {
                    self.expireTime = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.expireTime {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.expireTime {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAccessTokenReq {
        UserAccessTokenReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.accountMap.clear();
        self.verifyMap.clear();
        self.expireTime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAccessTokenReq {
        static instance: ::protobuf::rt::Lazy<UserAccessTokenReq> = ::protobuf::rt::Lazy::new();
        instance.get(UserAccessTokenReq::new)
    }
}

impl ::protobuf::MessageFull for UserAccessTokenReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAccessTokenReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAccessTokenReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAccessTokenReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAccessTokenResp 用户登录响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAccessTokenResp)
pub struct UserAccessTokenResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAccessTokenResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.UserAccessTokenResp.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UserAccessTokenResp.accessToken)
    pub accessToken: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAccessTokenResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAccessTokenResp {
    fn default() -> &'a UserAccessTokenResp {
        <UserAccessTokenResp as ::protobuf::Message>::default_instance()
    }
}

impl UserAccessTokenResp {
    pub fn new() -> UserAccessTokenResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserAccessTokenResp| { &m.header },
            |m: &mut UserAccessTokenResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserAccessTokenResp| { &m.userId },
            |m: &mut UserAccessTokenResp| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accessToken",
            |m: &UserAccessTokenResp| { &m.accessToken },
            |m: &mut UserAccessTokenResp| { &mut m.accessToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAccessTokenResp>(
            "UserAccessTokenResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAccessTokenResp {
    const NAME: &'static str = "UserAccessTokenResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                26 => {
                    self.accessToken = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if !self.accessToken.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.accessToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if !self.accessToken.is_empty() {
            os.write_string(3, &self.accessToken)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAccessTokenResp {
        UserAccessTokenResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.accessToken.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAccessTokenResp {
        static instance: UserAccessTokenResp = UserAccessTokenResp {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            accessToken: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAccessTokenResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAccessTokenResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAccessTokenResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAccessTokenResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// RefreshUserAccessTokenReq 刷新用户token请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.RefreshUserAccessTokenReq)
pub struct RefreshUserAccessTokenReq {
    // message fields
    // @@protoc_insertion_point(field:pb.RefreshUserAccessTokenReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.RefreshUserAccessTokenReq.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.RefreshUserAccessTokenReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RefreshUserAccessTokenReq {
    fn default() -> &'a RefreshUserAccessTokenReq {
        <RefreshUserAccessTokenReq as ::protobuf::Message>::default_instance()
    }
}

impl RefreshUserAccessTokenReq {
    pub fn new() -> RefreshUserAccessTokenReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &RefreshUserAccessTokenReq| { &m.header },
            |m: &mut RefreshUserAccessTokenReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &RefreshUserAccessTokenReq| { &m.userId },
            |m: &mut RefreshUserAccessTokenReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefreshUserAccessTokenReq>(
            "RefreshUserAccessTokenReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RefreshUserAccessTokenReq {
    const NAME: &'static str = "RefreshUserAccessTokenReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RefreshUserAccessTokenReq {
        RefreshUserAccessTokenReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RefreshUserAccessTokenReq {
        static instance: RefreshUserAccessTokenReq = RefreshUserAccessTokenReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RefreshUserAccessTokenReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RefreshUserAccessTokenReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RefreshUserAccessTokenReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshUserAccessTokenReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// RefreshUserAccessTokenResp 刷新用户token响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.RefreshUserAccessTokenResp)
pub struct RefreshUserAccessTokenResp {
    // message fields
    // @@protoc_insertion_point(field:pb.RefreshUserAccessTokenResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.RefreshUserAccessTokenResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RefreshUserAccessTokenResp {
    fn default() -> &'a RefreshUserAccessTokenResp {
        <RefreshUserAccessTokenResp as ::protobuf::Message>::default_instance()
    }
}

impl RefreshUserAccessTokenResp {
    pub fn new() -> RefreshUserAccessTokenResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &RefreshUserAccessTokenResp| { &m.header },
            |m: &mut RefreshUserAccessTokenResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefreshUserAccessTokenResp>(
            "RefreshUserAccessTokenResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RefreshUserAccessTokenResp {
    const NAME: &'static str = "RefreshUserAccessTokenResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RefreshUserAccessTokenResp {
        RefreshUserAccessTokenResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RefreshUserAccessTokenResp {
        static instance: RefreshUserAccessTokenResp = RefreshUserAccessTokenResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RefreshUserAccessTokenResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RefreshUserAccessTokenResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RefreshUserAccessTokenResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshUserAccessTokenResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// RevokeUserAccessTokenReq 注销用户token
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.RevokeUserAccessTokenReq)
pub struct RevokeUserAccessTokenReq {
    // message fields
    // @@protoc_insertion_point(field:pb.RevokeUserAccessTokenReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.RevokeUserAccessTokenReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RevokeUserAccessTokenReq {
    fn default() -> &'a RevokeUserAccessTokenReq {
        <RevokeUserAccessTokenReq as ::protobuf::Message>::default_instance()
    }
}

impl RevokeUserAccessTokenReq {
    pub fn new() -> RevokeUserAccessTokenReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &RevokeUserAccessTokenReq| { &m.header },
            |m: &mut RevokeUserAccessTokenReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RevokeUserAccessTokenReq>(
            "RevokeUserAccessTokenReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RevokeUserAccessTokenReq {
    const NAME: &'static str = "RevokeUserAccessTokenReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RevokeUserAccessTokenReq {
        RevokeUserAccessTokenReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RevokeUserAccessTokenReq {
        static instance: RevokeUserAccessTokenReq = RevokeUserAccessTokenReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RevokeUserAccessTokenReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RevokeUserAccessTokenReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RevokeUserAccessTokenReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevokeUserAccessTokenReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// RevokeUserAccessTokenResp 注销用户token
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.RevokeUserAccessTokenResp)
pub struct RevokeUserAccessTokenResp {
    // message fields
    // @@protoc_insertion_point(field:pb.RevokeUserAccessTokenResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.RevokeUserAccessTokenResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RevokeUserAccessTokenResp {
    fn default() -> &'a RevokeUserAccessTokenResp {
        <RevokeUserAccessTokenResp as ::protobuf::Message>::default_instance()
    }
}

impl RevokeUserAccessTokenResp {
    pub fn new() -> RevokeUserAccessTokenResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &RevokeUserAccessTokenResp| { &m.header },
            |m: &mut RevokeUserAccessTokenResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RevokeUserAccessTokenResp>(
            "RevokeUserAccessTokenResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RevokeUserAccessTokenResp {
    const NAME: &'static str = "RevokeUserAccessTokenResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RevokeUserAccessTokenResp {
        RevokeUserAccessTokenResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RevokeUserAccessTokenResp {
        static instance: RevokeUserAccessTokenResp = RevokeUserAccessTokenResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RevokeUserAccessTokenResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RevokeUserAccessTokenResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RevokeUserAccessTokenResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevokeUserAccessTokenResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserAccountMapReq 更新用户账号信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserAccountMapReq)
pub struct UpdateUserAccountMapReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserAccountMapReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UpdateUserAccountMapReq.accountMap)
    pub accountMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.UpdateUserAccountMapReq.verifyMap)
    pub verifyMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserAccountMapReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserAccountMapReq {
    fn default() -> &'a UpdateUserAccountMapReq {
        <UpdateUserAccountMapReq as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserAccountMapReq {
    pub fn new() -> UpdateUserAccountMapReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UpdateUserAccountMapReq| { &m.header },
            |m: &mut UpdateUserAccountMapReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "accountMap",
            |m: &UpdateUserAccountMapReq| { &m.accountMap },
            |m: &mut UpdateUserAccountMapReq| { &mut m.accountMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "verifyMap",
            |m: &UpdateUserAccountMapReq| { &m.verifyMap },
            |m: &mut UpdateUserAccountMapReq| { &mut m.verifyMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserAccountMapReq>(
            "UpdateUserAccountMapReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserAccountMapReq {
    const NAME: &'static str = "UpdateUserAccountMapReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.accountMap.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.verifyMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserAccountMapReq {
        UpdateUserAccountMapReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.accountMap.clear();
        self.verifyMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserAccountMapReq {
        static instance: ::protobuf::rt::Lazy<UpdateUserAccountMapReq> = ::protobuf::rt::Lazy::new();
        instance.get(UpdateUserAccountMapReq::new)
    }
}

impl ::protobuf::MessageFull for UpdateUserAccountMapReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserAccountMapReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserAccountMapReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserAccountMapReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserAccountMapResp 更新用户账号信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserAccountMapResp)
pub struct UpdateUserAccountMapResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserAccountMapResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserAccountMapResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserAccountMapResp {
    fn default() -> &'a UpdateUserAccountMapResp {
        <UpdateUserAccountMapResp as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserAccountMapResp {
    pub fn new() -> UpdateUserAccountMapResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UpdateUserAccountMapResp| { &m.header },
            |m: &mut UpdateUserAccountMapResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserAccountMapResp>(
            "UpdateUserAccountMapResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserAccountMapResp {
    const NAME: &'static str = "UpdateUserAccountMapResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserAccountMapResp {
        UpdateUserAccountMapResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserAccountMapResp {
        static instance: UpdateUserAccountMapResp = UpdateUserAccountMapResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUserAccountMapResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserAccountMapResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserAccountMapResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserAccountMapResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserProfileMapReq 更新用户个人信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserProfileMapReq)
pub struct UpdateUserProfileMapReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserProfileMapReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UpdateUserProfileMapReq.profileMap)
    pub profileMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserProfileMapReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserProfileMapReq {
    fn default() -> &'a UpdateUserProfileMapReq {
        <UpdateUserProfileMapReq as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserProfileMapReq {
    pub fn new() -> UpdateUserProfileMapReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UpdateUserProfileMapReq| { &m.header },
            |m: &mut UpdateUserProfileMapReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "profileMap",
            |m: &UpdateUserProfileMapReq| { &m.profileMap },
            |m: &mut UpdateUserProfileMapReq| { &mut m.profileMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserProfileMapReq>(
            "UpdateUserProfileMapReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserProfileMapReq {
    const NAME: &'static str = "UpdateUserProfileMapReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.profileMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserProfileMapReq {
        UpdateUserProfileMapReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.profileMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserProfileMapReq {
        static instance: ::protobuf::rt::Lazy<UpdateUserProfileMapReq> = ::protobuf::rt::Lazy::new();
        instance.get(UpdateUserProfileMapReq::new)
    }
}

impl ::protobuf::MessageFull for UpdateUserProfileMapReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserProfileMapReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserProfileMapReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserProfileMapReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserProfileMapResp 更新用户个人信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserProfileMapResp)
pub struct UpdateUserProfileMapResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserProfileMapResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserProfileMapResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserProfileMapResp {
    fn default() -> &'a UpdateUserProfileMapResp {
        <UpdateUserProfileMapResp as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserProfileMapResp {
    pub fn new() -> UpdateUserProfileMapResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UpdateUserProfileMapResp| { &m.header },
            |m: &mut UpdateUserProfileMapResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserProfileMapResp>(
            "UpdateUserProfileMapResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserProfileMapResp {
    const NAME: &'static str = "UpdateUserProfileMapResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserProfileMapResp {
        UpdateUserProfileMapResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserProfileMapResp {
        static instance: UpdateUserProfileMapResp = UpdateUserProfileMapResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUserProfileMapResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserProfileMapResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserProfileMapResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserProfileMapResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserExtraMapReq 更新用户扩展信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserExtraMapReq)
pub struct UpdateUserExtraMapReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserExtraMapReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UpdateUserExtraMapReq.extraMap)
    pub extraMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserExtraMapReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserExtraMapReq {
    fn default() -> &'a UpdateUserExtraMapReq {
        <UpdateUserExtraMapReq as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserExtraMapReq {
    pub fn new() -> UpdateUserExtraMapReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UpdateUserExtraMapReq| { &m.header },
            |m: &mut UpdateUserExtraMapReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extraMap",
            |m: &UpdateUserExtraMapReq| { &m.extraMap },
            |m: &mut UpdateUserExtraMapReq| { &mut m.extraMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserExtraMapReq>(
            "UpdateUserExtraMapReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserExtraMapReq {
    const NAME: &'static str = "UpdateUserExtraMapReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extraMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserExtraMapReq {
        UpdateUserExtraMapReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.extraMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserExtraMapReq {
        static instance: ::protobuf::rt::Lazy<UpdateUserExtraMapReq> = ::protobuf::rt::Lazy::new();
        instance.get(UpdateUserExtraMapReq::new)
    }
}

impl ::protobuf::MessageFull for UpdateUserExtraMapReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserExtraMapReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserExtraMapReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserExtraMapReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserExtraMapResp 更新用户扩展信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserExtraMapResp)
pub struct UpdateUserExtraMapResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserExtraMapResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserExtraMapResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserExtraMapResp {
    fn default() -> &'a UpdateUserExtraMapResp {
        <UpdateUserExtraMapResp as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserExtraMapResp {
    pub fn new() -> UpdateUserExtraMapResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UpdateUserExtraMapResp| { &m.header },
            |m: &mut UpdateUserExtraMapResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserExtraMapResp>(
            "UpdateUserExtraMapResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserExtraMapResp {
    const NAME: &'static str = "UpdateUserExtraMapResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserExtraMapResp {
        UpdateUserExtraMapResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserExtraMapResp {
        static instance: UpdateUserExtraMapResp = UpdateUserExtraMapResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUserExtraMapResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserExtraMapResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserExtraMapResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserExtraMapResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UpdateUserCountMapReq 更新用户计数信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserCountMapReq)
pub struct UpdateUserCountMapReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserCountMapReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UpdateUserCountMapReq.countType)
    pub countType: ::protobuf::EnumOrUnknown<update_user_count_map_req::CountType>,
    // @@protoc_insertion_point(field:pb.UpdateUserCountMapReq.algorithm)
    pub algorithm: ::protobuf::EnumOrUnknown<update_user_count_map_req::Algorithm>,
    // @@protoc_insertion_point(field:pb.UpdateUserCountMapReq.count)
    pub count: i64,
    /// 是否统计 统计后同步到数据库
    // @@protoc_insertion_point(field:pb.UpdateUserCountMapReq.statistics)
    pub statistics: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserCountMapReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserCountMapReq {
    fn default() -> &'a UpdateUserCountMapReq {
        <UpdateUserCountMapReq as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserCountMapReq {
    pub fn new() -> UpdateUserCountMapReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UpdateUserCountMapReq| { &m.header },
            |m: &mut UpdateUserCountMapReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "countType",
            |m: &UpdateUserCountMapReq| { &m.countType },
            |m: &mut UpdateUserCountMapReq| { &mut m.countType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "algorithm",
            |m: &UpdateUserCountMapReq| { &m.algorithm },
            |m: &mut UpdateUserCountMapReq| { &mut m.algorithm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &UpdateUserCountMapReq| { &m.count },
            |m: &mut UpdateUserCountMapReq| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "statistics",
            |m: &UpdateUserCountMapReq| { &m.statistics },
            |m: &mut UpdateUserCountMapReq| { &mut m.statistics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserCountMapReq>(
            "UpdateUserCountMapReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserCountMapReq {
    const NAME: &'static str = "UpdateUserCountMapReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.countType = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.algorithm = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.count = is.read_int64()?;
                },
                40 => {
                    self.statistics = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.countType != ::protobuf::EnumOrUnknown::new(update_user_count_map_req::CountType::friendCount) {
            my_size += ::protobuf::rt::int32_size(2, self.countType.value());
        }
        if self.algorithm != ::protobuf::EnumOrUnknown::new(update_user_count_map_req::Algorithm::add) {
            my_size += ::protobuf::rt::int32_size(3, self.algorithm.value());
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.count);
        }
        if self.statistics != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.countType != ::protobuf::EnumOrUnknown::new(update_user_count_map_req::CountType::friendCount) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.countType))?;
        }
        if self.algorithm != ::protobuf::EnumOrUnknown::new(update_user_count_map_req::Algorithm::add) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.algorithm))?;
        }
        if self.count != 0 {
            os.write_int64(4, self.count)?;
        }
        if self.statistics != false {
            os.write_bool(5, self.statistics)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserCountMapReq {
        UpdateUserCountMapReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.countType = ::protobuf::EnumOrUnknown::new(update_user_count_map_req::CountType::friendCount);
        self.algorithm = ::protobuf::EnumOrUnknown::new(update_user_count_map_req::Algorithm::add);
        self.count = 0;
        self.statistics = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserCountMapReq {
        static instance: UpdateUserCountMapReq = UpdateUserCountMapReq {
            header: ::protobuf::MessageField::none(),
            countType: ::protobuf::EnumOrUnknown::from_i32(0),
            algorithm: ::protobuf::EnumOrUnknown::from_i32(0),
            count: 0,
            statistics: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUserCountMapReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserCountMapReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserCountMapReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserCountMapReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UpdateUserCountMapReq`
pub mod update_user_count_map_req {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:pb.UpdateUserCountMapReq.CountType)
    pub enum CountType {
        // @@protoc_insertion_point(enum_value:pb.UpdateUserCountMapReq.CountType.friendCount)
        friendCount = 0,
        // @@protoc_insertion_point(enum_value:pb.UpdateUserCountMapReq.CountType.joinGroupCount)
        joinGroupCount = 1,
        // @@protoc_insertion_point(enum_value:pb.UpdateUserCountMapReq.CountType.createGroupCount)
        createGroupCount = 2,
    }

    impl ::protobuf::Enum for CountType {
        const NAME: &'static str = "CountType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CountType> {
            match value {
                0 => ::std::option::Option::Some(CountType::friendCount),
                1 => ::std::option::Option::Some(CountType::joinGroupCount),
                2 => ::std::option::Option::Some(CountType::createGroupCount),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CountType] = &[
            CountType::friendCount,
            CountType::joinGroupCount,
            CountType::createGroupCount,
        ];
    }

    impl ::protobuf::EnumFull for CountType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("UpdateUserCountMapReq.CountType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CountType {
        fn default() -> Self {
            CountType::friendCount
        }
    }

    impl CountType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CountType>("UpdateUserCountMapReq.CountType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:pb.UpdateUserCountMapReq.Algorithm)
    pub enum Algorithm {
        // @@protoc_insertion_point(enum_value:pb.UpdateUserCountMapReq.Algorithm.add)
        add = 0,
        // @@protoc_insertion_point(enum_value:pb.UpdateUserCountMapReq.Algorithm.sub)
        sub = 1,
        // @@protoc_insertion_point(enum_value:pb.UpdateUserCountMapReq.Algorithm.fixed)
        fixed = 2,
    }

    impl ::protobuf::Enum for Algorithm {
        const NAME: &'static str = "Algorithm";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Algorithm> {
            match value {
                0 => ::std::option::Option::Some(Algorithm::add),
                1 => ::std::option::Option::Some(Algorithm::sub),
                2 => ::std::option::Option::Some(Algorithm::fixed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Algorithm] = &[
            Algorithm::add,
            Algorithm::sub,
            Algorithm::fixed,
        ];
    }

    impl ::protobuf::EnumFull for Algorithm {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("UpdateUserCountMapReq.Algorithm").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Algorithm {
        fn default() -> Self {
            Algorithm::add
        }
    }

    impl Algorithm {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Algorithm>("UpdateUserCountMapReq.Algorithm")
        }
    }
}

/// UpdateUserCountMapResp 更新用户计数信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UpdateUserCountMapResp)
pub struct UpdateUserCountMapResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UpdateUserCountMapResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UpdateUserCountMapResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateUserCountMapResp {
    fn default() -> &'a UpdateUserCountMapResp {
        <UpdateUserCountMapResp as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserCountMapResp {
    pub fn new() -> UpdateUserCountMapResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UpdateUserCountMapResp| { &m.header },
            |m: &mut UpdateUserCountMapResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateUserCountMapResp>(
            "UpdateUserCountMapResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateUserCountMapResp {
    const NAME: &'static str = "UpdateUserCountMapResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateUserCountMapResp {
        UpdateUserCountMapResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateUserCountMapResp {
        static instance: UpdateUserCountMapResp = UpdateUserCountMapResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateUserCountMapResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateUserCountMapResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateUserCountMapResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserCountMapResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetSelfUserInfoReq 获取自己的用户信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetSelfUserInfoReq)
pub struct GetSelfUserInfoReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetSelfUserInfoReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSelfUserInfoReq {
    fn default() -> &'a GetSelfUserInfoReq {
        <GetSelfUserInfoReq as ::protobuf::Message>::default_instance()
    }
}

impl GetSelfUserInfoReq {
    pub fn new() -> GetSelfUserInfoReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GetSelfUserInfoReq| { &m.header },
            |m: &mut GetSelfUserInfoReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSelfUserInfoReq>(
            "GetSelfUserInfoReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSelfUserInfoReq {
    const NAME: &'static str = "GetSelfUserInfoReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSelfUserInfoReq {
        GetSelfUserInfoReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSelfUserInfoReq {
        static instance: GetSelfUserInfoReq = GetSelfUserInfoReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSelfUserInfoReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSelfUserInfoReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSelfUserInfoReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSelfUserInfoReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetSelfUserInfoResp 获取自己的用户信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetSelfUserInfoResp)
pub struct GetSelfUserInfoResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.registerTime)
    pub registerTime: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.avatar)
    pub avatar: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.accountMap)
    pub accountMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.profileMap)
    pub profileMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetSelfUserInfoResp.extraMap)
    pub extraMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetSelfUserInfoResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSelfUserInfoResp {
    fn default() -> &'a GetSelfUserInfoResp {
        <GetSelfUserInfoResp as ::protobuf::Message>::default_instance()
    }
}

impl GetSelfUserInfoResp {
    pub fn new() -> GetSelfUserInfoResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GetSelfUserInfoResp| { &m.header },
            |m: &mut GetSelfUserInfoResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &GetSelfUserInfoResp| { &m.userId },
            |m: &mut GetSelfUserInfoResp| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registerTime",
            |m: &GetSelfUserInfoResp| { &m.registerTime },
            |m: &mut GetSelfUserInfoResp| { &mut m.registerTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nickname",
            |m: &GetSelfUserInfoResp| { &m.nickname },
            |m: &mut GetSelfUserInfoResp| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar",
            |m: &GetSelfUserInfoResp| { &m.avatar },
            |m: &mut GetSelfUserInfoResp| { &mut m.avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "accountMap",
            |m: &GetSelfUserInfoResp| { &m.accountMap },
            |m: &mut GetSelfUserInfoResp| { &mut m.accountMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "profileMap",
            |m: &GetSelfUserInfoResp| { &m.profileMap },
            |m: &mut GetSelfUserInfoResp| { &mut m.profileMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extraMap",
            |m: &GetSelfUserInfoResp| { &m.extraMap },
            |m: &mut GetSelfUserInfoResp| { &mut m.extraMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSelfUserInfoResp>(
            "GetSelfUserInfoResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSelfUserInfoResp {
    const NAME: &'static str = "GetSelfUserInfoResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                24 => {
                    self.registerTime = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.avatar = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.accountMap.insert(key, value);
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.profileMap.insert(key, value);
                },
                66 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extraMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if let Some(v) = self.registerTime {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if let Some(v) = self.registerTime {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.avatar.as_ref() {
            os.write_string(5, v)?;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.extraMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(66)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSelfUserInfoResp {
        GetSelfUserInfoResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.registerTime = ::std::option::Option::None;
        self.nickname = ::std::option::Option::None;
        self.avatar = ::std::option::Option::None;
        self.accountMap.clear();
        self.profileMap.clear();
        self.extraMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSelfUserInfoResp {
        static instance: ::protobuf::rt::Lazy<GetSelfUserInfoResp> = ::protobuf::rt::Lazy::new();
        instance.get(GetSelfUserInfoResp::new)
    }
}

impl ::protobuf::MessageFull for GetSelfUserInfoResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSelfUserInfoResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSelfUserInfoResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSelfUserInfoResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetUserInfoReq 获取用户信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetUserInfoReq)
pub struct GetUserInfoReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GetUserInfoReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GetUserInfoReq.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetUserInfoReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserInfoReq {
    fn default() -> &'a GetUserInfoReq {
        <GetUserInfoReq as ::protobuf::Message>::default_instance()
    }
}

impl GetUserInfoReq {
    pub fn new() -> GetUserInfoReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GetUserInfoReq| { &m.header },
            |m: &mut GetUserInfoReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &GetUserInfoReq| { &m.userId },
            |m: &mut GetUserInfoReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserInfoReq>(
            "GetUserInfoReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserInfoReq {
    const NAME: &'static str = "GetUserInfoReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserInfoReq {
        GetUserInfoReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserInfoReq {
        static instance: GetUserInfoReq = GetUserInfoReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserInfoReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserInfoReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserInfoReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserInfoReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetUserInfoResp 获取用户信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetUserInfoResp)
pub struct GetUserInfoResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GetUserInfoResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GetUserInfoResp.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GetUserInfoResp.registerTime)
    pub registerTime: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pb.GetUserInfoResp.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetUserInfoResp.avatar)
    pub avatar: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetUserInfoResp.profileMap)
    pub profileMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetUserInfoResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserInfoResp {
    fn default() -> &'a GetUserInfoResp {
        <GetUserInfoResp as ::protobuf::Message>::default_instance()
    }
}

impl GetUserInfoResp {
    pub fn new() -> GetUserInfoResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GetUserInfoResp| { &m.header },
            |m: &mut GetUserInfoResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &GetUserInfoResp| { &m.userId },
            |m: &mut GetUserInfoResp| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registerTime",
            |m: &GetUserInfoResp| { &m.registerTime },
            |m: &mut GetUserInfoResp| { &mut m.registerTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nickname",
            |m: &GetUserInfoResp| { &m.nickname },
            |m: &mut GetUserInfoResp| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar",
            |m: &GetUserInfoResp| { &m.avatar },
            |m: &mut GetUserInfoResp| { &mut m.avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "profileMap",
            |m: &GetUserInfoResp| { &m.profileMap },
            |m: &mut GetUserInfoResp| { &mut m.profileMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserInfoResp>(
            "GetUserInfoResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserInfoResp {
    const NAME: &'static str = "GetUserInfoResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                24 => {
                    self.registerTime = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.avatar = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.profileMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if let Some(v) = self.registerTime {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if let Some(v) = self.registerTime {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.avatar.as_ref() {
            os.write_string(5, v)?;
        }
        for (k, v) in &self.profileMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserInfoResp {
        GetUserInfoResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.registerTime = ::std::option::Option::None;
        self.nickname = ::std::option::Option::None;
        self.avatar = ::std::option::Option::None;
        self.profileMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserInfoResp {
        static instance: ::protobuf::rt::Lazy<GetUserInfoResp> = ::protobuf::rt::Lazy::new();
        instance.get(GetUserInfoResp::new)
    }
}

impl ::protobuf::MessageFull for GetUserInfoResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserInfoResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserInfoResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserInfoResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// ResetUserAccountMapReq 重置用户账号信息请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ResetUserAccountMapReq)
pub struct ResetUserAccountMapReq {
    // message fields
    // @@protoc_insertion_point(field:pb.ResetUserAccountMapReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.ResetUserAccountMapReq.accountMap)
    pub accountMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pb.ResetUserAccountMapReq.verifyMap)
    pub verifyMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ResetUserAccountMapReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetUserAccountMapReq {
    fn default() -> &'a ResetUserAccountMapReq {
        <ResetUserAccountMapReq as ::protobuf::Message>::default_instance()
    }
}

impl ResetUserAccountMapReq {
    pub fn new() -> ResetUserAccountMapReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &ResetUserAccountMapReq| { &m.header },
            |m: &mut ResetUserAccountMapReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "accountMap",
            |m: &ResetUserAccountMapReq| { &m.accountMap },
            |m: &mut ResetUserAccountMapReq| { &mut m.accountMap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "verifyMap",
            |m: &ResetUserAccountMapReq| { &m.verifyMap },
            |m: &mut ResetUserAccountMapReq| { &mut m.verifyMap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResetUserAccountMapReq>(
            "ResetUserAccountMapReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResetUserAccountMapReq {
    const NAME: &'static str = "ResetUserAccountMapReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.accountMap.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.verifyMap.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.accountMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.verifyMap {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetUserAccountMapReq {
        ResetUserAccountMapReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.accountMap.clear();
        self.verifyMap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetUserAccountMapReq {
        static instance: ::protobuf::rt::Lazy<ResetUserAccountMapReq> = ::protobuf::rt::Lazy::new();
        instance.get(ResetUserAccountMapReq::new)
    }
}

impl ::protobuf::MessageFull for ResetUserAccountMapReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResetUserAccountMapReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResetUserAccountMapReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetUserAccountMapReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// ResetUserAccountMapResp 重置用户账号信息响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.ResetUserAccountMapResp)
pub struct ResetUserAccountMapResp {
    // message fields
    // @@protoc_insertion_point(field:pb.ResetUserAccountMapResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.ResetUserAccountMapResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetUserAccountMapResp {
    fn default() -> &'a ResetUserAccountMapResp {
        <ResetUserAccountMapResp as ::protobuf::Message>::default_instance()
    }
}

impl ResetUserAccountMapResp {
    pub fn new() -> ResetUserAccountMapResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &ResetUserAccountMapResp| { &m.header },
            |m: &mut ResetUserAccountMapResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResetUserAccountMapResp>(
            "ResetUserAccountMapResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResetUserAccountMapResp {
    const NAME: &'static str = "ResetUserAccountMapResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetUserAccountMapResp {
        ResetUserAccountMapResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetUserAccountMapResp {
        static instance: ResetUserAccountMapResp = ResetUserAccountMapResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResetUserAccountMapResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResetUserAccountMapResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResetUserAccountMapResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetUserAccountMapResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAfterOnlineReq 用户上线回调请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAfterOnlineReq)
pub struct UserAfterOnlineReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAfterOnlineReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAfterOnlineReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAfterOnlineReq {
    fn default() -> &'a UserAfterOnlineReq {
        <UserAfterOnlineReq as ::protobuf::Message>::default_instance()
    }
}

impl UserAfterOnlineReq {
    pub fn new() -> UserAfterOnlineReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserAfterOnlineReq| { &m.header },
            |m: &mut UserAfterOnlineReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAfterOnlineReq>(
            "UserAfterOnlineReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAfterOnlineReq {
    const NAME: &'static str = "UserAfterOnlineReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAfterOnlineReq {
        UserAfterOnlineReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAfterOnlineReq {
        static instance: UserAfterOnlineReq = UserAfterOnlineReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAfterOnlineReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAfterOnlineReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAfterOnlineReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAfterOnlineReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAfterOnlineResp 用户上线回调响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAfterOnlineResp)
pub struct UserAfterOnlineResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAfterOnlineResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAfterOnlineResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAfterOnlineResp {
    fn default() -> &'a UserAfterOnlineResp {
        <UserAfterOnlineResp as ::protobuf::Message>::default_instance()
    }
}

impl UserAfterOnlineResp {
    pub fn new() -> UserAfterOnlineResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserAfterOnlineResp| { &m.header },
            |m: &mut UserAfterOnlineResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAfterOnlineResp>(
            "UserAfterOnlineResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAfterOnlineResp {
    const NAME: &'static str = "UserAfterOnlineResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAfterOnlineResp {
        UserAfterOnlineResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAfterOnlineResp {
        static instance: UserAfterOnlineResp = UserAfterOnlineResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAfterOnlineResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAfterOnlineResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAfterOnlineResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAfterOnlineResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAfterOfflineReq 用户下线回调请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAfterOfflineReq)
pub struct UserAfterOfflineReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAfterOfflineReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UserAfterOfflineReq.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAfterOfflineReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAfterOfflineReq {
    fn default() -> &'a UserAfterOfflineReq {
        <UserAfterOfflineReq as ::protobuf::Message>::default_instance()
    }
}

impl UserAfterOfflineReq {
    pub fn new() -> UserAfterOfflineReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserAfterOfflineReq| { &m.header },
            |m: &mut UserAfterOfflineReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserAfterOfflineReq| { &m.userId },
            |m: &mut UserAfterOfflineReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAfterOfflineReq>(
            "UserAfterOfflineReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAfterOfflineReq {
    const NAME: &'static str = "UserAfterOfflineReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAfterOfflineReq {
        UserAfterOfflineReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAfterOfflineReq {
        static instance: UserAfterOfflineReq = UserAfterOfflineReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAfterOfflineReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAfterOfflineReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAfterOfflineReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAfterOfflineReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAfterOfflineResp 用户下线回调响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAfterOfflineResp)
pub struct UserAfterOfflineResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAfterOfflineResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAfterOfflineResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAfterOfflineResp {
    fn default() -> &'a UserAfterOfflineResp {
        <UserAfterOfflineResp as ::protobuf::Message>::default_instance()
    }
}

impl UserAfterOfflineResp {
    pub fn new() -> UserAfterOfflineResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserAfterOfflineResp| { &m.header },
            |m: &mut UserAfterOfflineResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAfterOfflineResp>(
            "UserAfterOfflineResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAfterOfflineResp {
    const NAME: &'static str = "UserAfterOfflineResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAfterOfflineResp {
        UserAfterOfflineResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAfterOfflineResp {
        static instance: UserAfterOfflineResp = UserAfterOfflineResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAfterOfflineResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAfterOfflineResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAfterOfflineResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAfterOfflineResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserBeforeConnectReq 服务端连接前的回调
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserBeforeConnectReq)
pub struct UserBeforeConnectReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserBeforeConnectReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UserBeforeConnectReq.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UserBeforeConnectReq.token)
    pub token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserBeforeConnectReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserBeforeConnectReq {
    fn default() -> &'a UserBeforeConnectReq {
        <UserBeforeConnectReq as ::protobuf::Message>::default_instance()
    }
}

impl UserBeforeConnectReq {
    pub fn new() -> UserBeforeConnectReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserBeforeConnectReq| { &m.header },
            |m: &mut UserBeforeConnectReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserBeforeConnectReq| { &m.userId },
            |m: &mut UserBeforeConnectReq| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &UserBeforeConnectReq| { &m.token },
            |m: &mut UserBeforeConnectReq| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserBeforeConnectReq>(
            "UserBeforeConnectReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserBeforeConnectReq {
    const NAME: &'static str = "UserBeforeConnectReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                26 => {
                    self.token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserBeforeConnectReq {
        UserBeforeConnectReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserBeforeConnectReq {
        static instance: UserBeforeConnectReq = UserBeforeConnectReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserBeforeConnectReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserBeforeConnectReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserBeforeConnectReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserBeforeConnectReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserBeforeConnectResp 服务端连接前的回调
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserBeforeConnectResp)
pub struct UserBeforeConnectResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserBeforeConnectResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    ///  是否允许建立连接
    // @@protoc_insertion_point(field:pb.UserBeforeConnectResp.success)
    pub success: bool,
    ///  如果不允许建立连接，返回的错误码
    // @@protoc_insertion_point(field:pb.UserBeforeConnectResp.closeCode)
    pub closeCode: ::protobuf::EnumOrUnknown<super::common::WebsocketCustomCloseCode>,
    ///  如果不允许建立连接，返回的错误信息
    // @@protoc_insertion_point(field:pb.UserBeforeConnectResp.closeReason)
    pub closeReason: ::std::string::String,
    // @@protoc_insertion_point(field:pb.UserBeforeConnectResp.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserBeforeConnectResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserBeforeConnectResp {
    fn default() -> &'a UserBeforeConnectResp {
        <UserBeforeConnectResp as ::protobuf::Message>::default_instance()
    }
}

impl UserBeforeConnectResp {
    pub fn new() -> UserBeforeConnectResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserBeforeConnectResp| { &m.header },
            |m: &mut UserBeforeConnectResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &UserBeforeConnectResp| { &m.success },
            |m: &mut UserBeforeConnectResp| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "closeCode",
            |m: &UserBeforeConnectResp| { &m.closeCode },
            |m: &mut UserBeforeConnectResp| { &mut m.closeCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "closeReason",
            |m: &UserBeforeConnectResp| { &m.closeReason },
            |m: &mut UserBeforeConnectResp| { &mut m.closeReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserBeforeConnectResp| { &m.userId },
            |m: &mut UserBeforeConnectResp| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserBeforeConnectResp>(
            "UserBeforeConnectResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserBeforeConnectResp {
    const NAME: &'static str = "UserBeforeConnectResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.success = is.read_bool()?;
                },
                24 => {
                    self.closeCode = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.closeReason = is.read_string()?;
                },
                42 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.closeCode != ::protobuf::EnumOrUnknown::new(super::common::WebsocketCustomCloseCode::CloseCodeZero) {
            my_size += ::protobuf::rt::int32_size(3, self.closeCode.value());
        }
        if !self.closeReason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.closeReason);
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if self.closeCode != ::protobuf::EnumOrUnknown::new(super::common::WebsocketCustomCloseCode::CloseCodeZero) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.closeCode))?;
        }
        if !self.closeReason.is_empty() {
            os.write_string(4, &self.closeReason)?;
        }
        if !self.userId.is_empty() {
            os.write_string(5, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserBeforeConnectResp {
        UserBeforeConnectResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.success = false;
        self.closeCode = ::protobuf::EnumOrUnknown::new(super::common::WebsocketCustomCloseCode::CloseCodeZero);
        self.closeReason.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserBeforeConnectResp {
        static instance: UserBeforeConnectResp = UserBeforeConnectResp {
            header: ::protobuf::MessageField::none(),
            success: false,
            closeCode: ::protobuf::EnumOrUnknown::from_i32(0),
            closeReason: ::std::string::String::new(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserBeforeConnectResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserBeforeConnectResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserBeforeConnectResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserBeforeConnectResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserBeforeRequestReq 用户请求前的回调请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserBeforeRequestReq)
pub struct UserBeforeRequestReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserBeforeRequestReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.UserBeforeRequestReq.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserBeforeRequestReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserBeforeRequestReq {
    fn default() -> &'a UserBeforeRequestReq {
        <UserBeforeRequestReq as ::protobuf::Message>::default_instance()
    }
}

impl UserBeforeRequestReq {
    pub fn new() -> UserBeforeRequestReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserBeforeRequestReq| { &m.header },
            |m: &mut UserBeforeRequestReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &UserBeforeRequestReq| { &m.path },
            |m: &mut UserBeforeRequestReq| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserBeforeRequestReq>(
            "UserBeforeRequestReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserBeforeRequestReq {
    const NAME: &'static str = "UserBeforeRequestReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserBeforeRequestReq {
        UserBeforeRequestReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserBeforeRequestReq {
        static instance: UserBeforeRequestReq = UserBeforeRequestReq {
            header: ::protobuf::MessageField::none(),
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserBeforeRequestReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserBeforeRequestReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserBeforeRequestReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserBeforeRequestReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserBeforeRequestResp 用户请求前的回调响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserBeforeRequestResp)
pub struct UserBeforeRequestResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserBeforeRequestResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.UserBeforeRequestResp.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserBeforeRequestResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserBeforeRequestResp {
    fn default() -> &'a UserBeforeRequestResp {
        <UserBeforeRequestResp as ::protobuf::Message>::default_instance()
    }
}

impl UserBeforeRequestResp {
    pub fn new() -> UserBeforeRequestResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserBeforeRequestResp| { &m.header },
            |m: &mut UserBeforeRequestResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserBeforeRequestResp| { &m.userId },
            |m: &mut UserBeforeRequestResp| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserBeforeRequestResp>(
            "UserBeforeRequestResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserBeforeRequestResp {
    const NAME: &'static str = "UserBeforeRequestResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserBeforeRequestResp {
        UserBeforeRequestResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserBeforeRequestResp {
        static instance: UserBeforeRequestResp = UserBeforeRequestResp {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserBeforeRequestResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserBeforeRequestResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserBeforeRequestResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserBeforeRequestResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAfterKeepAliveReq 用户保活回调请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAfterKeepAliveReq)
pub struct UserAfterKeepAliveReq {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAfterKeepAliveReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAfterKeepAliveReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAfterKeepAliveReq {
    fn default() -> &'a UserAfterKeepAliveReq {
        <UserAfterKeepAliveReq as ::protobuf::Message>::default_instance()
    }
}

impl UserAfterKeepAliveReq {
    pub fn new() -> UserAfterKeepAliveReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &UserAfterKeepAliveReq| { &m.header },
            |m: &mut UserAfterKeepAliveReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAfterKeepAliveReq>(
            "UserAfterKeepAliveReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAfterKeepAliveReq {
    const NAME: &'static str = "UserAfterKeepAliveReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAfterKeepAliveReq {
        UserAfterKeepAliveReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAfterKeepAliveReq {
        static instance: UserAfterKeepAliveReq = UserAfterKeepAliveReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAfterKeepAliveReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAfterKeepAliveReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAfterKeepAliveReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAfterKeepAliveReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// UserAfterKeepAliveResp 用户保活回调响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.UserAfterKeepAliveResp)
pub struct UserAfterKeepAliveResp {
    // message fields
    // @@protoc_insertion_point(field:pb.UserAfterKeepAliveResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.UserAfterKeepAliveResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAfterKeepAliveResp {
    fn default() -> &'a UserAfterKeepAliveResp {
        <UserAfterKeepAliveResp as ::protobuf::Message>::default_instance()
    }
}

impl UserAfterKeepAliveResp {
    pub fn new() -> UserAfterKeepAliveResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &UserAfterKeepAliveResp| { &m.header },
            |m: &mut UserAfterKeepAliveResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAfterKeepAliveResp>(
            "UserAfterKeepAliveResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAfterKeepAliveResp {
    const NAME: &'static str = "UserAfterKeepAliveResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAfterKeepAliveResp {
        UserAfterKeepAliveResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAfterKeepAliveResp {
        static instance: UserAfterKeepAliveResp = UserAfterKeepAliveResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAfterKeepAliveResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAfterKeepAliveResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAfterKeepAliveResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAfterKeepAliveResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CreateRobotReq 创建机器人请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CreateRobotReq)
pub struct CreateRobotReq {
    // message fields
    // @@protoc_insertion_point(field:pb.CreateRobotReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.CreateRobotReq.robotId)
    pub robotId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.CreateRobotReq.nickname)
    pub nickname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pb.CreateRobotReq.avatar)
    pub avatar: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CreateRobotReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateRobotReq {
    fn default() -> &'a CreateRobotReq {
        <CreateRobotReq as ::protobuf::Message>::default_instance()
    }
}

impl CreateRobotReq {
    pub fn new() -> CreateRobotReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &CreateRobotReq| { &m.header },
            |m: &mut CreateRobotReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "robotId",
            |m: &CreateRobotReq| { &m.robotId },
            |m: &mut CreateRobotReq| { &mut m.robotId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nickname",
            |m: &CreateRobotReq| { &m.nickname },
            |m: &mut CreateRobotReq| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar",
            |m: &CreateRobotReq| { &m.avatar },
            |m: &mut CreateRobotReq| { &mut m.avatar },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateRobotReq>(
            "CreateRobotReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateRobotReq {
    const NAME: &'static str = "CreateRobotReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.robotId = is.read_string()?;
                },
                26 => {
                    self.nickname = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.avatar = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.robotId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.robotId);
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.avatar.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.robotId.is_empty() {
            os.write_string(2, &self.robotId)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.avatar.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateRobotReq {
        CreateRobotReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.robotId.clear();
        self.nickname = ::std::option::Option::None;
        self.avatar = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateRobotReq {
        static instance: CreateRobotReq = CreateRobotReq {
            header: ::protobuf::MessageField::none(),
            robotId: ::std::string::String::new(),
            nickname: ::std::option::Option::None,
            avatar: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateRobotReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateRobotReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateRobotReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRobotReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CreateRobotResp 创建机器人响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.CreateRobotResp)
pub struct CreateRobotResp {
    // message fields
    // @@protoc_insertion_point(field:pb.CreateRobotResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.CreateRobotResp.accessToken)
    pub accessToken: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.CreateRobotResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateRobotResp {
    fn default() -> &'a CreateRobotResp {
        <CreateRobotResp as ::protobuf::Message>::default_instance()
    }
}

impl CreateRobotResp {
    pub fn new() -> CreateRobotResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &CreateRobotResp| { &m.header },
            |m: &mut CreateRobotResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accessToken",
            |m: &CreateRobotResp| { &m.accessToken },
            |m: &mut CreateRobotResp| { &mut m.accessToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateRobotResp>(
            "CreateRobotResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateRobotResp {
    const NAME: &'static str = "CreateRobotResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.accessToken = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.accessToken.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.accessToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.accessToken.is_empty() {
            os.write_string(2, &self.accessToken)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateRobotResp {
        CreateRobotResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.accessToken.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateRobotResp {
        static instance: CreateRobotResp = CreateRobotResp {
            header: ::protobuf::MessageField::none(),
            accessToken: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateRobotResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateRobotResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateRobotResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRobotResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetUserModelReq 获取用户模型请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetUserModelByIdReq)
pub struct GetUserModelByIdReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GetUserModelByIdReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdReq.userId)
    pub userId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdReq.opt)
    pub opt: ::protobuf::MessageField<get_user_model_by_id_req::Opt>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetUserModelByIdReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserModelByIdReq {
    fn default() -> &'a GetUserModelByIdReq {
        <GetUserModelByIdReq as ::protobuf::Message>::default_instance()
    }
}

impl GetUserModelByIdReq {
    pub fn new() -> GetUserModelByIdReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GetUserModelByIdReq| { &m.header },
            |m: &mut GetUserModelByIdReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &GetUserModelByIdReq| { &m.userId },
            |m: &mut GetUserModelByIdReq| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_user_model_by_id_req::Opt>(
            "opt",
            |m: &GetUserModelByIdReq| { &m.opt },
            |m: &mut GetUserModelByIdReq| { &mut m.opt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserModelByIdReq>(
            "GetUserModelByIdReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserModelByIdReq {
    const NAME: &'static str = "GetUserModelByIdReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        if let Some(v) = self.opt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        if let Some(v) = self.opt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserModelByIdReq {
        GetUserModelByIdReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.opt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserModelByIdReq {
        static instance: GetUserModelByIdReq = GetUserModelByIdReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            opt: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserModelByIdReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserModelByIdReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserModelByIdReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserModelByIdReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetUserModelByIdReq`
pub mod get_user_model_by_id_req {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.GetUserModelByIdReq.Opt)
    pub struct Opt {
        // message fields
        ///  是否携带用户设置列表
        // @@protoc_insertion_point(field:pb.GetUserModelByIdReq.Opt.withUserSettings)
        pub withUserSettings: bool,
        // @@protoc_insertion_point(field:pb.GetUserModelByIdReq.Opt.userSettingKeys)
        pub userSettingKeys: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:pb.GetUserModelByIdReq.Opt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Opt {
        fn default() -> &'a Opt {
            <Opt as ::protobuf::Message>::default_instance()
        }
    }

    impl Opt {
        pub fn new() -> Opt {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "withUserSettings",
                |m: &Opt| { &m.withUserSettings },
                |m: &mut Opt| { &mut m.withUserSettings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "userSettingKeys",
                |m: &Opt| { &m.userSettingKeys },
                |m: &mut Opt| { &mut m.userSettingKeys },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Opt>(
                "GetUserModelByIdReq.Opt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Opt {
        const NAME: &'static str = "Opt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.withUserSettings = is.read_bool()?;
                    },
                    18 => {
                        self.userSettingKeys.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.withUserSettings != false {
                my_size += 1 + 1;
            }
            for value in &self.userSettingKeys {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.withUserSettings != false {
                os.write_bool(1, self.withUserSettings)?;
            }
            for v in &self.userSettingKeys {
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Opt {
            Opt::new()
        }

        fn clear(&mut self) {
            self.withUserSettings = false;
            self.userSettingKeys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Opt {
            static instance: Opt = Opt {
                withUserSettings: false,
                userSettingKeys: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Opt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetUserModelByIdReq.Opt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Opt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Opt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// GetUserModelByIdResp 获取用户模型响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetUserModelByIdResp)
pub struct GetUserModelByIdResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GetUserModelByIdResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdResp.userModelJson)
    pub userModelJson: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdResp.userSettingsJson)
    pub userSettingsJson: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetUserModelByIdResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserModelByIdResp {
    fn default() -> &'a GetUserModelByIdResp {
        <GetUserModelByIdResp as ::protobuf::Message>::default_instance()
    }
}

impl GetUserModelByIdResp {
    pub fn new() -> GetUserModelByIdResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GetUserModelByIdResp| { &m.header },
            |m: &mut GetUserModelByIdResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userModelJson",
            |m: &GetUserModelByIdResp| { &m.userModelJson },
            |m: &mut GetUserModelByIdResp| { &mut m.userModelJson },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userSettingsJson",
            |m: &GetUserModelByIdResp| { &m.userSettingsJson },
            |m: &mut GetUserModelByIdResp| { &mut m.userSettingsJson },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserModelByIdResp>(
            "GetUserModelByIdResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserModelByIdResp {
    const NAME: &'static str = "GetUserModelByIdResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userModelJson = is.read_bytes()?;
                },
                26 => {
                    self.userSettingsJson = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userModelJson.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.userModelJson);
        }
        if !self.userSettingsJson.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.userSettingsJson);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userModelJson.is_empty() {
            os.write_bytes(2, &self.userModelJson)?;
        }
        if !self.userSettingsJson.is_empty() {
            os.write_bytes(3, &self.userSettingsJson)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserModelByIdResp {
        GetUserModelByIdResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userModelJson.clear();
        self.userSettingsJson.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserModelByIdResp {
        static instance: GetUserModelByIdResp = GetUserModelByIdResp {
            header: ::protobuf::MessageField::none(),
            userModelJson: ::std::vec::Vec::new(),
            userSettingsJson: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserModelByIdResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserModelByIdResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserModelByIdResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserModelByIdResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GetUserModelByIdsReq 批量获取用户模型请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetUserModelByIdsReq)
pub struct GetUserModelByIdsReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GetUserModelByIdsReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdsReq.userIds)
    pub userIds: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdsReq.opt)
    pub opt: ::protobuf::MessageField<get_user_model_by_ids_req::Opt>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetUserModelByIdsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserModelByIdsReq {
    fn default() -> &'a GetUserModelByIdsReq {
        <GetUserModelByIdsReq as ::protobuf::Message>::default_instance()
    }
}

impl GetUserModelByIdsReq {
    pub fn new() -> GetUserModelByIdsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GetUserModelByIdsReq| { &m.header },
            |m: &mut GetUserModelByIdsReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userIds",
            |m: &GetUserModelByIdsReq| { &m.userIds },
            |m: &mut GetUserModelByIdsReq| { &mut m.userIds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, get_user_model_by_ids_req::Opt>(
            "opt",
            |m: &GetUserModelByIdsReq| { &m.opt },
            |m: &mut GetUserModelByIdsReq| { &mut m.opt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserModelByIdsReq>(
            "GetUserModelByIdsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserModelByIdsReq {
    const NAME: &'static str = "GetUserModelByIdsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userIds.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.opt)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.userIds {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.opt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.userIds {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.opt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserModelByIdsReq {
        GetUserModelByIdsReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userIds.clear();
        self.opt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserModelByIdsReq {
        static instance: GetUserModelByIdsReq = GetUserModelByIdsReq {
            header: ::protobuf::MessageField::none(),
            userIds: ::std::vec::Vec::new(),
            opt: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserModelByIdsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserModelByIdsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserModelByIdsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserModelByIdsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetUserModelByIdsReq`
pub mod get_user_model_by_ids_req {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:pb.GetUserModelByIdsReq.Opt)
    pub struct Opt {
        // message fields
        ///  是否携带用户设置列表
        // @@protoc_insertion_point(field:pb.GetUserModelByIdsReq.Opt.withUserSettings)
        pub withUserSettings: bool,
        // @@protoc_insertion_point(field:pb.GetUserModelByIdsReq.Opt.userSettingKeys)
        pub userSettingKeys: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:pb.GetUserModelByIdsReq.Opt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Opt {
        fn default() -> &'a Opt {
            <Opt as ::protobuf::Message>::default_instance()
        }
    }

    impl Opt {
        pub fn new() -> Opt {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "withUserSettings",
                |m: &Opt| { &m.withUserSettings },
                |m: &mut Opt| { &mut m.withUserSettings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "userSettingKeys",
                |m: &Opt| { &m.userSettingKeys },
                |m: &mut Opt| { &mut m.userSettingKeys },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Opt>(
                "GetUserModelByIdsReq.Opt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Opt {
        const NAME: &'static str = "Opt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.withUserSettings = is.read_bool()?;
                    },
                    18 => {
                        self.userSettingKeys.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.withUserSettings != false {
                my_size += 1 + 1;
            }
            for value in &self.userSettingKeys {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.withUserSettings != false {
                os.write_bool(1, self.withUserSettings)?;
            }
            for v in &self.userSettingKeys {
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Opt {
            Opt::new()
        }

        fn clear(&mut self) {
            self.withUserSettings = false;
            self.userSettingKeys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Opt {
            static instance: Opt = Opt {
                withUserSettings: false,
                userSettingKeys: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Opt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GetUserModelByIdsReq.Opt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Opt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Opt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

/// GetUserModelByIdsResp 批量获取用户模型响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GetUserModelByIdsResp)
pub struct GetUserModelByIdsResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GetUserModelByIdsResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdsResp.userModelJsons)
    pub userModelJsons: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pb.GetUserModelByIdsResp.userSettingsJsons)
    pub userSettingsJsons: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GetUserModelByIdsResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserModelByIdsResp {
    fn default() -> &'a GetUserModelByIdsResp {
        <GetUserModelByIdsResp as ::protobuf::Message>::default_instance()
    }
}

impl GetUserModelByIdsResp {
    pub fn new() -> GetUserModelByIdsResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GetUserModelByIdsResp| { &m.header },
            |m: &mut GetUserModelByIdsResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "userModelJsons",
            |m: &GetUserModelByIdsResp| { &m.userModelJsons },
            |m: &mut GetUserModelByIdsResp| { &mut m.userModelJsons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "userSettingsJsons",
            |m: &GetUserModelByIdsResp| { &m.userSettingsJsons },
            |m: &mut GetUserModelByIdsResp| { &mut m.userSettingsJsons },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserModelByIdsResp>(
            "GetUserModelByIdsResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserModelByIdsResp {
    const NAME: &'static str = "GetUserModelByIdsResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.userModelJsons.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.userSettingsJsons.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.userModelJsons {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.userSettingsJsons {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.userModelJsons {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        for (k, v) in &self.userSettingsJsons {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserModelByIdsResp {
        GetUserModelByIdsResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userModelJsons.clear();
        self.userSettingsJsons.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserModelByIdsResp {
        static instance: ::protobuf::rt::Lazy<GetUserModelByIdsResp> = ::protobuf::rt::Lazy::new();
        instance.get(GetUserModelByIdsResp::new)
    }
}

impl ::protobuf::MessageFull for GetUserModelByIdsResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserModelByIdsResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserModelByIdsResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserModelByIdsResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nuser.proto\x12\x02pb\x1a\x0ccommon.proto\"\xe8\x05\n\x0fUserRegister\
    Req\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06head\
    er\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\x12'\n\x0cregisterT\
    ime\x18\x03\x20\x01(\x03H\0R\x0cregisterTime\x88\x01\x01\x12\x1f\n\x08ni\
    ckname\x18\x04\x20\x01(\tH\x01R\x08nickname\x88\x01\x01\x12\x1b\n\x06ava\
    tar\x18\x05\x20\x01(\tH\x02R\x06avatar\x88\x01\x01\x12C\n\naccountMap\
    \x18\x06\x20\x03(\x0b2#.pb.UserRegisterReq.AccountMapEntryR\naccountMap\
    \x12C\n\nprofileMap\x18\x07\x20\x03(\x0b2#.pb.UserRegisterReq.ProfileMap\
    EntryR\nprofileMap\x12=\n\x08extraMap\x18\x08\x20\x03(\x0b2!.pb.UserRegi\
    sterReq.ExtraMapEntryR\x08extraMap\x12@\n\tverifyMap\x18\t\x20\x03(\x0b2\
    \".pb.UserRegisterReq.VerifyMapEntryR\tverifyMap\x1a=\n\x0fAccountMapEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a=\n\x0fProfileMapEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a;\n\rExtraMapEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\x1a<\n\x0eVerifyMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0f\n\r_reg\
    isterTimeB\x0b\n\t_nicknameB\t\n\x07_avatar\">\n\x10UserRegisterResp\x12\
    *\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"S\
    \n\x0eUserDestroyReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.Reque\
    stHeaderR\x06header\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\"=\
    \n\x0fUserDestroyResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Resp\
    onseHeaderR\x06header\"\xfd\x02\n\x12UserAccessTokenReq\x12)\n\x06header\
    \x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12F\n\naccountMa\
    p\x18\x02\x20\x03(\x0b2&.pb.UserAccessTokenReq.AccountMapEntryR\naccount\
    Map\x12C\n\tverifyMap\x18\x03\x20\x03(\x0b2%.pb.UserAccessTokenReq.Verif\
    yMapEntryR\tverifyMap\x12#\n\nexpireTime\x18\x04\x20\x01(\x03H\0R\nexpir\
    eTime\x88\x01\x01\x1a=\n\x0fAccountMapEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\x1a<\n\x0eVerifyMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\r\n\x0b_exp\
    ireTime\"{\n\x13UserAccessTokenResp\x12*\n\x06header\x18\x01\x20\x01(\
    \x0b2\x12.pb.ResponseHeaderR\x06header\x12\x16\n\x06userId\x18\x02\x20\
    \x01(\tR\x06userId\x12\x20\n\x0baccessToken\x18\x03\x20\x01(\tR\x0bacces\
    sToken\"^\n\x19RefreshUserAccessTokenReq\x12)\n\x06header\x18\x01\x20\
    \x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12\x16\n\x06userId\x18\x02\
    \x20\x01(\tR\x06userId\"H\n\x1aRefreshUserAccessTokenResp\x12*\n\x06head\
    er\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"E\n\x18Revoke\
    UserAccessTokenReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.Request\
    HeaderR\x06header\"G\n\x19RevokeUserAccessTokenResp\x12*\n\x06header\x18\
    \x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"\xd8\x02\n\x17Updat\
    eUserAccountMapReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.Request\
    HeaderR\x06header\x12K\n\naccountMap\x18\x02\x20\x03(\x0b2+.pb.UpdateUse\
    rAccountMapReq.AccountMapEntryR\naccountMap\x12H\n\tverifyMap\x18\x03\
    \x20\x03(\x0b2*.pb.UpdateUserAccountMapReq.VerifyMapEntryR\tverifyMap\
    \x1a=\n\x0fAccountMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a<\n\x0eVer\
    ifyMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"F\n\x18UpdateUserAccountMapRe\
    sp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06head\
    er\"\xd0\x01\n\x17UpdateUserProfileMapReq\x12)\n\x06header\x18\x01\x20\
    \x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12K\n\nprofileMap\x18\x02\
    \x20\x03(\x0b2+.pb.UpdateUserProfileMapReq.ProfileMapEntryR\nprofileMap\
    \x1a=\n\x0fProfileMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"F\n\x18Updat\
    eUserProfileMapResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Respon\
    seHeaderR\x06header\"\xc4\x01\n\x15UpdateUserExtraMapReq\x12)\n\x06heade\
    r\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12C\n\x08extraM\
    ap\x18\x02\x20\x03(\x0b2'.pb.UpdateUserExtraMapReq.ExtraMapEntryR\x08ext\
    raMap\x1a;\n\rExtraMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"D\n\x16Updat\
    eUserExtraMapResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Response\
    HeaderR\x06header\"\xf0\x02\n\x15UpdateUserCountMapReq\x12)\n\x06header\
    \x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x12A\n\tcountType\
    \x18\x02\x20\x01(\x0e2#.pb.UpdateUserCountMapReq.CountTypeR\tcountType\
    \x12A\n\talgorithm\x18\x03\x20\x01(\x0e2#.pb.UpdateUserCountMapReq.Algor\
    ithmR\talgorithm\x12\x14\n\x05count\x18\x04\x20\x01(\x03R\x05count\x12\
    \x1e\n\nstatistics\x18\x05\x20\x01(\x08R\nstatistics\"F\n\tCountType\x12\
    \x0f\n\x0bfriendCount\x10\0\x12\x12\n\x0ejoinGroupCount\x10\x01\x12\x14\
    \n\x10createGroupCount\x10\x02\"(\n\tAlgorithm\x12\x07\n\x03add\x10\0\
    \x12\x07\n\x03sub\x10\x01\x12\t\n\x05fixed\x10\x02\"D\n\x16UpdateUserCou\
    ntMapResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\
    \x06header\"?\n\x12GetSelfUserInfoReq\x12)\n\x06header\x18\x01\x20\x01(\
    \x0b2\x11.pb.RequestHeaderR\x06header\"\xf9\x04\n\x13GetSelfUserInfoResp\
    \x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\
    \x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\x12'\n\x0cregisterTim\
    e\x18\x03\x20\x01(\x03H\0R\x0cregisterTime\x88\x01\x01\x12\x1f\n\x08nick\
    name\x18\x04\x20\x01(\tH\x01R\x08nickname\x88\x01\x01\x12\x1b\n\x06avata\
    r\x18\x05\x20\x01(\tH\x02R\x06avatar\x88\x01\x01\x12G\n\naccountMap\x18\
    \x06\x20\x03(\x0b2'.pb.GetSelfUserInfoResp.AccountMapEntryR\naccountMap\
    \x12G\n\nprofileMap\x18\x07\x20\x03(\x0b2'.pb.GetSelfUserInfoResp.Profil\
    eMapEntryR\nprofileMap\x12A\n\x08extraMap\x18\x08\x20\x03(\x0b2%.pb.GetS\
    elfUserInfoResp.ExtraMapEntryR\x08extraMap\x1a=\n\x0fAccountMapEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a=\n\x0fProfileMapEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a;\n\rExtraMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0f\n\
    \r_registerTimeB\x0b\n\t_nicknameB\t\n\x07_avatar\"S\n\x0eGetUserInfoReq\
    \x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\
    \x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\"\xe9\x02\n\x0fGetUse\
    rInfoResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\
    \x06header\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\x12'\n\x0cr\
    egisterTime\x18\x03\x20\x01(\x03H\0R\x0cregisterTime\x88\x01\x01\x12\x1f\
    \n\x08nickname\x18\x04\x20\x01(\tH\x01R\x08nickname\x88\x01\x01\x12\x1b\
    \n\x06avatar\x18\x05\x20\x01(\tH\x02R\x06avatar\x88\x01\x01\x12C\n\nprof\
    ileMap\x18\x06\x20\x03(\x0b2#.pb.GetUserInfoResp.ProfileMapEntryR\nprofi\
    leMap\x1a=\n\x0fProfileMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x0f\n\r_r\
    egisterTimeB\x0b\n\t_nicknameB\t\n\x07_avatar\"\xd5\x02\n\x16ResetUserAc\
    countMapReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\
    \x06header\x12J\n\naccountMap\x18\x02\x20\x03(\x0b2*.pb.ResetUserAccount\
    MapReq.AccountMapEntryR\naccountMap\x12G\n\tverifyMap\x18\x03\x20\x03(\
    \x0b2).pb.ResetUserAccountMapReq.VerifyMapEntryR\tverifyMap\x1a=\n\x0fAc\
    countMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a<\n\x0eVerifyMapEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"E\n\x17ResetUserAccountMapResp\x12*\n\x06he\
    ader\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"?\n\x12User\
    AfterOnlineReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHead\
    erR\x06header\"A\n\x13UserAfterOnlineResp\x12*\n\x06header\x18\x01\x20\
    \x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"X\n\x13UserAfterOfflineReq\
    \x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\
    \x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\"B\n\x14UserAfterOffl\
    ineResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\
    \x06header\"o\n\x14UserBeforeConnectReq\x12)\n\x06header\x18\x01\x20\x01\
    (\x0b2\x11.pb.RequestHeaderR\x06header\x12\x16\n\x06userId\x18\x02\x20\
    \x01(\tR\x06userId\x12\x14\n\x05token\x18\x03\x20\x01(\tR\x05token\"\xd3\
    \x01\n\x15UserBeforeConnectResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\
    \x12.pb.ResponseHeaderR\x06header\x12\x18\n\x07success\x18\x02\x20\x01(\
    \x08R\x07success\x12:\n\tcloseCode\x18\x03\x20\x01(\x0e2\x1c.pb.Websocke\
    tCustomCloseCodeR\tcloseCode\x12\x20\n\x0bcloseReason\x18\x04\x20\x01(\t\
    R\x0bcloseReason\x12\x16\n\x06userId\x18\x05\x20\x01(\tR\x06userId\"U\n\
    \x14UserBeforeRequestReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.R\
    equestHeaderR\x06header\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\"[\
    \n\x15UserBeforeRequestResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.p\
    b.ResponseHeaderR\x06header\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06u\
    serId\"B\n\x15UserAfterKeepAliveReq\x12)\n\x06header\x18\x01\x20\x01(\
    \x0b2\x11.pb.RequestHeaderR\x06header\"D\n\x16UserAfterKeepAliveResp\x12\
    *\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\"\
    \xab\x01\n\x0eCreateRobotReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.\
    pb.RequestHeaderR\x06header\x12\x18\n\x07robotId\x18\x02\x20\x01(\tR\x07\
    robotId\x12\x1f\n\x08nickname\x18\x03\x20\x01(\tH\0R\x08nickname\x88\x01\
    \x01\x12\x1b\n\x06avatar\x18\x04\x20\x01(\tH\x01R\x06avatar\x88\x01\x01B\
    \x0b\n\t_nicknameB\t\n\x07_avatar\"_\n\x0fCreateRobotResp\x12*\n\x06head\
    er\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12\x20\n\x0ba\
    ccessToken\x18\x02\x20\x01(\tR\x0baccessToken\"\xf1\x01\n\x13GetUserMode\
    lByIdReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\
    \x06header\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\x122\n\x03o\
    pt\x18\x03\x20\x01(\x0b2\x1b.pb.GetUserModelByIdReq.OptH\0R\x03opt\x88\
    \x01\x01\x1a[\n\x03Opt\x12*\n\x10withUserSettings\x18\x01\x20\x01(\x08R\
    \x10withUserSettings\x12(\n\x0fuserSettingKeys\x18\x02\x20\x03(\tR\x0fus\
    erSettingKeysB\x06\n\x04_opt\"\x94\x01\n\x14GetUserModelByIdResp\x12*\n\
    \x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12$\n\
    \ruserModelJson\x18\x02\x20\x01(\x0cR\ruserModelJson\x12*\n\x10userSetti\
    ngsJson\x18\x03\x20\x01(\x0cR\x10userSettingsJson\"\xf5\x01\n\x14GetUser\
    ModelByIdsReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeade\
    rR\x06header\x12\x18\n\x07userIds\x18\x02\x20\x03(\tR\x07userIds\x123\n\
    \x03opt\x18\x03\x20\x01(\x0b2\x1c.pb.GetUserModelByIdsReq.OptH\0R\x03opt\
    \x88\x01\x01\x1a[\n\x03Opt\x12*\n\x10withUserSettings\x18\x01\x20\x01(\
    \x08R\x10withUserSettings\x12(\n\x0fuserSettingKeys\x18\x02\x20\x03(\tR\
    \x0fuserSettingKeysB\x06\n\x04_opt\"\x83\x03\n\x15GetUserModelByIdsResp\
    \x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\
    \x12U\n\x0euserModelJsons\x18\x02\x20\x03(\x0b2-.pb.GetUserModelByIdsRes\
    p.UserModelJsonsEntryR\x0euserModelJsons\x12^\n\x11userSettingsJsons\x18\
    \x03\x20\x03(\x0b20.pb.GetUserModelByIdsResp.UserSettingsJsonsEntryR\x11\
    userSettingsJsons\x1aA\n\x13UserModelJsonsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\
    \x028\x01\x1aD\n\x16UserSettingsJsonsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\
    \x012\xd1\x04\n\x0eaccountService\x129\n\x0cUserRegister\x12\x13.pb.User\
    RegisterReq\x1a\x14.pb.UserRegisterResp\x126\n\x0bUserDestroy\x12\x12.pb\
    .UserDestroyReq\x1a\x13.pb.UserDestroyResp\x12B\n\x0fUserAccessToken\x12\
    \x16.pb.UserAccessTokenReq\x1a\x17.pb.UserAccessTokenResp\x12W\n\x16Refr\
    eshUserAccessToken\x12\x1d.pb.RefreshUserAccessTokenReq\x1a\x1e.pb.Refre\
    shUserAccessTokenResp\x12T\n\x15RevokeUserAccessToken\x12\x1c.pb.RevokeU\
    serAccessTokenReq\x1a\x1d.pb.RevokeUserAccessTokenResp\x12Q\n\x14UpdateU\
    serAccountMap\x12\x1b.pb.UpdateUserAccountMapReq\x1a\x1c.pb.UpdateUserAc\
    countMapResp\x12N\n\x13ResetUserAccountMap\x12\x1a.pb.ResetUserAccountMa\
    pReq\x1a\x1b.pb.ResetUserAccountMapResp\x126\n\x0bCreateRobot\x12\x12.pb\
    .CreateRobotReq\x1a\x13.pb.CreateRobotResp2\x87\x04\n\x0binfoService\x12\
    Q\n\x14UpdateUserProfileMap\x12\x1b.pb.UpdateUserProfileMapReq\x1a\x1c.p\
    b.UpdateUserProfileMapResp\x12K\n\x12UpdateUserExtraMap\x12\x19.pb.Updat\
    eUserExtraMapReq\x1a\x1a.pb.UpdateUserExtraMapResp\x12K\n\x12UpdateUserC\
    ountMap\x12\x19.pb.UpdateUserCountMapReq\x1a\x1a.pb.UpdateUserCountMapRe\
    sp\x12B\n\x0fGetSelfUserInfo\x12\x16.pb.GetSelfUserInfoReq\x1a\x17.pb.Ge\
    tSelfUserInfoResp\x126\n\x0bGetUserInfo\x12\x12.pb.GetUserInfoReq\x1a\
    \x13.pb.GetUserInfoResp\x12E\n\x10GetUserModelById\x12\x17.pb.GetUserMod\
    elByIdReq\x1a\x18.pb.GetUserModelByIdResp\x12H\n\x11GetUserModelByIds\
    \x12\x18.pb.GetUserModelByIdsReq\x1a\x19.pb.GetUserModelByIdsResp2\xfd\
    \x02\n\x0fcallbackService\x12B\n\x0fUserAfterOnline\x12\x16.pb.UserAfter\
    OnlineReq\x1a\x17.pb.UserAfterOnlineResp\x12E\n\x10UserAfterOffline\x12\
    \x17.pb.UserAfterOfflineReq\x1a\x18.pb.UserAfterOfflineResp\x12H\n\x11Us\
    erBeforeConnect\x12\x18.pb.UserBeforeConnectReq\x1a\x19.pb.UserBeforeCon\
    nectResp\x12H\n\x11UserBeforeRequest\x12\x18.pb.UserBeforeRequestReq\x1a\
    \x19.pb.UserBeforeRequestResp\x12K\n\x12UserAfterKeepAlive\x12\x19.pb.Us\
    erAfterKeepAliveReq\x1a\x1a.pb.UserAfterKeepAliveRespB\x06Z\x04./pbJ\xde\
    |\n\x07\x12\x05\0\0\x8e\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x01\0\x0b\n\x08\n\x01\x08\x12\x03\x02\0\x1b\n\t\n\x02\
    \x08\x0b\x12\x03\x02\0\x1b\n\t\n\x02\x03\0\x12\x03\x03\0\x16\ny\n\x02\
    \x04\0\x12\x04\x08\0\x14\x01\x1a#UserRegisterReq\x20\xe7\x94\xa8\xe6\x88\
    \xb7\xe6\xb3\xa8\xe5\x86\x8c\xe8\xaf\xb7\xe6\xb1\x82\n2HUserRegister\x20\
    \xe7\x94\xa8\xe6\x88\xb7\xe6\xb3\xa8\xe5\x86\x8c\x20\xe4\xba\x8c\xe6\xac\
    \xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\x8f\xaf\xe4\xbb\
    \xa5\xe4\xbc\xa0\xe9\x80\x92\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe5\x8f\
    \x82\xe6\x95\xb0\n\n\n\n\x03\x04\0\x01\x12\x03\x08\x08\x17\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\t\x02\x1b\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\t\x02\
    \x0f\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\t\x10\x16\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03\t\x19\x1a\n\x1e\n\x04\x04\0\x02\x01\x12\x03\n\x02\x14\"\
    \x11\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\xe4\xb8\x80\n\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03\n\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\n\t\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\n\x12\x13\nM\n\
    \x04\x04\0\x02\x02\x12\x03\x0b\x02\"\"@\x20\xe6\xb3\xa8\xe5\x86\x8c\xe6\
    \x97\xb6\xe9\x97\xb4\x2013\xe4\xbd\x8d\xe6\x97\xb6\xe9\x97\xb4\xe6\x88\
    \xb3\x20\xe5\xa6\x82\xe6\x9e\x9c\xe4\xb8\x8d\xe4\xbc\xa0\x20\xe9\xbb\x98\
    \xe8\xae\xa4\xe4\xb8\xba\xe5\xbd\x93\xe5\x89\x8d\xe6\x97\xb6\xe9\x97\xb4\
    \n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x0b\x02\n\n\x0c\n\x05\x04\0\x02\
    \x02\x05\x12\x03\x0b\x0b\x10\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0b\
    \x11\x1d\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x0b\x20!\n\x15\n\x04\x04\
    \0\x02\x03\x12\x03\x0c\x02\x1f\"\x08\x20\xe6\x98\xb5\xe7\xa7\xb0\n\n\x0c\
    \n\x05\x04\0\x02\x03\x04\x12\x03\x0c\x02\n\n\x0c\n\x05\x04\0\x02\x03\x05\
    \x12\x03\x0c\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x0c\x12\x1a\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0c\x1d\x1e\n\x18\n\x04\x04\0\x02\
    \x04\x12\x03\r\x02\x1d\"\x0b\x20\xe5\xa4\xb4\xe5\x83\x8furl\n\n\x0c\n\
    \x05\x04\0\x02\x04\x04\x12\x03\r\x02\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\
    \x03\r\x0b\x11\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\r\x12\x18\n\x0c\n\
    \x05\x04\0\x02\x04\x03\x12\x03\r\x1b\x1c\nI\n\x04\x04\0\x02\x05\x12\x03\
    \x0f\x02%\"<\x20\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\
    \xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbepassword\xe3\x80\
    \x81email\xe3\x80\x81phone\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\x04\0\
    \x02\x05\x06\x12\x03\x0f\x02\x15\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\
    \x0f\x16\x20\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x0f#$\nI\n\x04\x04\0\
    \x02\x06\x12\x03\x10\x02%\"<\x20\xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\xa1\xe6\
    \x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbe\
    \xe6\x80\xa7\xe5\x88\xab\xe3\x80\x81\xe5\xb9\xb4\xe9\xbe\x84\xe3\x80\x81\
    \xe7\x94\x9f\xe6\x97\xa5\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\x04\0\x02\
    \x06\x06\x12\x03\x10\x02\x15\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x10\
    \x16\x20\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x10#$\nI\n\x04\x04\0\x02\
    \x07\x12\x03\x11\x02#\"<\x20\xe6\x89\xa9\xe5\xb1\x95\xe4\xbf\xa1\xe6\x81\
    \xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbe\xe7\
    \xad\x89\xe7\xba\xa7\xe3\x80\x81\xe7\xa7\xaf\xe5\x88\x86\xe3\x80\x81\xe9\
    \x87\x91\xe5\xb8\x81\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\x04\0\x02\x07\
    \x06\x12\x03\x11\x02\x15\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x11\x16\
    \x1e\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x11!\"\nD\n\x04\x04\0\x02\x08\
    \x12\x03\x13\x02$\"7\x20\xe9\xaa\x8c\xe8\xaf\x81\xe4\xbf\xa1\xe6\x81\xaf\
    \x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbesmsCode\
    \xe3\x80\x81emailCode\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\x04\0\x02\
    \x08\x06\x12\x03\x13\x02\x15\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\x13\
    \x16\x1f\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x13\"#\n0\n\x02\x04\x01\
    \x12\x04\x17\0\x19\x01\x1a$UserRegisterResp\x20\xe7\x94\xa8\xe6\x88\xb7\
    \xe6\xb3\xa8\xe5\x86\x8c\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\x04\x01\x01\
    \x12\x03\x17\x08\x18\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x18\x02\x1c\n\x0c\
    \n\x05\x04\x01\x02\0\x06\x12\x03\x18\x02\x10\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03\x18\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x18\x1a\
    \x1b\nI\n\x02\x04\x02\x12\x04\x1e\0!\x01\x1a\"UserDestroyReq\x20\xe7\x94\
    \xa8\xe6\x88\xb7\xe6\xb3\xa8\xe9\x94\x80\xe8\xaf\xb7\xe6\xb1\x82\n2\x19U\
    serDestroy\x20\xe7\x94\xa8\xe6\x88\xb7\xe6\xb3\xa8\xe9\x94\x80\n\n\n\n\
    \x03\x04\x02\x01\x12\x03\x1e\x08\x16\n\x0b\n\x04\x04\x02\x02\0\x12\x03\
    \x1f\x02\x1b\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03\x1f\x02\x0f\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03\x1f\x10\x16\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03\x1f\x19\x1a\n!\n\x04\x04\x02\x02\x01\x12\x03\x20\x02\x14\"\x14\
    \x20//\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\xe4\xb8\x80\n\n\x0c\
    \n\x05\x04\x02\x02\x01\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03\x20\t\x0f\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x20\
    \x12\x13\n/\n\x02\x04\x03\x12\x04$\0&\x01\x1a#UserDestroyResp\x20\xe7\
    \x94\xa8\xe6\x88\xb7\xe6\xb3\xa8\xe9\x94\x80\xe5\x93\x8d\xe5\xba\x94\n\n\
    \n\n\x03\x04\x03\x01\x12\x03$\x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\x03%\
    \x02\x1c\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03%\x02\x10\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03%\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03%\
    \x1a\x1b\nf\n\x02\x04\x04\x12\x04+\00\x01\x1a&UserAccessTokenReq\x20\xe7\
    \x94\xa8\xe6\x88\xb7\xe7\x99\xbb\xe5\xbd\x95\xe8\xaf\xb7\xe6\xb1\x82\n22\
    UserAccessToken\x20\xe7\x94\xa8\xe6\x88\xb7\xe9\x80\x9a\xe8\xbf\x87accou\
    ntMap\xe8\x8e\xb7\xe5\x8f\x96token\n\n\n\n\x03\x04\x04\x01\x12\x03+\x08\
    \x1a\n\x0b\n\x04\x04\x04\x02\0\x12\x03,\x02\x1b\n\x0c\n\x05\x04\x04\x02\
    \0\x06\x12\x03,\x02\x0f\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03,\x10\x16\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03,\x19\x1a\nI\n\x04\x04\x04\x02\x01\
    \x12\x03-\x02%\"<\x20\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\
    \x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbepassword\
    \xe3\x80\x81email\xe3\x80\x81phone\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\
    \x04\x04\x02\x01\x06\x12\x03-\x02\x15\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x03-\x16\x20\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03-#$\nD\n\x04\
    \x04\x04\x02\x02\x12\x03.\x02$\"7\x20\xe9\xaa\x8c\xe8\xaf\x81\xe4\xbf\
    \xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\
    \x94\xbesmsCode\xe3\x80\x81emailCode\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\
    \x05\x04\x04\x02\x02\x06\x12\x03.\x02\x15\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03.\x16\x1f\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03.\"#\n*\n\
    \x04\x04\x04\x02\x03\x12\x03/\x02\x20\"\x1d\x20\xe8\xbf\x87\xe6\x9c\x9f\
    \xe6\x97\xb6\xe9\x97\xb4\x2013\xe4\xbd\x8d\xe6\x97\xb6\xe9\x97\xb4\xe6\
    \x88\xb3\n\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03/\x02\n\n\x0c\n\x05\
    \x04\x04\x02\x03\x05\x12\x03/\x0b\x10\n\x0c\n\x05\x04\x04\x02\x03\x01\
    \x12\x03/\x11\x1b\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03/\x1e\x1f\n3\n\
    \x02\x04\x05\x12\x043\07\x01\x1a'UserAccessTokenResp\x20\xe7\x94\xa8\xe6\
    \x88\xb7\xe7\x99\xbb\xe5\xbd\x95\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\x04\
    \x05\x01\x12\x033\x08\x1b\n\x0b\n\x04\x04\x05\x02\0\x12\x034\x02\x1c\n\
    \x0c\n\x05\x04\x05\x02\0\x06\x12\x034\x02\x10\n\x0c\n\x05\x04\x05\x02\0\
    \x01\x12\x034\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x034\x1a\x1b\n\
    \x1e\n\x04\x04\x05\x02\x01\x12\x035\x02\x14\"\x11\x20\xe7\x94\xa8\xe6\
    \x88\xb7id\x20\xe5\x94\xaf\xe4\xb8\x80\n\n\x0c\n\x05\x04\x05\x02\x01\x05\
    \x12\x035\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x035\t\x0f\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x035\x12\x13\n\x1a\n\x04\x04\x05\x02\x02\
    \x12\x036\x02\x19\"\r\x20\xe7\x94\xa8\xe6\x88\xb7token\n\n\x0c\n\x05\x04\
    \x05\x02\x02\x05\x12\x036\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\
    \x036\t\x14\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x036\x17\x18\ni\n\x02\
    \x04\x06\x12\x04<\0?\x01\x1a2RefreshUserAccessTokenReq\x20\xe5\x88\xb7\
    \xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7token\xe8\xaf\xb7\xe6\xb1\x82\n2)Ref\
    reshUserAccessToken\x20\xe5\x88\xb7\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7t\
    oken\n\n\n\n\x03\x04\x06\x01\x12\x03<\x08!\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03=\x02\x1b\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03=\x02\x0f\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03=\x10\x16\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03=\x19\x1a\n\x1e\n\x04\x04\x06\x02\x01\x12\x03>\x02\x14\"\x11\x20\xe7\
    \x94\xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\xe4\xb8\x80\n\n\x0c\n\x05\x04\x06\
    \x02\x01\x05\x12\x03>\x02\x08\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03>\t\
    \x0f\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03>\x12\x13\n?\n\x02\x04\x07\
    \x12\x04B\0D\x01\x1a3RefreshUserAccessTokenResp\x20\xe5\x88\xb7\xe6\x96\
    \xb0\xe7\x94\xa8\xe6\x88\xb7token\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\
    \x04\x07\x01\x12\x03B\x08\"\n\x0b\n\x04\x04\x07\x02\0\x12\x03C\x02\x1c\n\
    \x0c\n\x05\x04\x07\x02\0\x06\x12\x03C\x02\x10\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03C\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03C\x1a\x1b\na\
    \n\x02\x04\x08\x12\x04I\0K\x01\x1a+RevokeUserAccessTokenReq\x20\xe6\xb3\
    \xa8\xe9\x94\x80\xe7\x94\xa8\xe6\x88\xb7token\n2(RevokeUserAccessToken\
    \x20\xe6\xb3\xa8\xe9\x94\x80\xe7\x94\xa8\xe6\x88\xb7token\n\n\n\n\x03\
    \x04\x08\x01\x12\x03I\x08\x20\n\x0b\n\x04\x04\x08\x02\0\x12\x03J\x02\x1b\
    \n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03J\x02\x0f\n\x0c\n\x05\x04\x08\x02\
    \0\x01\x12\x03J\x10\x16\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03J\x19\x1a\n\
    8\n\x02\x04\t\x12\x04N\0P\x01\x1a,RevokeUserAccessTokenResp\x20\xe6\xb3\
    \xa8\xe9\x94\x80\xe7\x94\xa8\xe6\x88\xb7token\n\n\n\n\x03\x04\t\x01\x12\
    \x03N\x08!\n\x0b\n\x04\x04\t\x02\0\x12\x03O\x02\x1c\n\x0c\n\x05\x04\t\
    \x02\0\x06\x12\x03O\x02\x10\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03O\x11\x17\
    \n\x0c\n\x05\x04\t\x02\0\x03\x12\x03O\x1a\x1b\ns\n\x02\x04\n\x12\x04U\0Y\
    \x01\x1a7UpdateUserAccountMapReq\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\
    \xe6\x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe8\xaf\xb7\
    \xe6\xb1\x82\n2.UpdateUserAccountMap\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\
    \xa8\xe6\x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\n\n\n\n\
    \x03\x04\n\x01\x12\x03U\x08\x1f\n\x0b\n\x04\x04\n\x02\0\x12\x03V\x02\x1b\
    \n\x0c\n\x05\x04\n\x02\0\x06\x12\x03V\x02\x0f\n\x0c\n\x05\x04\n\x02\0\
    \x01\x12\x03V\x10\x16\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03V\x19\x1a\nI\n\
    \x04\x04\n\x02\x01\x12\x03W\x02%\"<\x20\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\
    \xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\
    \x94\xbepassword\xe3\x80\x81email\xe3\x80\x81phone\xe7\xad\x89\xe7\xad\
    \x89\n\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03W\x02\x15\n\x0c\n\x05\x04\n\
    \x02\x01\x01\x12\x03W\x16\x20\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03W#$\n\
    R\n\x04\x04\n\x02\x02\x12\x03X\x02$\"E\x20\xe9\xaa\x8c\xe8\xaf\x81\xe4\
    \xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\
    \xe6\x94\xbeoldPassword\xe3\x80\x81smsCode\xe3\x80\x81emailCode\xe7\xad\
    \x89\xe7\xad\x89\n\n\x0c\n\x05\x04\n\x02\x02\x06\x12\x03X\x02\x15\n\x0c\
    \n\x05\x04\n\x02\x02\x01\x12\x03X\x16\x1f\n\x0c\n\x05\x04\n\x02\x02\x03\
    \x12\x03X\"#\nD\n\x02\x04\x0b\x12\x04\\\0^\x01\x1a8UpdateUserAccountMapR\
    esp\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe8\xb4\xa6\xe5\
    \x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\xe5\xba\x94\n\n\n\n\x03\x04\
    \x0b\x01\x12\x03\\\x08\x20\n\x0b\n\x04\x04\x0b\x02\0\x12\x03]\x02\x1c\n\
    \x0c\n\x05\x04\x0b\x02\0\x06\x12\x03]\x02\x10\n\x0c\n\x05\x04\x0b\x02\0\
    \x01\x12\x03]\x11\x17\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03]\x1a\x1b\ns\
    \n\x02\x04\x0c\x12\x04c\0f\x01\x1a7UpdateUserProfileMapReq\x20\xe6\x9b\
    \xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\
    \xa1\xe6\x81\xaf\xe8\xaf\xb7\xe6\xb1\x82\n2.UpdateUserProfileMap\x20\xe6\
    \x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\xaa\xe4\xba\xba\xe4\
    \xbf\xa1\xe6\x81\xaf\n\n\n\n\x03\x04\x0c\x01\x12\x03c\x08\x1f\n\x0b\n\
    \x04\x04\x0c\x02\0\x12\x03d\x02\x1b\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\
    \x03d\x02\x0f\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03d\x10\x16\n\x0c\n\x05\
    \x04\x0c\x02\0\x03\x12\x03d\x19\x1a\nI\n\x04\x04\x0c\x02\x01\x12\x03e\
    \x02%\"<\x20\xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\
    \xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbe\xe6\x80\xa7\xe5\x88\
    \xab\xe3\x80\x81\xe5\xb9\xb4\xe9\xbe\x84\xe3\x80\x81\xe7\x94\x9f\xe6\x97\
    \xa5\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03e\
    \x02\x15\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03e\x16\x20\n\x0c\n\x05\
    \x04\x0c\x02\x01\x03\x12\x03e#$\nD\n\x02\x04\r\x12\x04i\0k\x01\x1a8Updat\
    eUserProfileMapResp\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\
    \xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\xe5\xba\x94\
    \n\n\n\n\x03\x04\r\x01\x12\x03i\x08\x20\n\x0b\n\x04\x04\r\x02\0\x12\x03j\
    \x02\x1c\n\x0c\n\x05\x04\r\x02\0\x06\x12\x03j\x02\x10\n\x0c\n\x05\x04\r\
    \x02\0\x01\x12\x03j\x11\x17\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03j\x1a\x1b\
    \no\n\x02\x04\x0e\x12\x04p\0s\x01\x1a5UpdateUserExtraMapReq\x20\xe6\x9b\
    \xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe6\x89\xa9\xe5\xb1\x95\xe4\xbf\
    \xa1\xe6\x81\xaf\xe8\xaf\xb7\xe6\xb1\x82\n2,UpdateUserExtraMap\x20\xe6\
    \x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe6\x89\xa9\xe5\xb1\x95\xe4\
    \xbf\xa1\xe6\x81\xaf\n\n\n\n\x03\x04\x0e\x01\x12\x03p\x08\x1d\n\x0b\n\
    \x04\x04\x0e\x02\0\x12\x03q\x02\x1b\n\x0c\n\x05\x04\x0e\x02\0\x06\x12\
    \x03q\x02\x0f\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03q\x10\x16\n\x0c\n\x05\
    \x04\x0e\x02\0\x03\x12\x03q\x19\x1a\nI\n\x04\x04\x0e\x02\x01\x12\x03r\
    \x02#\"<\x20\xe6\x89\xa9\xe5\xb1\x95\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\
    \xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbe\xe7\xad\x89\xe7\xba\
    \xa7\xe3\x80\x81\xe7\xa7\xaf\xe5\x88\x86\xe3\x80\x81\xe9\x87\x91\xe5\xb8\
    \x81\xe7\xad\x89\xe7\xad\x89\n\n\x0c\n\x05\x04\x0e\x02\x01\x06\x12\x03r\
    \x02\x15\n\x0c\n\x05\x04\x0e\x02\x01\x01\x12\x03r\x16\x1e\n\x0c\n\x05\
    \x04\x0e\x02\x01\x03\x12\x03r!\"\nB\n\x02\x04\x0f\x12\x04v\0x\x01\x1a6Up\
    dateUserExtraMapResp\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\
    \xe6\x89\xa9\xe5\xb1\x95\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\xe5\xba\x94\
    \n\n\n\n\x03\x04\x0f\x01\x12\x03v\x08\x1e\n\x0b\n\x04\x04\x0f\x02\0\x12\
    \x03w\x02\x1c\n\x0c\n\x05\x04\x0f\x02\0\x06\x12\x03w\x02\x10\n\x0c\n\x05\
    \x04\x0f\x02\0\x01\x12\x03w\x11\x17\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\
    \x03w\x1a\x1b\nB\n\x02\x04\x10\x12\x05{\0\x8f\x01\x01\x1a5UpdateUserCoun\
    tMapReq\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xa1\
    \xe6\x95\xb0\xe4\xbf\xa1\xe6\x81\xaf\xe8\xaf\xb7\xe6\xb1\x82\n\n\n\n\x03\
    \x04\x10\x01\x12\x03{\x08\x1d\n\x0b\n\x04\x04\x10\x02\0\x12\x03|\x02\x1b\
    \n\x0c\n\x05\x04\x10\x02\0\x06\x12\x03|\x02\x0f\n\x0c\n\x05\x04\x10\x02\
    \0\x01\x12\x03|\x10\x16\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03|\x19\x1a\n\
    \r\n\x04\x04\x10\x04\0\x12\x05~\x02\x82\x01\x03\n\x0c\n\x05\x04\x10\x04\
    \0\x01\x12\x03~\x07\x10\n\x1d\n\x06\x04\x10\x04\0\x02\0\x12\x03\x7f\x04\
    \x14\"\x0e\x20\xe5\xa5\xbd\xe5\x8f\x8b\xe6\x95\xb0\xe9\x87\x8f\n\n\x0e\n\
    \x07\x04\x10\x04\0\x02\0\x01\x12\x03\x7f\x04\x0f\n\x0e\n\x07\x04\x10\x04\
    \0\x02\0\x02\x12\x03\x7f\x12\x13\n!\n\x06\x04\x10\x04\0\x02\x01\x12\x04\
    \x80\x01\x04\x17\"\x11\x20\xe5\x8a\xa0\xe5\x85\xa5\xe7\xbe\xa4\xe6\x95\
    \xb0\xe9\x87\x8f\n\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\x80\x01\
    \x04\x12\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x02\x12\x04\x80\x01\x15\x16\n\
    !\n\x06\x04\x10\x04\0\x02\x02\x12\x04\x81\x01\x04\x19\"\x11\x20\xe5\x88\
    \x9b\xe5\xbb\xba\xe7\xbe\xa4\xe6\x95\xb0\xe9\x87\x8f\n\n\x0f\n\x07\x04\
    \x10\x04\0\x02\x02\x01\x12\x04\x81\x01\x04\x14\n\x0f\n\x07\x04\x10\x04\0\
    \x02\x02\x02\x12\x04\x81\x01\x17\x18\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\
    \x83\x01\x02\x1a\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\x83\x01\x02\x0b\n\
    \r\n\x05\x04\x10\x02\x01\x01\x12\x04\x83\x01\x0c\x15\n\r\n\x05\x04\x10\
    \x02\x01\x03\x12\x04\x83\x01\x18\x19\n\x0e\n\x04\x04\x10\x04\x01\x12\x06\
    \x85\x01\x02\x89\x01\x03\n\r\n\x05\x04\x10\x04\x01\x01\x12\x04\x85\x01\
    \x07\x10\n\x15\n\x06\x04\x10\x04\x01\x02\0\x12\x04\x86\x01\x04\x0c\"\x05\
    \x20\xe5\x8a\xa0\n\n\x0f\n\x07\x04\x10\x04\x01\x02\0\x01\x12\x04\x86\x01\
    \x04\x07\n\x0f\n\x07\x04\x10\x04\x01\x02\0\x02\x12\x04\x86\x01\n\x0b\n\
    \x15\n\x06\x04\x10\x04\x01\x02\x01\x12\x04\x87\x01\x04\x0c\"\x05\x20\xe5\
    \x87\x8f\n\n\x0f\n\x07\x04\x10\x04\x01\x02\x01\x01\x12\x04\x87\x01\x04\
    \x07\n\x0f\n\x07\x04\x10\x04\x01\x02\x01\x02\x12\x04\x87\x01\n\x0b\n\x18\
    \n\x06\x04\x10\x04\x01\x02\x02\x12\x04\x88\x01\x04\x0e\"\x08\x20\xe5\x9b\
    \xba\xe5\xae\x9a\n\n\x0f\n\x07\x04\x10\x04\x01\x02\x02\x01\x12\x04\x88\
    \x01\x04\t\n\x0f\n\x07\x04\x10\x04\x01\x02\x02\x02\x12\x04\x88\x01\x0c\r\
    \n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x8a\x01\x02\x1a\n\r\n\x05\x04\x10\
    \x02\x02\x06\x12\x04\x8a\x01\x02\x0b\n\r\n\x05\x04\x10\x02\x02\x01\x12\
    \x04\x8a\x01\x0c\x15\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x8a\x01\x18\
    \x19\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\x8b\x01\x02\x12\n\r\n\x05\x04\
    \x10\x02\x03\x05\x12\x04\x8b\x01\x02\x07\n\r\n\x05\x04\x10\x02\x03\x01\
    \x12\x04\x8b\x01\x08\r\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\x8b\x01\x10\
    \x11\n7\n\x04\x04\x10\x02\x04\x12\x04\x8e\x01\x02\x16\x1a)\xe6\x98\xaf\
    \xe5\x90\xa6\xe7\xbb\x9f\xe8\xae\xa1\x20\xe7\xbb\x9f\xe8\xae\xa1\xe5\x90\
    \x8e\xe5\x90\x8c\xe6\xad\xa5\xe5\x88\xb0\xe6\x95\xb0\xe6\x8d\xae\xe5\xba\
    \x93\n\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\x8e\x01\x02\x06\n\r\n\x05\
    \x04\x10\x02\x04\x01\x12\x04\x8e\x01\x07\x11\n\r\n\x05\x04\x10\x02\x04\
    \x03\x12\x04\x8e\x01\x14\x15\nD\n\x02\x04\x11\x12\x06\x92\x01\0\x94\x01\
    \x01\x1a6UpdateUserCountMapResp\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\
    \xe6\x88\xb7\xe8\xae\xa1\xe6\x95\xb0\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\
    \xe5\xba\x94\n\n\x0b\n\x03\x04\x11\x01\x12\x04\x92\x01\x08\x1e\n\x0c\n\
    \x04\x04\x11\x02\0\x12\x04\x93\x01\x02\x1c\n\r\n\x05\x04\x11\x02\0\x06\
    \x12\x04\x93\x01\x02\x10\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x93\x01\x11\
    \x17\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x93\x01\x1a\x1b\nq\n\x02\x04\
    \x12\x12\x06\x99\x01\0\x9b\x01\x01\x1a5GetSelfUserInfoReq\x20\xe8\x8e\
    \xb7\xe5\x8f\x96\xe8\x87\xaa\xe5\xb7\xb1\xe7\x9a\x84\xe7\x94\xa8\xe6\x88\
    \xb7\xe4\xbf\xa1\xe6\x81\xaf\xe8\xaf\xb7\xe6\xb1\x82\n2,GetSelfUserInfo\
    \x20\xe8\x8e\xb7\xe5\x8f\x96\xe8\x87\xaa\xe5\xb7\xb1\xe7\x9a\x84\xe7\x94\
    \xa8\xe6\x88\xb7\xe4\xbf\xa1\xe6\x81\xaf\n\n\x0b\n\x03\x04\x12\x01\x12\
    \x04\x99\x01\x08\x1a\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x9a\x01\x02\x1b\n\
    \r\n\x05\x04\x12\x02\0\x06\x12\x04\x9a\x01\x02\x0f\n\r\n\x05\x04\x12\x02\
    \0\x01\x12\x04\x9a\x01\x10\x16\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x9a\
    \x01\x19\x1a\nD\n\x02\x04\x13\x12\x06\x9e\x01\0\xa8\x01\x01\x1a6GetSelfU\
    serInfoResp\x20\xe8\x8e\xb7\xe5\x8f\x96\xe8\x87\xaa\xe5\xb7\xb1\xe7\x9a\
    \x84\xe7\x94\xa8\xe6\x88\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\xe5\xba\
    \x94\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x9e\x01\x08\x1b\n\x0c\n\x04\x04\
    \x13\x02\0\x12\x04\x9f\x01\x02\x1c\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\
    \x9f\x01\x02\x10\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x9f\x01\x11\x17\n\r\
    \n\x05\x04\x13\x02\0\x03\x12\x04\x9f\x01\x1a\x1b\n\x1f\n\x04\x04\x13\x02\
    \x01\x12\x04\xa0\x01\x02\x14\"\x11\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\
    \x94\xaf\xe4\xb8\x80\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xa0\x01\x02\
    \x08\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xa0\x01\t\x0f\n\r\n\x05\x04\
    \x13\x02\x01\x03\x12\x04\xa0\x01\x12\x13\nN\n\x04\x04\x13\x02\x02\x12\
    \x04\xa1\x01\x02\"\"@\x20\xe6\xb3\xa8\xe5\x86\x8c\xe6\x97\xb6\xe9\x97\
    \xb4\x2013\xe4\xbd\x8d\xe6\x97\xb6\xe9\x97\xb4\xe6\x88\xb3\x20\xe5\xa6\
    \x82\xe6\x9e\x9c\xe4\xb8\x8d\xe4\xbc\xa0\x20\xe9\xbb\x98\xe8\xae\xa4\xe4\
    \xb8\xba\xe5\xbd\x93\xe5\x89\x8d\xe6\x97\xb6\xe9\x97\xb4\n\n\r\n\x05\x04\
    \x13\x02\x02\x04\x12\x04\xa1\x01\x02\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\
    \x04\xa1\x01\x0b\x10\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xa1\x01\x11\
    \x1d\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xa1\x01\x20!\n\x16\n\x04\x04\
    \x13\x02\x03\x12\x04\xa2\x01\x02\x1f\"\x08\x20\xe6\x98\xb5\xe7\xa7\xb0\n\
    \n\r\n\x05\x04\x13\x02\x03\x04\x12\x04\xa2\x01\x02\n\n\r\n\x05\x04\x13\
    \x02\x03\x05\x12\x04\xa2\x01\x0b\x11\n\r\n\x05\x04\x13\x02\x03\x01\x12\
    \x04\xa2\x01\x12\x1a\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xa2\x01\x1d\
    \x1e\n\x19\n\x04\x04\x13\x02\x04\x12\x04\xa3\x01\x02\x1d\"\x0b\x20\xe5\
    \xa4\xb4\xe5\x83\x8furl\n\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\xa3\x01\
    \x02\n\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\xa3\x01\x0b\x11\n\r\n\x05\
    \x04\x13\x02\x04\x01\x12\x04\xa3\x01\x12\x18\n\r\n\x05\x04\x13\x02\x04\
    \x03\x12\x04\xa3\x01\x1b\x1c\nJ\n\x04\x04\x13\x02\x05\x12\x04\xa5\x01\
    \x02%\"<\x20\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\
    \xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbepassword\xe3\x80\x81\
    email\xe3\x80\x81phone\xe7\xad\x89\xe7\xad\x89\n\n\r\n\x05\x04\x13\x02\
    \x05\x06\x12\x04\xa5\x01\x02\x15\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\
    \xa5\x01\x16\x20\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xa5\x01#$\nJ\n\
    \x04\x04\x13\x02\x06\x12\x04\xa6\x01\x02%\"<\x20\xe4\xb8\xaa\xe4\xba\xba\
    \xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\
    \x98\xe6\x94\xbe\xe6\x80\xa7\xe5\x88\xab\xe3\x80\x81\xe5\xb9\xb4\xe9\xbe\
    \x84\xe3\x80\x81\xe7\x94\x9f\xe6\x97\xa5\xe7\xad\x89\xe7\xad\x89\n\n\r\n\
    \x05\x04\x13\x02\x06\x06\x12\x04\xa6\x01\x02\x15\n\r\n\x05\x04\x13\x02\
    \x06\x01\x12\x04\xa6\x01\x16\x20\n\r\n\x05\x04\x13\x02\x06\x03\x12\x04\
    \xa6\x01#$\nJ\n\x04\x04\x13\x02\x07\x12\x04\xa7\x01\x02#\"<\x20\xe6\x89\
    \xa9\xe5\xb1\x95\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\
    \xbb\xa5\xe5\xad\x98\xe6\x94\xbe\xe7\xad\x89\xe7\xba\xa7\xe3\x80\x81\xe7\
    \xa7\xaf\xe5\x88\x86\xe3\x80\x81\xe9\x87\x91\xe5\xb8\x81\xe7\xad\x89\xe7\
    \xad\x89\n\n\r\n\x05\x04\x13\x02\x07\x06\x12\x04\xa7\x01\x02\x15\n\r\n\
    \x05\x04\x13\x02\x07\x01\x12\x04\xa7\x01\x16\x1e\n\r\n\x05\x04\x13\x02\
    \x07\x03\x12\x04\xa7\x01!\"\nW\n\x02\x04\x14\x12\x06\xad\x01\0\xb0\x01\
    \x01\x1a(GetUserInfoReq\x20\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\
    \xb7\xe4\xbf\xa1\xe6\x81\xaf\xe8\xaf\xb7\xe6\xb1\x82\n2\x1fGetUserInfo\
    \x20\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe4\xbf\xa1\xe6\x81\
    \xaf\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xad\x01\x08\x16\n\x0c\n\x04\x04\
    \x14\x02\0\x12\x04\xae\x01\x02\x1b\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\
    \xae\x01\x02\x0f\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xae\x01\x10\x16\n\r\
    \n\x05\x04\x14\x02\0\x03\x12\x04\xae\x01\x19\x1a\n\x1f\n\x04\x04\x14\x02\
    \x01\x12\x04\xaf\x01\x02\x14\"\x11\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\
    \x94\xaf\xe4\xb8\x80\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xaf\x01\x02\
    \x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xaf\x01\t\x0f\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xaf\x01\x12\x13\n7\n\x02\x04\x15\x12\x06\xb3\
    \x01\0\xbb\x01\x01\x1a)GetUserInfoResp\x20\xe8\x8e\xb7\xe5\x8f\x96\xe7\
    \x94\xa8\xe6\x88\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\xe5\xba\x94\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xb3\x01\x08\x17\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xb4\x01\x02\x1c\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\xb4\x01\x02\
    \x10\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xb4\x01\x11\x17\n\r\n\x05\x04\
    \x15\x02\0\x03\x12\x04\xb4\x01\x1a\x1b\n\x1f\n\x04\x04\x15\x02\x01\x12\
    \x04\xb5\x01\x02\x14\"\x11\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\
    \xe4\xb8\x80\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xb5\x01\x02\x08\n\r\
    \n\x05\x04\x15\x02\x01\x01\x12\x04\xb5\x01\t\x0f\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\xb5\x01\x12\x13\nN\n\x04\x04\x15\x02\x02\x12\x04\xb6\
    \x01\x02\"\"@\x20\xe6\xb3\xa8\xe5\x86\x8c\xe6\x97\xb6\xe9\x97\xb4\x2013\
    \xe4\xbd\x8d\xe6\x97\xb6\xe9\x97\xb4\xe6\x88\xb3\x20\xe5\xa6\x82\xe6\x9e\
    \x9c\xe4\xb8\x8d\xe4\xbc\xa0\x20\xe9\xbb\x98\xe8\xae\xa4\xe4\xb8\xba\xe5\
    \xbd\x93\xe5\x89\x8d\xe6\x97\xb6\xe9\x97\xb4\n\n\r\n\x05\x04\x15\x02\x02\
    \x04\x12\x04\xb6\x01\x02\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xb6\x01\
    \x0b\x10\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xb6\x01\x11\x1d\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\xb6\x01\x20!\n\x16\n\x04\x04\x15\x02\x03\
    \x12\x04\xb7\x01\x02\x1f\"\x08\x20\xe6\x98\xb5\xe7\xa7\xb0\n\n\r\n\x05\
    \x04\x15\x02\x03\x04\x12\x04\xb7\x01\x02\n\n\r\n\x05\x04\x15\x02\x03\x05\
    \x12\x04\xb7\x01\x0b\x11\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xb7\x01\
    \x12\x1a\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xb7\x01\x1d\x1e\n\x19\n\
    \x04\x04\x15\x02\x04\x12\x04\xb8\x01\x02\x1d\"\x0b\x20\xe5\xa4\xb4\xe5\
    \x83\x8furl\n\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\xb8\x01\x02\n\n\r\n\
    \x05\x04\x15\x02\x04\x05\x12\x04\xb8\x01\x0b\x11\n\r\n\x05\x04\x15\x02\
    \x04\x01\x12\x04\xb8\x01\x12\x18\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\
    \xb8\x01\x1b\x1c\nJ\n\x04\x04\x15\x02\x05\x12\x04\xba\x01\x02%\"<\x20\
    \xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\
    \xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbe\xe6\x80\xa7\xe5\x88\xab\xe3\x80\
    \x81\xe5\xb9\xb4\xe9\xbe\x84\xe3\x80\x81\xe7\x94\x9f\xe6\x97\xa5\xe7\xad\
    \x89\xe7\xad\x89\n\n\r\n\x05\x04\x15\x02\x05\x06\x12\x04\xba\x01\x02\x15\
    \n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xba\x01\x16\x20\n\r\n\x05\x04\x15\
    \x02\x05\x03\x12\x04\xba\x01#$\ns\n\x02\x04\x16\x12\x06\xc0\x01\0\xc4\
    \x01\x01\x1a6ResetUserAccountMapReq\x20\xe9\x87\x8d\xe7\xbd\xae\xe7\x94\
    \xa8\xe6\x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe8\xaf\
    \xb7\xe6\xb1\x82\n2-ResetUserAccountMap\x20\xe9\x87\x8d\xe7\xbd\xae\xe7\
    \x94\xa8\xe6\x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\n\n\
    \x0b\n\x03\x04\x16\x01\x12\x04\xc0\x01\x08\x1e\n\x0c\n\x04\x04\x16\x02\0\
    \x12\x04\xc1\x01\x02\x1b\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xc1\x01\x02\
    \x0f\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xc1\x01\x10\x16\n\r\n\x05\x04\
    \x16\x02\0\x03\x12\x04\xc1\x01\x19\x1a\nJ\n\x04\x04\x16\x02\x01\x12\x04\
    \xc2\x01\x02%\"<\x20\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\x20\
    \xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xad\x98\xe6\x94\xbepassword\xe3\
    \x80\x81email\xe3\x80\x81phone\xe7\xad\x89\xe7\xad\x89\n\n\r\n\x05\x04\
    \x16\x02\x01\x06\x12\x04\xc2\x01\x02\x15\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\xc2\x01\x16\x20\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xc2\x01#$\
    \nE\n\x04\x04\x16\x02\x02\x12\x04\xc3\x01\x02$\"7\x20\xe9\xaa\x8c\xe8\
    \xaf\x81\xe4\xbf\xa1\xe6\x81\xaf\x20\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\
    \xe5\xad\x98\xe6\x94\xbesmsCode\xe3\x80\x81emailCode\xe7\xad\x89\xe7\xad\
    \x89\n\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\xc3\x01\x02\x15\n\r\n\x05\
    \x04\x16\x02\x02\x01\x12\x04\xc3\x01\x16\x1f\n\r\n\x05\x04\x16\x02\x02\
    \x03\x12\x04\xc3\x01\"#\nE\n\x02\x04\x17\x12\x06\xc7\x01\0\xc9\x01\x01\
    \x1a7ResetUserAccountMapResp\x20\xe9\x87\x8d\xe7\xbd\xae\xe7\x94\xa8\xe6\
    \x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe5\x93\x8d\xe5\
    \xba\x94\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xc7\x01\x08\x1f\n\x0c\n\x04\
    \x04\x17\x02\0\x12\x04\xc8\x01\x02\x1c\n\r\n\x05\x04\x17\x02\0\x06\x12\
    \x04\xc8\x01\x02\x10\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc8\x01\x11\x17\
    \n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xc8\x01\x1a\x1b\n`\n\x02\x04\x18\
    \x12\x06\xce\x01\0\xd0\x01\x01\x1a,UserAfterOnlineReq\x20\xe7\x94\xa8\
    \xe6\x88\xb7\xe4\xb8\x8a\xe7\xba\xbf\xe5\x9b\x9e\xe8\xb0\x83\xe8\xaf\xb7\
    \xe6\xb1\x82\n2$\x20UserAfterOnline\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\
    \x8a\xe7\xba\xbf\xe5\x9b\x9e\xe8\xb0\x83\n\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xce\x01\x08\x1a\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xcf\x01\x02\x1b\n\
    \r\n\x05\x04\x18\x02\0\x06\x12\x04\xcf\x01\x02\x0f\n\r\n\x05\x04\x18\x02\
    \0\x01\x12\x04\xcf\x01\x10\x16\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xcf\
    \x01\x19\x1a\n;\n\x02\x04\x19\x12\x06\xd3\x01\0\xd5\x01\x01\x1a-UserAfte\
    rOnlineResp\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8a\xe7\xba\xbf\xe5\x9b\
    \x9e\xe8\xb0\x83\xe5\x93\x8d\xe5\xba\x94\n\n\x0b\n\x03\x04\x19\x01\x12\
    \x04\xd3\x01\x08\x1b\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xd4\x01\x02\x1c\n\
    \r\n\x05\x04\x19\x02\0\x06\x12\x04\xd4\x01\x02\x10\n\r\n\x05\x04\x19\x02\
    \0\x01\x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xd4\
    \x01\x1a\x1b\na\n\x02\x04\x1a\x12\x06\xda\x01\0\xdd\x01\x01\x1a-UserAfte\
    rOfflineReq\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8b\xe7\xba\xbf\xe5\x9b\
    \x9e\xe8\xb0\x83\xe8\xaf\xb7\xe6\xb1\x82\n2$UserAfterOffline\x20\xe7\x94\
    \xa8\xe6\x88\xb7\xe4\xb8\x8b\xe7\xba\xbf\xe5\x9b\x9e\xe8\xb0\x83\n\n\x0b\
    \n\x03\x04\x1a\x01\x12\x04\xda\x01\x08\x1b\n\x0c\n\x04\x04\x1a\x02\0\x12\
    \x04\xdb\x01\x02\x1b\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xdb\x01\x02\x0f\
    \n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xdb\x01\x10\x16\n\r\n\x05\x04\x1a\
    \x02\0\x03\x12\x04\xdb\x01\x19\x1a\n\x1f\n\x04\x04\x1a\x02\x01\x12\x04\
    \xdc\x01\x02\x14\"\x11\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\xe4\
    \xb8\x80\n\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xdc\x01\x02\x08\n\r\n\
    \x05\x04\x1a\x02\x01\x01\x12\x04\xdc\x01\t\x0f\n\r\n\x05\x04\x1a\x02\x01\
    \x03\x12\x04\xdc\x01\x12\x13\n<\n\x02\x04\x1b\x12\x06\xe0\x01\0\xe2\x01\
    \x01\x1a.UserAfterOfflineResp\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8b\
    \xe7\xba\xbf\xe5\x9b\x9e\xe8\xb0\x83\xe5\x93\x8d\xe5\xba\x94\n\n\x0b\n\
    \x03\x04\x1b\x01\x12\x04\xe0\x01\x08\x1c\n\x0c\n\x04\x04\x1b\x02\0\x12\
    \x04\xe1\x01\x02\x1c\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xe1\x01\x02\x10\
    \n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\xe1\x01\x1a\x1b\nl\n\x02\x04\x1c\x12\x06\xe7\x01\0\
    \xeb\x01\x01\x1a1UserBeforeConnectReq\x20\xe6\x9c\x8d\xe5\x8a\xa1\xe7\
    \xab\xaf\xe8\xbf\x9e\xe6\x8e\xa5\xe5\x89\x8d\xe7\x9a\x84\xe5\x9b\x9e\xe8\
    \xb0\x83\n2+UserBeforeConnect\x20\xe7\x94\xa8\xe6\x88\xb7\xe8\xbf\x9e\
    \xe6\x8e\xa5\xe5\x89\x8d\xe7\x9a\x84\xe5\x9b\x9e\xe8\xb0\x83\n\n\x0b\n\
    \x03\x04\x1c\x01\x12\x04\xe7\x01\x08\x1c\n\x0c\n\x04\x04\x1c\x02\0\x12\
    \x04\xe8\x01\x02\x1b\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xe8\x01\x02\x0f\
    \n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe8\x01\x10\x16\n\r\n\x05\x04\x1c\
    \x02\0\x03\x12\x04\xe8\x01\x19\x1a\n\x1f\n\x04\x04\x1c\x02\x01\x12\x04\
    \xe9\x01\x02\x14\"\x11\x20\xe7\x94\xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\xe4\
    \xb8\x80\n\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xe9\x01\x02\x08\n\r\n\
    \x05\x04\x1c\x02\x01\x01\x12\x04\xe9\x01\t\x0f\n\r\n\x05\x04\x1c\x02\x01\
    \x03\x12\x04\xe9\x01\x12\x13\n\x1b\n\x04\x04\x1c\x02\x02\x12\x04\xea\x01\
    \x02\x13\"\r\x20\xe7\x94\xa8\xe6\x88\xb7token\n\n\r\n\x05\x04\x1c\x02\
    \x02\x05\x12\x04\xea\x01\x02\x08\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\
    \xea\x01\t\x0e\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xea\x01\x11\x12\n@\
    \n\x02\x04\x1d\x12\x06\xee\x01\0\xf7\x01\x01\x1a2UserBeforeConnectResp\
    \x20\xe6\x9c\x8d\xe5\x8a\xa1\xe7\xab\xaf\xe8\xbf\x9e\xe6\x8e\xa5\xe5\x89\
    \x8d\xe7\x9a\x84\xe5\x9b\x9e\xe8\xb0\x83\n\n\x0b\n\x03\x04\x1d\x01\x12\
    \x04\xee\x01\x08\x1d\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xef\x01\x02\x1c\n\
    \r\n\x05\x04\x1d\x02\0\x06\x12\x04\xef\x01\x02\x10\n\r\n\x05\x04\x1d\x02\
    \0\x01\x12\x04\xef\x01\x11\x17\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xef\
    \x01\x1a\x1b\n(\n\x04\x04\x1d\x02\x01\x12\x04\xf1\x01\x02\x13\x1a\x1a\
    \x20\xe6\x98\xaf\xe5\x90\xa6\xe5\x85\x81\xe8\xae\xb8\xe5\xbb\xba\xe7\xab\
    \x8b\xe8\xbf\x9e\xe6\x8e\xa5\n\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xf1\
    \x01\x02\x06\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xf1\x01\x07\x0e\n\r\n\
    \x05\x04\x1d\x02\x01\x03\x12\x04\xf1\x01\x11\x12\n@\n\x04\x04\x1d\x02\
    \x02\x12\x04\xf3\x01\x02)\x1a2\x20\xe5\xa6\x82\xe6\x9e\x9c\xe4\xb8\x8d\
    \xe5\x85\x81\xe8\xae\xb8\xe5\xbb\xba\xe7\xab\x8b\xe8\xbf\x9e\xe6\x8e\xa5\
    \xef\xbc\x8c\xe8\xbf\x94\xe5\x9b\x9e\xe7\x9a\x84\xe9\x94\x99\xe8\xaf\xaf\
    \xe7\xa0\x81\n\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\xf3\x01\x02\x1a\n\r\
    \n\x05\x04\x1d\x02\x02\x01\x12\x04\xf3\x01\x1b$\n\r\n\x05\x04\x1d\x02\
    \x02\x03\x12\x04\xf3\x01'(\nC\n\x04\x04\x1d\x02\x03\x12\x04\xf5\x01\x02\
    \x19\x1a5\x20\xe5\xa6\x82\xe6\x9e\x9c\xe4\xb8\x8d\xe5\x85\x81\xe8\xae\
    \xb8\xe5\xbb\xba\xe7\xab\x8b\xe8\xbf\x9e\xe6\x8e\xa5\xef\xbc\x8c\xe8\xbf\
    \x94\xe5\x9b\x9e\xe7\x9a\x84\xe9\x94\x99\xe8\xaf\xaf\xe4\xbf\xa1\xe6\x81\
    \xaf\n\n\r\n\x05\x04\x1d\x02\x03\x05\x12\x04\xf5\x01\x02\x08\n\r\n\x05\
    \x04\x1d\x02\x03\x01\x12\x04\xf5\x01\t\x14\n\r\n\x05\x04\x1d\x02\x03\x03\
    \x12\x04\xf5\x01\x17\x18\n*\n\x04\x04\x1d\x02\x04\x12\x04\xf6\x01\x02\
    \x14\"\x1c\x20\xe6\x88\x90\xe5\x8a\x9f\xe7\x9a\x84\xe8\xaf\x9d\xe8\xbf\
    \x94\xe5\x9b\x9e\xe7\x94\xa8\xe6\x88\xb7id\n\n\r\n\x05\x04\x1d\x02\x04\
    \x05\x12\x04\xf6\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\xf6\
    \x01\t\x0f\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\xf6\x01\x12\x13\no\n\
    \x02\x04\x1e\x12\x06\xfc\x01\0\xff\x01\x01\x1a4UserBeforeRequestReq\x20\
    \xe7\x94\xa8\xe6\x88\xb7\xe8\xaf\xb7\xe6\xb1\x82\xe5\x89\x8d\xe7\x9a\x84\
    \xe5\x9b\x9e\xe8\xb0\x83\xe8\xaf\xb7\xe6\xb1\x82\n2+UserBeforeRequest\
    \x20\xe7\x94\xa8\xe6\x88\xb7\xe8\xaf\xb7\xe6\xb1\x82\xe5\x89\x8d\xe7\x9a\
    \x84\xe5\x9b\x9e\xe8\xb0\x83\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xfc\x01\
    \x08\x1c\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xfd\x01\x02\x1b\n\r\n\x05\x04\
    \x1e\x02\0\x06\x12\x04\xfd\x01\x02\x0f\n\r\n\x05\x04\x1e\x02\0\x01\x12\
    \x04\xfd\x01\x10\x16\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xfd\x01\x19\x1a\
    \n\x1c\n\x04\x04\x1e\x02\x01\x12\x04\xfe\x01\x02\x12\"\x0e\x20\xe8\xaf\
    \xb7\xe6\xb1\x82\xe8\xb7\xaf\xe5\xbe\x84\n\n\r\n\x05\x04\x1e\x02\x01\x05\
    \x12\x04\xfe\x01\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xfe\x01\t\
    \r\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xfe\x01\x10\x11\nC\n\x02\x04\
    \x1f\x12\x06\x82\x02\0\x85\x02\x01\x1a5UserBeforeRequestResp\x20\xe7\x94\
    \xa8\xe6\x88\xb7\xe8\xaf\xb7\xe6\xb1\x82\xe5\x89\x8d\xe7\x9a\x84\xe5\x9b\
    \x9e\xe8\xb0\x83\xe5\x93\x8d\xe5\xba\x94\n\n\x0b\n\x03\x04\x1f\x01\x12\
    \x04\x82\x02\x08\x1d\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x83\x02\x02\x1c\n\
    \r\n\x05\x04\x1f\x02\0\x06\x12\x04\x83\x02\x02\x10\n\r\n\x05\x04\x1f\x02\
    \0\x01\x12\x04\x83\x02\x11\x17\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x83\
    \x02\x1a\x1b\n\x18\n\x04\x04\x1f\x02\x01\x12\x04\x84\x02\x02\x14\"\n\x20\
    \xe7\x94\xa8\xe6\x88\xb7id\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\x84\
    \x02\x02\x08\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x84\x02\t\x0f\n\r\n\
    \x05\x04\x1f\x02\x01\x03\x12\x04\x84\x02\x12\x13\ne\n\x02\x04\x20\x12\
    \x06\x8a\x02\0\x8c\x02\x01\x1a/UserAfterKeepAliveReq\x20\xe7\x94\xa8\xe6\
    \x88\xb7\xe4\xbf\x9d\xe6\xb4\xbb\xe5\x9b\x9e\xe8\xb0\x83\xe8\xaf\xb7\xe6\
    \xb1\x82\n2&UserAfterKeepAlive\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xbf\x9d\
    \xe6\xb4\xbb\xe5\x9b\x9e\xe8\xb0\x83\n\n\x0b\n\x03\x04\x20\x01\x12\x04\
    \x8a\x02\x08\x1d\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x8b\x02\x02\x1b\n\r\n\
    \x05\x04\x20\x02\0\x06\x12\x04\x8b\x02\x02\x0f\n\r\n\x05\x04\x20\x02\0\
    \x01\x12\x04\x8b\x02\x10\x16\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x8b\x02\
    \x19\x1a\n>\n\x02\x04!\x12\x06\x8f\x02\0\x91\x02\x01\x1a0UserAfterKeepAl\
    iveResp\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xbf\x9d\xe6\xb4\xbb\xe5\x9b\x9e\
    \xe8\xb0\x83\xe5\x93\x8d\xe5\xba\x94\n\n\x0b\n\x03\x04!\x01\x12\x04\x8f\
    \x02\x08\x1e\n\x0c\n\x04\x04!\x02\0\x12\x04\x90\x02\x02\x1c\n\r\n\x05\
    \x04!\x02\0\x06\x12\x04\x90\x02\x02\x10\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \x90\x02\x11\x17\n\r\n\x05\x04!\x02\0\x03\x12\x04\x90\x02\x1a\x1b\nQ\n\
    \x02\x04\"\x12\x06\x96\x02\0\x9b\x02\x01\x1a%CreateRobotReq\x20\xe5\x88\
    \x9b\xe5\xbb\xba\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xba\xe8\xaf\xb7\xe6\xb1\
    \x82\n2\x1cCreateRobot\x20\xe5\x88\x9b\xe5\xbb\xba\xe6\x9c\xba\xe5\x99\
    \xa8\xe4\xba\xba\n\n\x0b\n\x03\x04\"\x01\x12\x04\x96\x02\x08\x16\n\x0c\n\
    \x04\x04\"\x02\0\x12\x04\x97\x02\x02\x1b\n\r\n\x05\x04\"\x02\0\x06\x12\
    \x04\x97\x02\x02\x0f\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x97\x02\x10\x16\n\
    \r\n\x05\x04\"\x02\0\x03\x12\x04\x97\x02\x19\x1a\n\"\n\x04\x04\"\x02\x01\
    \x12\x04\x98\x02\x02\x15\"\x14\x20\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xbaid\
    \x20\xe5\x94\xaf\xe4\xb8\x80\n\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x98\
    \x02\x02\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x98\x02\t\x10\n\r\n\x05\
    \x04\"\x02\x01\x03\x12\x04\x98\x02\x13\x14\n\x16\n\x04\x04\"\x02\x02\x12\
    \x04\x99\x02\x02\x1f\"\x08\x20\xe6\x98\xb5\xe7\xa7\xb0\n\n\r\n\x05\x04\"\
    \x02\x02\x04\x12\x04\x99\x02\x02\n\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\
    \x99\x02\x0b\x11\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\x99\x02\x12\x1a\n\r\
    \n\x05\x04\"\x02\x02\x03\x12\x04\x99\x02\x1d\x1e\n\x19\n\x04\x04\"\x02\
    \x03\x12\x04\x9a\x02\x02\x1d\"\x0b\x20\xe5\xa4\xb4\xe5\x83\x8furl\n\n\r\
    \n\x05\x04\"\x02\x03\x04\x12\x04\x9a\x02\x02\n\n\r\n\x05\x04\"\x02\x03\
    \x05\x12\x04\x9a\x02\x0b\x11\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\x9a\x02\
    \x12\x18\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\x9a\x02\x1b\x1c\n4\n\x02\
    \x04#\x12\x06\x9e\x02\0\xa1\x02\x01\x1a&CreateRobotResp\x20\xe5\x88\x9b\
    \xe5\xbb\xba\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xba\xe5\x93\x8d\xe5\xba\x94\
    \n\n\x0b\n\x03\x04#\x01\x12\x04\x9e\x02\x08\x17\n\x0c\n\x04\x04#\x02\0\
    \x12\x04\x9f\x02\x02\x1c\n\r\n\x05\x04#\x02\0\x06\x12\x04\x9f\x02\x02\
    \x10\n\r\n\x05\x04#\x02\0\x01\x12\x04\x9f\x02\x11\x17\n\r\n\x05\x04#\x02\
    \0\x03\x12\x04\x9f\x02\x1a\x1b\n\x1e\n\x04\x04#\x02\x01\x12\x04\xa0\x02\
    \x02\x19\"\x10\x20\xe6\x9c\xba\xe5\x99\xa8\xe4\xba\xbatoken\n\n\r\n\x05\
    \x04#\x02\x01\x05\x12\x04\xa0\x02\x02\x08\n\r\n\x05\x04#\x02\x01\x01\x12\
    \x04\xa0\x02\t\x14\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xa0\x02\x17\x18\nY\
    \n\x02\x04$\x12\x06\xa6\x02\0\xaf\x02\x01\x1a)GetUserModelReq\x20\xe8\
    \x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\x8b\xe8\
    \xaf\xb7\xe6\xb1\x82\n2\x20GetUserModel\x20\xe8\x8e\xb7\xe5\x8f\x96\xe7\
    \x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\x8b\n\n\x0b\n\x03\x04$\x01\x12\
    \x04\xa6\x02\x08\x1b\n\x0c\n\x04\x04$\x02\0\x12\x04\xa7\x02\x02\x1b\n\r\
    \n\x05\x04$\x02\0\x06\x12\x04\xa7\x02\x02\x0f\n\r\n\x05\x04$\x02\0\x01\
    \x12\x04\xa7\x02\x10\x16\n\r\n\x05\x04$\x02\0\x03\x12\x04\xa7\x02\x19\
    \x1a\n\x1f\n\x04\x04$\x02\x01\x12\x04\xa8\x02\x02\x14\"\x11\x20\xe7\x94\
    \xa8\xe6\x88\xb7id\x20\xe5\x94\xaf\xe4\xb8\x80\n\n\r\n\x05\x04$\x02\x01\
    \x05\x12\x04\xa8\x02\x02\x08\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xa8\x02\
    \t\x0f\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xa8\x02\x12\x13\n\x0e\n\x04\
    \x04$\x03\0\x12\x06\xa9\x02\x02\xad\x02\x03\n\r\n\x05\x04$\x03\0\x01\x12\
    \x04\xa9\x02\n\r\n0\n\x06\x04$\x03\0\x02\0\x12\x04\xab\x02\x04\x1e\x1a\
    \x20\x20\xe6\x98\xaf\xe5\x90\xa6\xe6\x90\xba\xe5\xb8\xa6\xe7\x94\xa8\xe6\
    \x88\xb7\xe8\xae\xbe\xe7\xbd\xae\xe5\x88\x97\xe8\xa1\xa8\n\n\x0f\n\x07\
    \x04$\x03\0\x02\0\x05\x12\x04\xab\x02\x04\x08\n\x0f\n\x07\x04$\x03\0\x02\
    \0\x01\x12\x04\xab\x02\t\x19\n\x0f\n\x07\x04$\x03\0\x02\0\x03\x12\x04\
    \xab\x02\x1c\x1d\nY\n\x06\x04$\x03\0\x02\x01\x12\x04\xac\x02\x04(\"I\x20\
    \xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xbe\xe7\xbd\xaekey\xe5\x88\x97\xe8\xa1\
    \xa8\x20\xe5\xa6\x82\xe6\x9e\x9cwithUserSettings\xe4\xb8\xbafalse\x20\
    \xe5\x88\x99\xe8\xaf\xa5\xe5\xad\x97\xe6\xae\xb5\xe6\x97\xa0\xe6\x95\x88\
    \n\n\x0f\n\x07\x04$\x03\0\x02\x01\x04\x12\x04\xac\x02\x04\x0c\n\x0f\n\
    \x07\x04$\x03\0\x02\x01\x05\x12\x04\xac\x02\r\x13\n\x0f\n\x07\x04$\x03\0\
    \x02\x01\x01\x12\x04\xac\x02\x14#\n\x0f\n\x07\x04$\x03\0\x02\x01\x03\x12\
    \x04\xac\x02&'\n\x0c\n\x04\x04$\x02\x02\x12\x04\xae\x02\x02\x17\n\r\n\
    \x05\x04$\x02\x02\x04\x12\x04\xae\x02\x02\n\n\r\n\x05\x04$\x02\x02\x06\
    \x12\x04\xae\x02\x0b\x0e\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xae\x02\x0f\
    \x12\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xae\x02\x15\x16\n<\n\x02\x04%\
    \x12\x06\xb2\x02\0\xb6\x02\x01\x1a.GetUserModelByIdResp\x20\xe8\x8e\xb7\
    \xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x93\x8d\
    \xe5\xba\x94\n\n\x0b\n\x03\x04%\x01\x12\x04\xb2\x02\x08\x1c\n\x0c\n\x04\
    \x04%\x02\0\x12\x04\xb3\x02\x02\x1c\n\r\n\x05\x04%\x02\0\x06\x12\x04\xb3\
    \x02\x02\x10\n\r\n\x05\x04%\x02\0\x01\x12\x04\xb3\x02\x11\x17\n\r\n\x05\
    \x04%\x02\0\x03\x12\x04\xb3\x02\x1a\x1b\n\x20\n\x04\x04%\x02\x01\x12\x04\
    \xb4\x02\x02\x1a\"\x12\x20\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\
    \x8bjson\n\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xb4\x02\x02\x07\n\r\n\x05\
    \x04%\x02\x01\x01\x12\x04\xb4\x02\x08\x15\n\r\n\x05\x04%\x02\x01\x03\x12\
    \x04\xb4\x02\x18\x19\nN\n\x04\x04%\x02\x02\x12\x04\xb5\x02\x02\x1d\"@\
    \x20\xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xbe\xe7\xbd\xaejson\x20\xe4\xbb\x96\
    \xe6\x98\xafmap[string]usermodel.UserSetting\xe7\x9a\x84json\n\n\r\n\x05\
    \x04%\x02\x02\x05\x12\x04\xb5\x02\x02\x07\n\r\n\x05\x04%\x02\x02\x01\x12\
    \x04\xb5\x02\x08\x18\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xb5\x02\x1b\x1c\
    \nB\n\x02\x04&\x12\x06\xb9\x02\0\xc2\x02\x01\x1a4GetUserModelByIdsReq\
    \x20\xe6\x89\xb9\xe9\x87\x8f\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\
    \xb7\xe6\xa8\xa1\xe5\x9e\x8b\xe8\xaf\xb7\xe6\xb1\x82\n\n\x0b\n\x03\x04&\
    \x01\x12\x04\xb9\x02\x08\x1c\n\x0c\n\x04\x04&\x02\0\x12\x04\xba\x02\x02\
    \x1b\n\r\n\x05\x04&\x02\0\x06\x12\x04\xba\x02\x02\x0f\n\r\n\x05\x04&\x02\
    \0\x01\x12\x04\xba\x02\x10\x16\n\r\n\x05\x04&\x02\0\x03\x12\x04\xba\x02\
    \x19\x1a\n\x1e\n\x04\x04&\x02\x01\x12\x04\xbb\x02\x02\x1e\"\x10\x20\xe7\
    \x94\xa8\xe6\x88\xb7id\xe5\x88\x97\xe8\xa1\xa8\n\n\r\n\x05\x04&\x02\x01\
    \x04\x12\x04\xbb\x02\x02\n\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xbb\x02\
    \x0b\x11\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xbb\x02\x12\x19\n\r\n\x05\
    \x04&\x02\x01\x03\x12\x04\xbb\x02\x1c\x1d\n\x0e\n\x04\x04&\x03\0\x12\x06\
    \xbc\x02\x02\xc0\x02\x03\n\r\n\x05\x04&\x03\0\x01\x12\x04\xbc\x02\n\r\n0\
    \n\x06\x04&\x03\0\x02\0\x12\x04\xbe\x02\x04\x1e\x1a\x20\x20\xe6\x98\xaf\
    \xe5\x90\xa6\xe6\x90\xba\xe5\xb8\xa6\xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xbe\
    \xe7\xbd\xae\xe5\x88\x97\xe8\xa1\xa8\n\n\x0f\n\x07\x04&\x03\0\x02\0\x05\
    \x12\x04\xbe\x02\x04\x08\n\x0f\n\x07\x04&\x03\0\x02\0\x01\x12\x04\xbe\
    \x02\t\x19\n\x0f\n\x07\x04&\x03\0\x02\0\x03\x12\x04\xbe\x02\x1c\x1d\nY\n\
    \x06\x04&\x03\0\x02\x01\x12\x04\xbf\x02\x04(\"I\x20\xe7\x94\xa8\xe6\x88\
    \xb7\xe8\xae\xbe\xe7\xbd\xaekey\xe5\x88\x97\xe8\xa1\xa8\x20\xe5\xa6\x82\
    \xe6\x9e\x9cwithUserSettings\xe4\xb8\xbafalse\x20\xe5\x88\x99\xe8\xaf\
    \xa5\xe5\xad\x97\xe6\xae\xb5\xe6\x97\xa0\xe6\x95\x88\n\n\x0f\n\x07\x04&\
    \x03\0\x02\x01\x04\x12\x04\xbf\x02\x04\x0c\n\x0f\n\x07\x04&\x03\0\x02\
    \x01\x05\x12\x04\xbf\x02\r\x13\n\x0f\n\x07\x04&\x03\0\x02\x01\x01\x12\
    \x04\xbf\x02\x14#\n\x0f\n\x07\x04&\x03\0\x02\x01\x03\x12\x04\xbf\x02&'\n\
    \x0c\n\x04\x04&\x02\x02\x12\x04\xc1\x02\x02\x17\n\r\n\x05\x04&\x02\x02\
    \x04\x12\x04\xc1\x02\x02\n\n\r\n\x05\x04&\x02\x02\x06\x12\x04\xc1\x02\
    \x0b\x0e\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xc1\x02\x0f\x12\n\r\n\x05\
    \x04&\x02\x02\x03\x12\x04\xc1\x02\x15\x16\nC\n\x02\x04'\x12\x06\xc5\x02\
    \0\xc9\x02\x01\x1a5GetUserModelByIdsResp\x20\xe6\x89\xb9\xe9\x87\x8f\xe8\
    \x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\x8b\xe5\
    \x93\x8d\xe5\xba\x94\n\n\x0b\n\x03\x04'\x01\x12\x04\xc5\x02\x08\x1d\n\
    \x0c\n\x04\x04'\x02\0\x12\x04\xc6\x02\x02\x1c\n\r\n\x05\x04'\x02\0\x06\
    \x12\x04\xc6\x02\x02\x10\n\r\n\x05\x04'\x02\0\x01\x12\x04\xc6\x02\x11\
    \x17\n\r\n\x05\x04'\x02\0\x03\x12\x04\xc6\x02\x1a\x1b\n&\n\x04\x04'\x02\
    \x01\x12\x04\xc7\x02\x02(\"\x18\x20\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\
    \xe5\x9e\x8bjson\xe5\x88\x97\xe8\xa1\xa8\n\n\r\n\x05\x04'\x02\x01\x06\
    \x12\x04\xc7\x02\x02\x14\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xc7\x02\x15#\
    \n\r\n\x05\x04'\x02\x01\x03\x12\x04\xc7\x02&'\nV\n\x04\x04'\x02\x02\x12\
    \x04\xc8\x02\x02+\"H\x20\xe7\x94\xa8\xe6\x88\xb7\xe8\xae\xbe\xe7\xbd\xae\
    json\xe5\x88\x97\xe8\xa1\xa8\x20value\xe6\x98\xafmap[string]usermodel.Us\
    erSetting\xe7\x9a\x84json\n\n\r\n\x05\x04'\x02\x02\x06\x12\x04\xc8\x02\
    \x02\x14\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xc8\x02\x15&\n\r\n\x05\x04'\
    \x02\x02\x03\x12\x04\xc8\x02)*\n\x0c\n\x02\x06\0\x12\x06\xcb\x02\0\xe4\
    \x02\x01\n\x0b\n\x03\x06\0\x01\x12\x04\xcb\x02\x08\x16\n\x91\x01\n\x04\
    \x06\0\x02\0\x12\x04\xce\x02\x02?\x1a\x82\x01UserRegister\x20\xe7\x94\
    \xa8\xe6\x88\xb7\xe6\xb3\xa8\xe5\x86\x8c\n\xe4\xba\x8c\xe6\xac\xa1\xe5\
    \xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe4\
    \xbc\xa0\xe9\x80\x92\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe5\x8f\x82\xe6\
    \x95\xb0\x20\xe5\xa6\x82\xe6\x9e\x9c\xe4\xb8\x8d\xe6\xbb\xa1\xe8\xb6\xb3\
    \xe4\xbd\xa0\xe7\x9a\x84\xe9\x9c\x80\xe6\xb1\x82\x20\xe4\xbd\xa0\xe5\x8f\
    \xaf\xe4\xbb\xa5\xe4\xbf\xae\xe6\x94\xb9\xe8\xaf\xa5proto\xe6\x96\x87\
    \xe4\xbb\xb6\n\n\r\n\x05\x06\0\x02\0\x01\x12\x04\xce\x02\x06\x12\n\r\n\
    \x05\x06\0\x02\0\x02\x12\x04\xce\x02\x13\"\n\r\n\x05\x06\0\x02\0\x03\x12\
    \x04\xce\x02-=\nI\n\x04\x06\0\x02\x01\x12\x04\xd1\x02\x02<\x1a;UserDestr\
    oy\x20\xe7\x94\xa8\xe6\x88\xb7\xe6\xb3\xa8\xe9\x94\x80\n\xe6\xb3\xa8\xe9\
    \x94\x80\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\
    \xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\0\x02\x01\
    \x01\x12\x04\xd1\x02\x06\x11\n\r\n\x05\x06\0\x02\x01\x02\x12\x04\xd1\x02\
    \x12\x20\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\xd1\x02+:\nm\n\x04\x06\0\
    \x02\x02\x12\x04\xd4\x02\x02H\x1a_UserAccessToken\x20\xe7\x94\xa8\xe6\
    \x88\xb7\xe7\x99\xbb\xe5\xbd\x95\n\xe7\x99\xbb\xe5\xbd\x95\xe9\x80\xbb\
    \xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\
    \xe4\xbf\xae\xe6\x94\xb9\x20\xe9\xbb\x98\xe8\xae\xa4\xe6\x98\xaf\xe5\xaf\
    \x86\xe7\xa0\x81/\xe6\x89\x8b\xe6\x9c\xba\xe5\x8f\xb7\xe7\x99\xbb\xe5\
    \xbd\x95\n\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\xd4\x02\x06\x15\n\r\n\x05\
    \x06\0\x02\x02\x02\x12\x04\xd4\x02\x16(\n\r\n\x05\x06\0\x02\x02\x03\x12\
    \x04\xd4\x023F\nY\n\x04\x06\0\x02\x03\x12\x04\xd7\x02\x02]\x1aKRefreshUs\
    erAccessToken\x20\xe5\x88\xb7\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7token\n\
    \xe5\x88\xb7\xe6\x96\xb0\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\
    \xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\
    \x06\0\x02\x03\x01\x12\x04\xd7\x02\x06\x1c\n\r\n\x05\x06\0\x02\x03\x02\
    \x12\x04\xd7\x02\x1d6\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\xd7\x02A[\nX\n\
    \x04\x06\0\x02\x04\x12\x04\xda\x02\x02Z\x1aJRevokeUserAccessToken\x20\
    \xe6\xb3\xa8\xe9\x94\x80\xe7\x94\xa8\xe6\x88\xb7token\n\xe6\xb3\xa8\xe9\
    \x94\x80\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\
    \xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\0\x02\x04\
    \x01\x12\x04\xda\x02\x06\x1b\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\xda\x02\
    \x1c4\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\xda\x02?X\n\xf3\x01\n\x04\x06\
    \0\x02\x05\x12\x04\xdd\x02\x02W\x1a\xe4\x01UpdateUserAccountMap\x20\xe6\
    \x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\
    \xbf\xa1\xe6\x81\xaf\n\xe6\x9b\xb4\xe6\x96\xb0\xe8\xb4\xa6\xe5\x8f\xb7\
    \xe4\xbf\xa1\xe6\x81\xaf\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\
    \xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\x20\xe9\xbb\
    \x98\xe8\xae\xa4\xef\xbc\x9a\xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe4\xbf\
    \xae\xe6\x94\xb9\xe5\xaf\x86\xe7\xa0\x81\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\
    \x81\xe6\x97\xa7\xe5\xaf\x86\xe7\xa0\x81\xe6\x88\x96\xe6\x89\x8b\xe6\x9c\
    \xba\xe9\xaa\x8c\xe8\xaf\x81\xe7\xa0\x81\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\
    \x9c\xe4\xbf\xae\xe6\x94\xb9\xe7\xbb\x91\xe5\xae\x9a\xe6\x89\x8b\xe6\x9c\
    \xba\xe5\x8f\xb7\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\x81\xe9\xaa\x8c\xe8\xaf\
    \x81\xe6\x96\xb0\xe6\x89\x8b\xe6\x9c\xba\xe5\x8f\xb7\xe7\x9a\x84\xe9\xaa\
    \x8c\xe8\xaf\x81\xe7\xa0\x81\n\n\r\n\x05\x06\0\x02\x05\x01\x12\x04\xdd\
    \x02\x06\x1a\n\r\n\x05\x06\0\x02\x05\x02\x12\x04\xdd\x02\x1b2\n\r\n\x05\
    \x06\0\x02\x05\x03\x12\x04\xdd\x02=U\ni\n\x04\x06\0\x02\x06\x12\x04\xe0\
    \x02\x02T\x1a[ResetUserAccountMap\x20\xe9\x87\x8d\xe7\xbd\xae\xe7\x94\
    \xa8\xe6\x88\xb7\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\n\xe9\
    \x87\x8d\xe7\xbd\xae\xe8\xb4\xa6\xe5\x8f\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe9\
    \x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\
    \x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\
    \xe0\x02\x06\x19\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\xe0\x02\x1a0\n\r\n\
    \x05\x06\0\x02\x06\x03\x12\x04\xe0\x02;R\nU\n\x04\x06\0\x02\x07\x12\x04\
    \xe3\x02\x02<\x1aGCreateRobot\x20\xe5\x88\x9b\xe5\xbb\xba\xe6\x9c\xba\
    \xe5\x99\xa8\xe4\xba\xba\n\xe5\x88\x9b\xe5\xbb\xba\xe6\x9c\xba\xe5\x99\
    \xa8\xe4\xba\xba\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\
    \x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\0\
    \x02\x07\x01\x12\x04\xe3\x02\x06\x11\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\
    \xe3\x02\x12\x20\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\xe3\x02+:\n\x0c\n\
    \x02\x06\x01\x12\x06\xe6\x02\0\xfc\x02\x01\n\x0b\n\x03\x06\x01\x01\x12\
    \x04\xe6\x02\x08\x13\nj\n\x04\x06\x01\x02\0\x12\x04\xe9\x02\x02W\x1a\\Up\
    dateUserProfileMap\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\
    \xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\xa1\xe6\x81\xaf\n\xe6\x9b\xb4\xe6\x96\
    \xb0\xe4\xb8\xaa\xe4\xba\xba\xe4\xbf\xa1\xe6\x81\xaf\xe9\x80\xbb\xe8\xbe\
    \x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\
    \xae\xe6\x94\xb9\n\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\xe9\x02\x06\x1a\n\
    \r\n\x05\x06\x01\x02\0\x02\x12\x04\xe9\x02\x1b2\n\r\n\x05\x06\x01\x02\0\
    \x03\x12\x04\xe9\x02=U\nh\n\x04\x06\x01\x02\x01\x12\x04\xec\x02\x02Q\x1a\
    ZUpdateUserExtraMap\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\x88\xb7\
    \xe6\x89\xa9\xe5\xb1\x95\xe4\xbf\xa1\xe6\x81\xaf\n\xe6\x9b\xb4\xe6\x96\
    \xb0\xe6\x89\xa9\xe5\xb1\x95\xe4\xbf\xa1\xe6\x81\xaf\xe9\x80\xbb\xe8\xbe\
    \x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\
    \xae\xe6\x94\xb9\n\n\r\n\x05\x06\x01\x02\x01\x01\x12\x04\xec\x02\x06\x18\
    \n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\xec\x02\x19.\n\r\n\x05\x06\x01\
    \x02\x01\x03\x12\x04\xec\x029O\nh\n\x04\x06\x01\x02\x02\x12\x04\xef\x02\
    \x02Q\x1aZUpdateUserCountMap\x20\xe6\x9b\xb4\xe6\x96\xb0\xe7\x94\xa8\xe6\
    \x88\xb7\xe8\xae\xa1\xe6\x95\xb0\xe4\xbf\xa1\xe6\x81\xaf\n\xe6\x9b\xb4\
    \xe6\x96\xb0\xe8\xae\xa1\xe6\x95\xb0\xe4\xbf\xa1\xe6\x81\xaf\xe9\x80\xbb\
    \xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\
    \xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\xef\x02\
    \x06\x18\n\r\n\x05\x06\x01\x02\x02\x02\x12\x04\xef\x02\x19.\n\r\n\x05\
    \x06\x01\x02\x02\x03\x12\x04\xef\x029O\nq\n\x04\x06\x01\x02\x03\x12\x04\
    \xf2\x02\x02H\x1acGetSelfUserInfo\x20\xe8\x8e\xb7\xe5\x8f\x96\xe8\x87\
    \xaa\xe5\xb7\xb1\xe7\x9a\x84\xe7\x94\xa8\xe6\x88\xb7\xe4\xbf\xa1\xe6\x81\
    \xaf\n\xe8\x8e\xb7\xe5\x8f\x96\xe8\x87\xaa\xe5\xb7\xb1\xe7\x9a\x84\xe7\
    \x94\xa8\xe6\x88\xb7\xe4\xbf\xa1\xe6\x81\xaf\xe9\x80\xbb\xe8\xbe\x91\xe5\
    \x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\
    \x94\xb9\n\n\r\n\x05\x06\x01\x02\x03\x01\x12\x04\xf2\x02\x06\x15\n\r\n\
    \x05\x06\x01\x02\x03\x02\x12\x04\xf2\x02\x16(\n\r\n\x05\x06\x01\x02\x03\
    \x03\x12\x04\xf2\x023F\n[\n\x04\x06\x01\x02\x04\x12\x04\xf5\x02\x02<\x1a\
    MGetUserInfo\x20\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe4\xbf\
    \xa1\xe6\x81\xaf\n\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe4\
    \xbf\xa1\xe6\x81\xaf\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\
    \xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\
    \x01\x02\x04\x01\x12\x04\xf5\x02\x06\x11\n\r\n\x05\x06\x01\x02\x04\x02\
    \x12\x04\xf5\x02\x12\x20\n\r\n\x05\x06\x01\x02\x04\x03\x12\x04\xf5\x02+:\
    \n`\n\x04\x06\x01\x02\x05\x12\x04\xf8\x02\x02K\x1aRGetUserModelById\x20\
    \xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\x8b\
    \n\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\
    \x8b\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\
    \x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\x01\x02\x05\x01\
    \x12\x04\xf8\x02\x06\x16\n\r\n\x05\x06\x01\x02\x05\x02\x12\x04\xf8\x02\
    \x17*\n\r\n\x05\x06\x01\x02\x05\x03\x12\x04\xf8\x025I\nm\n\x04\x06\x01\
    \x02\x06\x12\x04\xfb\x02\x02N\x1a_GetUserModelByIds\x20\xe6\x89\xb9\xe9\
    \x87\x8f\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe6\xa8\xa1\xe5\
    \x9e\x8b\n\xe6\x89\xb9\xe9\x87\x8f\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\
    \xe6\x88\xb7\xe6\xa8\xa1\xe5\x9e\x8b\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\
    \xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\
    \n\n\r\n\x05\x06\x01\x02\x06\x01\x12\x04\xfb\x02\x06\x17\n\r\n\x05\x06\
    \x01\x02\x06\x02\x12\x04\xfb\x02\x18,\n\r\n\x05\x06\x01\x02\x06\x03\x12\
    \x04\xfb\x027L\n\x0c\n\x02\x06\x02\x12\x06\xfe\x02\0\x8e\x03\x01\n\x0b\n\
    \x03\x06\x02\x01\x12\x04\xfe\x02\x08\x17\n_\n\x04\x06\x02\x02\0\x12\x04\
    \x81\x03\x02H\x1aQUserAfterOnline\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\
    \x8a\xe7\xba\xbf\xe5\x9b\x9e\xe8\xb0\x83\n\xe7\x94\xa8\xe6\x88\xb7\xe4\
    \xb8\x8a\xe7\xba\xbf\xe5\x9b\x9e\xe8\xb0\x83\xe9\x80\xbb\xe8\xbe\x91\xe5\
    \x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\
    \x94\xb9\n\n\r\n\x05\x06\x02\x02\0\x01\x12\x04\x81\x03\x06\x15\n\r\n\x05\
    \x06\x02\x02\0\x02\x12\x04\x81\x03\x16(\n\r\n\x05\x06\x02\x02\0\x03\x12\
    \x04\x81\x033F\n`\n\x04\x06\x02\x02\x01\x12\x04\x84\x03\x02K\x1aRUserAft\
    erOffline\x20\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8b\xe7\xba\xbf\xe5\x9b\
    \x9e\xe8\xb0\x83\n\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\x8b\xe7\xba\xbf\xe5\
    \x9b\x9e\xe8\xb0\x83\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\
    \xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\
    \x02\x02\x01\x01\x12\x04\x84\x03\x06\x16\n\r\n\x05\x06\x02\x02\x01\x02\
    \x12\x04\x84\x03\x17*\n\r\n\x05\x06\x02\x02\x01\x03\x12\x04\x84\x035I\nm\
    \n\x04\x06\x02\x02\x02\x12\x04\x87\x03\x02N\x1a_UserBeforeConnect\x20\
    \xe7\x94\xa8\xe6\x88\xb7\xe8\xbf\x9e\xe6\x8e\xa5\xe5\x89\x8d\xe7\x9a\x84\
    \xe5\x9b\x9e\xe8\xb0\x83\n\xe7\x94\xa8\xe6\x88\xb7\xe8\xbf\x9e\xe6\x8e\
    \xa5\xe5\x89\x8d\xe7\x9a\x84\xe5\x9b\x9e\xe8\xb0\x83\xe9\x80\xbb\xe8\xbe\
    \x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\
    \xae\xe6\x94\xb9\n\n\r\n\x05\x06\x02\x02\x02\x01\x12\x04\x87\x03\x06\x17\
    \n\r\n\x05\x06\x02\x02\x02\x02\x12\x04\x87\x03\x18,\n\r\n\x05\x06\x02\
    \x02\x02\x03\x12\x04\x87\x037L\nm\n\x04\x06\x02\x02\x03\x12\x04\x8a\x03\
    \x02N\x1a_UserBeforeRequest\x20\xe7\x94\xa8\xe6\x88\xb7\xe8\xaf\xb7\xe6\
    \xb1\x82\xe5\x89\x8d\xe7\x9a\x84\xe5\x9b\x9e\xe8\xb0\x83\n\xe7\x94\xa8\
    \xe6\x88\xb7\xe8\xaf\xb7\xe6\xb1\x82\xe5\x89\x8d\xe7\x9a\x84\xe5\x9b\x9e\
    \xe8\xb0\x83\xe9\x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\
    \xe8\xbf\x99\xe9\x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\x02\x02\
    \x03\x01\x12\x04\x8a\x03\x06\x17\n\r\n\x05\x06\x02\x02\x03\x02\x12\x04\
    \x8a\x03\x18,\n\r\n\x05\x06\x02\x02\x03\x03\x12\x04\x8a\x037L\nb\n\x04\
    \x06\x02\x02\x04\x12\x04\x8d\x03\x02Q\x1aTUserAfterKeepAlive\x20\xe7\x94\
    \xa8\xe6\x88\xb7\xe4\xbf\x9d\xe6\xb4\xbb\xe5\x9b\x9e\xe8\xb0\x83\n\xe7\
    \x94\xa8\xe6\x88\xb7\xe4\xbf\x9d\xe6\xb4\xbb\xe5\x9b\x9e\xe8\xb0\x83\xe9\
    \x80\xbb\xe8\xbe\x91\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbb\x8e\xe8\xbf\x99\xe9\
    \x87\x8c\xe4\xbf\xae\xe6\x94\xb9\n\n\r\n\x05\x06\x02\x02\x04\x01\x12\x04\
    \x8d\x03\x06\x18\n\r\n\x05\x06\x02\x02\x04\x02\x12\x04\x8d\x03\x19.\n\r\
    \n\x05\x06\x02\x02\x04\x03\x12\x04\x8d\x039Ob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(42);
            messages.push(UserRegisterReq::generated_message_descriptor_data());
            messages.push(UserRegisterResp::generated_message_descriptor_data());
            messages.push(UserDestroyReq::generated_message_descriptor_data());
            messages.push(UserDestroyResp::generated_message_descriptor_data());
            messages.push(UserAccessTokenReq::generated_message_descriptor_data());
            messages.push(UserAccessTokenResp::generated_message_descriptor_data());
            messages.push(RefreshUserAccessTokenReq::generated_message_descriptor_data());
            messages.push(RefreshUserAccessTokenResp::generated_message_descriptor_data());
            messages.push(RevokeUserAccessTokenReq::generated_message_descriptor_data());
            messages.push(RevokeUserAccessTokenResp::generated_message_descriptor_data());
            messages.push(UpdateUserAccountMapReq::generated_message_descriptor_data());
            messages.push(UpdateUserAccountMapResp::generated_message_descriptor_data());
            messages.push(UpdateUserProfileMapReq::generated_message_descriptor_data());
            messages.push(UpdateUserProfileMapResp::generated_message_descriptor_data());
            messages.push(UpdateUserExtraMapReq::generated_message_descriptor_data());
            messages.push(UpdateUserExtraMapResp::generated_message_descriptor_data());
            messages.push(UpdateUserCountMapReq::generated_message_descriptor_data());
            messages.push(UpdateUserCountMapResp::generated_message_descriptor_data());
            messages.push(GetSelfUserInfoReq::generated_message_descriptor_data());
            messages.push(GetSelfUserInfoResp::generated_message_descriptor_data());
            messages.push(GetUserInfoReq::generated_message_descriptor_data());
            messages.push(GetUserInfoResp::generated_message_descriptor_data());
            messages.push(ResetUserAccountMapReq::generated_message_descriptor_data());
            messages.push(ResetUserAccountMapResp::generated_message_descriptor_data());
            messages.push(UserAfterOnlineReq::generated_message_descriptor_data());
            messages.push(UserAfterOnlineResp::generated_message_descriptor_data());
            messages.push(UserAfterOfflineReq::generated_message_descriptor_data());
            messages.push(UserAfterOfflineResp::generated_message_descriptor_data());
            messages.push(UserBeforeConnectReq::generated_message_descriptor_data());
            messages.push(UserBeforeConnectResp::generated_message_descriptor_data());
            messages.push(UserBeforeRequestReq::generated_message_descriptor_data());
            messages.push(UserBeforeRequestResp::generated_message_descriptor_data());
            messages.push(UserAfterKeepAliveReq::generated_message_descriptor_data());
            messages.push(UserAfterKeepAliveResp::generated_message_descriptor_data());
            messages.push(CreateRobotReq::generated_message_descriptor_data());
            messages.push(CreateRobotResp::generated_message_descriptor_data());
            messages.push(GetUserModelByIdReq::generated_message_descriptor_data());
            messages.push(GetUserModelByIdResp::generated_message_descriptor_data());
            messages.push(GetUserModelByIdsReq::generated_message_descriptor_data());
            messages.push(GetUserModelByIdsResp::generated_message_descriptor_data());
            messages.push(get_user_model_by_id_req::Opt::generated_message_descriptor_data());
            messages.push(get_user_model_by_ids_req::Opt::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(update_user_count_map_req::CountType::generated_enum_descriptor_data());
            enums.push(update_user_count_map_req::Algorithm::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
