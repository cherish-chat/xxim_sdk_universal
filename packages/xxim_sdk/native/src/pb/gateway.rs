// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gateway.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

/// GatewayApiRequest http/私有协议 请求
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayApiRequest)
pub struct GatewayApiRequest {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayApiRequest.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayApiRequest.requestId)
    pub requestId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GatewayApiRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GatewayApiRequest.body)
    pub body: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayApiRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayApiRequest {
    fn default() -> &'a GatewayApiRequest {
        <GatewayApiRequest as ::protobuf::Message>::default_instance()
    }
}

impl GatewayApiRequest {
    pub fn new() -> GatewayApiRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayApiRequest| { &m.header },
            |m: &mut GatewayApiRequest| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requestId",
            |m: &GatewayApiRequest| { &m.requestId },
            |m: &mut GatewayApiRequest| { &mut m.requestId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &GatewayApiRequest| { &m.path },
            |m: &mut GatewayApiRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &GatewayApiRequest| { &m.body },
            |m: &mut GatewayApiRequest| { &mut m.body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayApiRequest>(
            "GatewayApiRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayApiRequest {
    const NAME: &'static str = "GatewayApiRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.requestId = is.read_string()?;
                },
                26 => {
                    self.path = is.read_string()?;
                },
                34 => {
                    self.body = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.requestId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.requestId);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.requestId.is_empty() {
            os.write_string(2, &self.requestId)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        if !self.body.is_empty() {
            os.write_bytes(4, &self.body)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayApiRequest {
        GatewayApiRequest::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.requestId.clear();
        self.path.clear();
        self.body.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayApiRequest {
        static instance: GatewayApiRequest = GatewayApiRequest {
            header: ::protobuf::MessageField::none(),
            requestId: ::std::string::String::new(),
            path: ::std::string::String::new(),
            body: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayApiRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayApiRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayApiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayApiRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayApiResponse http/私有协议 响应
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayApiResponse)
pub struct GatewayApiResponse {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayApiResponse.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GatewayApiResponse.requestId)
    pub requestId: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GatewayApiResponse.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:pb.GatewayApiResponse.body)
    pub body: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayApiResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayApiResponse {
    fn default() -> &'a GatewayApiResponse {
        <GatewayApiResponse as ::protobuf::Message>::default_instance()
    }
}

impl GatewayApiResponse {
    pub fn new() -> GatewayApiResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayApiResponse| { &m.header },
            |m: &mut GatewayApiResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requestId",
            |m: &GatewayApiResponse| { &m.requestId },
            |m: &mut GatewayApiResponse| { &mut m.requestId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &GatewayApiResponse| { &m.path },
            |m: &mut GatewayApiResponse| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &GatewayApiResponse| { &m.body },
            |m: &mut GatewayApiResponse| { &mut m.body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayApiResponse>(
            "GatewayApiResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayApiResponse {
    const NAME: &'static str = "GatewayApiResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.requestId = is.read_string()?;
                },
                26 => {
                    self.path = is.read_string()?;
                },
                34 => {
                    self.body = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.requestId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.requestId);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.requestId.is_empty() {
            os.write_string(2, &self.requestId)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        if !self.body.is_empty() {
            os.write_bytes(4, &self.body)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayApiResponse {
        GatewayApiResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.requestId.clear();
        self.path.clear();
        self.body.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayApiResponse {
        static instance: GatewayApiResponse = GatewayApiResponse {
            header: ::protobuf::MessageField::none(),
            requestId: ::std::string::String::new(),
            path: ::std::string::String::new(),
            body: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayApiResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayApiResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayApiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayApiResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayWriteDataContent 写入数据内容
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayWriteDataContent)
pub struct GatewayWriteDataContent {
    // message fields
    /// 写入数据类型
    // @@protoc_insertion_point(field:pb.GatewayWriteDataContent.dataType)
    pub dataType: ::protobuf::EnumOrUnknown<GatewayWriteDataType>,
    /// 响应
    // @@protoc_insertion_point(field:pb.GatewayWriteDataContent.response)
    pub response: ::protobuf::MessageField<GatewayApiResponse>,
    /// 主动推送message
    // @@protoc_insertion_point(field:pb.GatewayWriteDataContent.message)
    pub message: ::protobuf::MessageField<super::common::Message>,
    /// 主动推送notice
    // @@protoc_insertion_point(field:pb.GatewayWriteDataContent.notice)
    pub notice: ::protobuf::MessageField<super::common::Notice>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayWriteDataContent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayWriteDataContent {
    fn default() -> &'a GatewayWriteDataContent {
        <GatewayWriteDataContent as ::protobuf::Message>::default_instance()
    }
}

impl GatewayWriteDataContent {
    pub fn new() -> GatewayWriteDataContent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataType",
            |m: &GatewayWriteDataContent| { &m.dataType },
            |m: &mut GatewayWriteDataContent| { &mut m.dataType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayApiResponse>(
            "response",
            |m: &GatewayWriteDataContent| { &m.response },
            |m: &mut GatewayWriteDataContent| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Message>(
            "message",
            |m: &GatewayWriteDataContent| { &m.message },
            |m: &mut GatewayWriteDataContent| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Notice>(
            "notice",
            |m: &GatewayWriteDataContent| { &m.notice },
            |m: &mut GatewayWriteDataContent| { &mut m.notice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayWriteDataContent>(
            "GatewayWriteDataContent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayWriteDataContent {
    const NAME: &'static str = "GatewayWriteDataContent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dataType = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.response)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.notice)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.dataType != ::protobuf::EnumOrUnknown::new(GatewayWriteDataType::Response) {
            my_size += ::protobuf::rt::int32_size(1, self.dataType.value());
        }
        if let Some(v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.notice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.dataType != ::protobuf::EnumOrUnknown::new(GatewayWriteDataType::Response) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.dataType))?;
        }
        if let Some(v) = self.response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.notice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayWriteDataContent {
        GatewayWriteDataContent::new()
    }

    fn clear(&mut self) {
        self.dataType = ::protobuf::EnumOrUnknown::new(GatewayWriteDataType::Response);
        self.response.clear();
        self.message.clear();
        self.notice.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayWriteDataContent {
        static instance: GatewayWriteDataContent = GatewayWriteDataContent {
            dataType: ::protobuf::EnumOrUnknown::from_i32(0),
            response: ::protobuf::MessageField::none(),
            message: ::protobuf::MessageField::none(),
            notice: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayWriteDataContent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayWriteDataContent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayWriteDataContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayWriteDataContent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// WsConnection ws连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.WsConnection)
pub struct WsConnection {
    // message fields
    // @@protoc_insertion_point(field:pb.WsConnection.id)
    pub id: i64,
    // @@protoc_insertion_point(field:pb.WsConnection.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.WsConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WsConnection {
    fn default() -> &'a WsConnection {
        <WsConnection as ::protobuf::Message>::default_instance()
    }
}

impl WsConnection {
    pub fn new() -> WsConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WsConnection| { &m.id },
            |m: &mut WsConnection| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &WsConnection| { &m.header },
            |m: &mut WsConnection| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WsConnection>(
            "WsConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WsConnection {
    const NAME: &'static str = "WsConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WsConnection {
        WsConnection::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WsConnection {
        static instance: WsConnection = WsConnection {
            id: 0,
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WsConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WsConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WsConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WsConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayGetUserConnectionReq 获取用户的连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayGetUserConnectionReq)
pub struct GatewayGetUserConnectionReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayGetUserConnectionReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayGetUserConnectionReq.userId)
    pub userId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayGetUserConnectionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayGetUserConnectionReq {
    fn default() -> &'a GatewayGetUserConnectionReq {
        <GatewayGetUserConnectionReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayGetUserConnectionReq {
    pub fn new() -> GatewayGetUserConnectionReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayGetUserConnectionReq| { &m.header },
            |m: &mut GatewayGetUserConnectionReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &GatewayGetUserConnectionReq| { &m.userId },
            |m: &mut GatewayGetUserConnectionReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayGetUserConnectionReq>(
            "GatewayGetUserConnectionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayGetUserConnectionReq {
    const NAME: &'static str = "GatewayGetUserConnectionReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.userId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.userId.is_empty() {
            os.write_string(2, &self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayGetUserConnectionReq {
        GatewayGetUserConnectionReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayGetUserConnectionReq {
        static instance: GatewayGetUserConnectionReq = GatewayGetUserConnectionReq {
            header: ::protobuf::MessageField::none(),
            userId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayGetUserConnectionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayGetUserConnectionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayGetUserConnectionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayGetUserConnectionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayGetUserConnectionResp)
pub struct GatewayGetUserConnectionResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayGetUserConnectionResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GatewayGetUserConnectionResp.connections)
    pub connections: ::std::vec::Vec<WsConnection>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayGetUserConnectionResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayGetUserConnectionResp {
    fn default() -> &'a GatewayGetUserConnectionResp {
        <GatewayGetUserConnectionResp as ::protobuf::Message>::default_instance()
    }
}

impl GatewayGetUserConnectionResp {
    pub fn new() -> GatewayGetUserConnectionResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayGetUserConnectionResp| { &m.header },
            |m: &mut GatewayGetUserConnectionResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connections",
            |m: &GatewayGetUserConnectionResp| { &m.connections },
            |m: &mut GatewayGetUserConnectionResp| { &mut m.connections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayGetUserConnectionResp>(
            "GatewayGetUserConnectionResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayGetUserConnectionResp {
    const NAME: &'static str = "GatewayGetUserConnectionResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.connections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.connections {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayGetUserConnectionResp {
        GatewayGetUserConnectionResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.connections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayGetUserConnectionResp {
        static instance: GatewayGetUserConnectionResp = GatewayGetUserConnectionResp {
            header: ::protobuf::MessageField::none(),
            connections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayGetUserConnectionResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayGetUserConnectionResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayGetUserConnectionResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayGetUserConnectionResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayBatchGetUserConnectionReq 批量获取用户的连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayBatchGetUserConnectionReq)
pub struct GatewayBatchGetUserConnectionReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayBatchGetUserConnectionReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayBatchGetUserConnectionReq.userIds)
    pub userIds: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayBatchGetUserConnectionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayBatchGetUserConnectionReq {
    fn default() -> &'a GatewayBatchGetUserConnectionReq {
        <GatewayBatchGetUserConnectionReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayBatchGetUserConnectionReq {
    pub fn new() -> GatewayBatchGetUserConnectionReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayBatchGetUserConnectionReq| { &m.header },
            |m: &mut GatewayBatchGetUserConnectionReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userIds",
            |m: &GatewayBatchGetUserConnectionReq| { &m.userIds },
            |m: &mut GatewayBatchGetUserConnectionReq| { &mut m.userIds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayBatchGetUserConnectionReq>(
            "GatewayBatchGetUserConnectionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayBatchGetUserConnectionReq {
    const NAME: &'static str = "GatewayBatchGetUserConnectionReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.userIds.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.userIds {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.userIds {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayBatchGetUserConnectionReq {
        GatewayBatchGetUserConnectionReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.userIds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayBatchGetUserConnectionReq {
        static instance: GatewayBatchGetUserConnectionReq = GatewayBatchGetUserConnectionReq {
            header: ::protobuf::MessageField::none(),
            userIds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayBatchGetUserConnectionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayBatchGetUserConnectionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayBatchGetUserConnectionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayBatchGetUserConnectionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayBatchGetUserConnectionResp)
pub struct GatewayBatchGetUserConnectionResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayBatchGetUserConnectionResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GatewayBatchGetUserConnectionResp.connections)
    pub connections: ::std::vec::Vec<WsConnection>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayBatchGetUserConnectionResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayBatchGetUserConnectionResp {
    fn default() -> &'a GatewayBatchGetUserConnectionResp {
        <GatewayBatchGetUserConnectionResp as ::protobuf::Message>::default_instance()
    }
}

impl GatewayBatchGetUserConnectionResp {
    pub fn new() -> GatewayBatchGetUserConnectionResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayBatchGetUserConnectionResp| { &m.header },
            |m: &mut GatewayBatchGetUserConnectionResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connections",
            |m: &GatewayBatchGetUserConnectionResp| { &m.connections },
            |m: &mut GatewayBatchGetUserConnectionResp| { &mut m.connections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayBatchGetUserConnectionResp>(
            "GatewayBatchGetUserConnectionResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayBatchGetUserConnectionResp {
    const NAME: &'static str = "GatewayBatchGetUserConnectionResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.connections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.connections {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayBatchGetUserConnectionResp {
        GatewayBatchGetUserConnectionResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.connections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayBatchGetUserConnectionResp {
        static instance: GatewayBatchGetUserConnectionResp = GatewayBatchGetUserConnectionResp {
            header: ::protobuf::MessageField::none(),
            connections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayBatchGetUserConnectionResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayBatchGetUserConnectionResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayBatchGetUserConnectionResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayBatchGetUserConnectionResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayGetConnectionFilter)
pub struct GatewayGetConnectionFilter {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayGetConnectionFilter.userIds)
    pub userIds: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayGetConnectionFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayGetConnectionFilter {
    fn default() -> &'a GatewayGetConnectionFilter {
        <GatewayGetConnectionFilter as ::protobuf::Message>::default_instance()
    }
}

impl GatewayGetConnectionFilter {
    pub fn new() -> GatewayGetConnectionFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userIds",
            |m: &GatewayGetConnectionFilter| { &m.userIds },
            |m: &mut GatewayGetConnectionFilter| { &mut m.userIds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayGetConnectionFilter>(
            "GatewayGetConnectionFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayGetConnectionFilter {
    const NAME: &'static str = "GatewayGetConnectionFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.userIds.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.userIds {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.userIds {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayGetConnectionFilter {
        GatewayGetConnectionFilter::new()
    }

    fn clear(&mut self) {
        self.userIds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayGetConnectionFilter {
        static instance: GatewayGetConnectionFilter = GatewayGetConnectionFilter {
            userIds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayGetConnectionFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayGetConnectionFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayGetConnectionFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayGetConnectionFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayGetConnectionByFilterReq 根据过滤条件获取连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayGetConnectionByFilterReq)
pub struct GatewayGetConnectionByFilterReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayGetConnectionByFilterReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayGetConnectionByFilterReq.filter)
    pub filter: ::protobuf::MessageField<GatewayGetConnectionFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayGetConnectionByFilterReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayGetConnectionByFilterReq {
    fn default() -> &'a GatewayGetConnectionByFilterReq {
        <GatewayGetConnectionByFilterReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayGetConnectionByFilterReq {
    pub fn new() -> GatewayGetConnectionByFilterReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayGetConnectionByFilterReq| { &m.header },
            |m: &mut GatewayGetConnectionByFilterReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayGetConnectionFilter>(
            "filter",
            |m: &GatewayGetConnectionByFilterReq| { &m.filter },
            |m: &mut GatewayGetConnectionByFilterReq| { &mut m.filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayGetConnectionByFilterReq>(
            "GatewayGetConnectionByFilterReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayGetConnectionByFilterReq {
    const NAME: &'static str = "GatewayGetConnectionByFilterReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayGetConnectionByFilterReq {
        GatewayGetConnectionByFilterReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayGetConnectionByFilterReq {
        static instance: GatewayGetConnectionByFilterReq = GatewayGetConnectionByFilterReq {
            header: ::protobuf::MessageField::none(),
            filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayGetConnectionByFilterReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayGetConnectionByFilterReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayGetConnectionByFilterReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayGetConnectionByFilterReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayGetConnectionByFilterResp)
pub struct GatewayGetConnectionByFilterResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayGetConnectionByFilterResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GatewayGetConnectionByFilterResp.connections)
    pub connections: ::std::vec::Vec<WsConnection>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayGetConnectionByFilterResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayGetConnectionByFilterResp {
    fn default() -> &'a GatewayGetConnectionByFilterResp {
        <GatewayGetConnectionByFilterResp as ::protobuf::Message>::default_instance()
    }
}

impl GatewayGetConnectionByFilterResp {
    pub fn new() -> GatewayGetConnectionByFilterResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayGetConnectionByFilterResp| { &m.header },
            |m: &mut GatewayGetConnectionByFilterResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connections",
            |m: &GatewayGetConnectionByFilterResp| { &m.connections },
            |m: &mut GatewayGetConnectionByFilterResp| { &mut m.connections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayGetConnectionByFilterResp>(
            "GatewayGetConnectionByFilterResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayGetConnectionByFilterResp {
    const NAME: &'static str = "GatewayGetConnectionByFilterResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.connections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.connections {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayGetConnectionByFilterResp {
        GatewayGetConnectionByFilterResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.connections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayGetConnectionByFilterResp {
        static instance: GatewayGetConnectionByFilterResp = GatewayGetConnectionByFilterResp {
            header: ::protobuf::MessageField::none(),
            connections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayGetConnectionByFilterResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayGetConnectionByFilterResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayGetConnectionByFilterResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayGetConnectionByFilterResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayWriteDataToWsReq 写入数据到ws连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayWriteDataToWsReq)
pub struct GatewayWriteDataToWsReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsReq.filter)
    pub filter: ::protobuf::MessageField<GatewayGetConnectionFilter>,
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsReq.data)
    pub data: ::protobuf::MessageField<GatewayWriteDataContent>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayWriteDataToWsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayWriteDataToWsReq {
    fn default() -> &'a GatewayWriteDataToWsReq {
        <GatewayWriteDataToWsReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayWriteDataToWsReq {
    pub fn new() -> GatewayWriteDataToWsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayWriteDataToWsReq| { &m.header },
            |m: &mut GatewayWriteDataToWsReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayGetConnectionFilter>(
            "filter",
            |m: &GatewayWriteDataToWsReq| { &m.filter },
            |m: &mut GatewayWriteDataToWsReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayWriteDataContent>(
            "data",
            |m: &GatewayWriteDataToWsReq| { &m.data },
            |m: &mut GatewayWriteDataToWsReq| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayWriteDataToWsReq>(
            "GatewayWriteDataToWsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayWriteDataToWsReq {
    const NAME: &'static str = "GatewayWriteDataToWsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayWriteDataToWsReq {
        GatewayWriteDataToWsReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.filter.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayWriteDataToWsReq {
        static instance: GatewayWriteDataToWsReq = GatewayWriteDataToWsReq {
            header: ::protobuf::MessageField::none(),
            filter: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayWriteDataToWsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayWriteDataToWsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayWriteDataToWsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayWriteDataToWsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayWriteDataToWsResp)
pub struct GatewayWriteDataToWsResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsResp.successConnections)
    pub successConnections: ::std::vec::Vec<WsConnection>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayWriteDataToWsResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayWriteDataToWsResp {
    fn default() -> &'a GatewayWriteDataToWsResp {
        <GatewayWriteDataToWsResp as ::protobuf::Message>::default_instance()
    }
}

impl GatewayWriteDataToWsResp {
    pub fn new() -> GatewayWriteDataToWsResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayWriteDataToWsResp| { &m.header },
            |m: &mut GatewayWriteDataToWsResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "successConnections",
            |m: &GatewayWriteDataToWsResp| { &m.successConnections },
            |m: &mut GatewayWriteDataToWsResp| { &mut m.successConnections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayWriteDataToWsResp>(
            "GatewayWriteDataToWsResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayWriteDataToWsResp {
    const NAME: &'static str = "GatewayWriteDataToWsResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.successConnections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.successConnections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.successConnections {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayWriteDataToWsResp {
        GatewayWriteDataToWsResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.successConnections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayWriteDataToWsResp {
        static instance: GatewayWriteDataToWsResp = GatewayWriteDataToWsResp {
            header: ::protobuf::MessageField::none(),
            successConnections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayWriteDataToWsResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayWriteDataToWsResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayWriteDataToWsResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayWriteDataToWsResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayWriteDataToWsWrapperReq 写入数据到ws连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayWriteDataToWsWrapperReq)
pub struct GatewayWriteDataToWsWrapperReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsWrapperReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsWrapperReq.filter)
    pub filter: ::protobuf::MessageField<GatewayGetConnectionFilter>,
    // @@protoc_insertion_point(field:pb.GatewayWriteDataToWsWrapperReq.data)
    pub data: ::protobuf::MessageField<GatewayWriteDataContent>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayWriteDataToWsWrapperReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayWriteDataToWsWrapperReq {
    fn default() -> &'a GatewayWriteDataToWsWrapperReq {
        <GatewayWriteDataToWsWrapperReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayWriteDataToWsWrapperReq {
    pub fn new() -> GatewayWriteDataToWsWrapperReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayWriteDataToWsWrapperReq| { &m.header },
            |m: &mut GatewayWriteDataToWsWrapperReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayGetConnectionFilter>(
            "filter",
            |m: &GatewayWriteDataToWsWrapperReq| { &m.filter },
            |m: &mut GatewayWriteDataToWsWrapperReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayWriteDataContent>(
            "data",
            |m: &GatewayWriteDataToWsWrapperReq| { &m.data },
            |m: &mut GatewayWriteDataToWsWrapperReq| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayWriteDataToWsWrapperReq>(
            "GatewayWriteDataToWsWrapperReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayWriteDataToWsWrapperReq {
    const NAME: &'static str = "GatewayWriteDataToWsWrapperReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayWriteDataToWsWrapperReq {
        GatewayWriteDataToWsWrapperReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.filter.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayWriteDataToWsWrapperReq {
        static instance: GatewayWriteDataToWsWrapperReq = GatewayWriteDataToWsWrapperReq {
            header: ::protobuf::MessageField::none(),
            filter: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayWriteDataToWsWrapperReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayWriteDataToWsWrapperReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayWriteDataToWsWrapperReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayWriteDataToWsWrapperReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayKickWsReq 踢出ws连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayKickWsReq)
pub struct GatewayKickWsReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayKickWsReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // @@protoc_insertion_point(field:pb.GatewayKickWsReq.filter)
    pub filter: ::protobuf::MessageField<GatewayGetConnectionFilter>,
    // @@protoc_insertion_point(field:pb.GatewayKickWsReq.closeCode)
    pub closeCode: ::protobuf::EnumOrUnknown<super::common::WebsocketCustomCloseCode>,
    // @@protoc_insertion_point(field:pb.GatewayKickWsReq.closeReason)
    pub closeReason: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayKickWsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayKickWsReq {
    fn default() -> &'a GatewayKickWsReq {
        <GatewayKickWsReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayKickWsReq {
    pub fn new() -> GatewayKickWsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayKickWsReq| { &m.header },
            |m: &mut GatewayKickWsReq| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GatewayGetConnectionFilter>(
            "filter",
            |m: &GatewayKickWsReq| { &m.filter },
            |m: &mut GatewayKickWsReq| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "closeCode",
            |m: &GatewayKickWsReq| { &m.closeCode },
            |m: &mut GatewayKickWsReq| { &mut m.closeCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "closeReason",
            |m: &GatewayKickWsReq| { &m.closeReason },
            |m: &mut GatewayKickWsReq| { &mut m.closeReason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayKickWsReq>(
            "GatewayKickWsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayKickWsReq {
    const NAME: &'static str = "GatewayKickWsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                24 => {
                    self.closeCode = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.closeReason = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.closeCode != ::protobuf::EnumOrUnknown::new(super::common::WebsocketCustomCloseCode::CloseCodeZero) {
            my_size += ::protobuf::rt::int32_size(3, self.closeCode.value());
        }
        if !self.closeReason.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.closeReason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.closeCode != ::protobuf::EnumOrUnknown::new(super::common::WebsocketCustomCloseCode::CloseCodeZero) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.closeCode))?;
        }
        if !self.closeReason.is_empty() {
            os.write_string(4, &self.closeReason)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayKickWsReq {
        GatewayKickWsReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.filter.clear();
        self.closeCode = ::protobuf::EnumOrUnknown::new(super::common::WebsocketCustomCloseCode::CloseCodeZero);
        self.closeReason.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayKickWsReq {
        static instance: GatewayKickWsReq = GatewayKickWsReq {
            header: ::protobuf::MessageField::none(),
            filter: ::protobuf::MessageField::none(),
            closeCode: ::protobuf::EnumOrUnknown::from_i32(0),
            closeReason: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayKickWsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayKickWsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayKickWsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayKickWsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayKickWsResp)
pub struct GatewayKickWsResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayKickWsResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // @@protoc_insertion_point(field:pb.GatewayKickWsResp.successConnections)
    pub successConnections: ::std::vec::Vec<WsConnection>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayKickWsResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayKickWsResp {
    fn default() -> &'a GatewayKickWsResp {
        <GatewayKickWsResp as ::protobuf::Message>::default_instance()
    }
}

impl GatewayKickWsResp {
    pub fn new() -> GatewayKickWsResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayKickWsResp| { &m.header },
            |m: &mut GatewayKickWsResp| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "successConnections",
            |m: &GatewayKickWsResp| { &m.successConnections },
            |m: &mut GatewayKickWsResp| { &mut m.successConnections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayKickWsResp>(
            "GatewayKickWsResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayKickWsResp {
    const NAME: &'static str = "GatewayKickWsResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.successConnections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.successConnections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.successConnections {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayKickWsResp {
        GatewayKickWsResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.successConnections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayKickWsResp {
        static instance: GatewayKickWsResp = GatewayKickWsResp {
            header: ::protobuf::MessageField::none(),
            successConnections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayKickWsResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayKickWsResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayKickWsResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayKickWsResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayKeepAliveReq 保持连接
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayKeepAliveReq)
pub struct GatewayKeepAliveReq {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayKeepAliveReq.header)
    pub header: ::protobuf::MessageField<super::common::RequestHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayKeepAliveReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayKeepAliveReq {
    fn default() -> &'a GatewayKeepAliveReq {
        <GatewayKeepAliveReq as ::protobuf::Message>::default_instance()
    }
}

impl GatewayKeepAliveReq {
    pub fn new() -> GatewayKeepAliveReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RequestHeader>(
            "header",
            |m: &GatewayKeepAliveReq| { &m.header },
            |m: &mut GatewayKeepAliveReq| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayKeepAliveReq>(
            "GatewayKeepAliveReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayKeepAliveReq {
    const NAME: &'static str = "GatewayKeepAliveReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayKeepAliveReq {
        GatewayKeepAliveReq::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayKeepAliveReq {
        static instance: GatewayKeepAliveReq = GatewayKeepAliveReq {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayKeepAliveReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayKeepAliveReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayKeepAliveReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayKeepAliveReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:pb.GatewayKeepAliveResp)
pub struct GatewayKeepAliveResp {
    // message fields
    // @@protoc_insertion_point(field:pb.GatewayKeepAliveResp.header)
    pub header: ::protobuf::MessageField<super::common::ResponseHeader>,
    // special fields
    // @@protoc_insertion_point(special_field:pb.GatewayKeepAliveResp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GatewayKeepAliveResp {
    fn default() -> &'a GatewayKeepAliveResp {
        <GatewayKeepAliveResp as ::protobuf::Message>::default_instance()
    }
}

impl GatewayKeepAliveResp {
    pub fn new() -> GatewayKeepAliveResp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ResponseHeader>(
            "header",
            |m: &GatewayKeepAliveResp| { &m.header },
            |m: &mut GatewayKeepAliveResp| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GatewayKeepAliveResp>(
            "GatewayKeepAliveResp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GatewayKeepAliveResp {
    const NAME: &'static str = "GatewayKeepAliveResp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GatewayKeepAliveResp {
        GatewayKeepAliveResp::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GatewayKeepAliveResp {
        static instance: GatewayKeepAliveResp = GatewayKeepAliveResp {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GatewayKeepAliveResp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GatewayKeepAliveResp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GatewayKeepAliveResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayKeepAliveResp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GatewayWriteDataType 写入数据类型
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pb.GatewayWriteDataType)
pub enum GatewayWriteDataType {
    // @@protoc_insertion_point(enum_value:pb.GatewayWriteDataType.Response)
    Response = 0,
    // @@protoc_insertion_point(enum_value:pb.GatewayWriteDataType.PushMessage)
    PushMessage = 1,
    // @@protoc_insertion_point(enum_value:pb.GatewayWriteDataType.PushNotice)
    PushNotice = 2,
}

impl ::protobuf::Enum for GatewayWriteDataType {
    const NAME: &'static str = "GatewayWriteDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GatewayWriteDataType> {
        match value {
            0 => ::std::option::Option::Some(GatewayWriteDataType::Response),
            1 => ::std::option::Option::Some(GatewayWriteDataType::PushMessage),
            2 => ::std::option::Option::Some(GatewayWriteDataType::PushNotice),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GatewayWriteDataType] = &[
        GatewayWriteDataType::Response,
        GatewayWriteDataType::PushMessage,
        GatewayWriteDataType::PushNotice,
    ];
}

impl ::protobuf::EnumFull for GatewayWriteDataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GatewayWriteDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GatewayWriteDataType {
    fn default() -> Self {
        GatewayWriteDataType::Response
    }
}

impl GatewayWriteDataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GatewayWriteDataType>("GatewayWriteDataType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rgateway.proto\x12\x02pb\x1a\x0ccommon.proto\"\x84\x01\n\x11GatewayAp\
    iRequest\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\
    \x06header\x12\x1c\n\trequestId\x18\x02\x20\x01(\tR\trequestId\x12\x12\n\
    \x04path\x18\x03\x20\x01(\tR\x04path\x12\x12\n\x04body\x18\x04\x20\x01(\
    \x0cR\x04body\"\x86\x01\n\x12GatewayApiResponse\x12*\n\x06header\x18\x01\
    \x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12\x1c\n\trequestId\x18\
    \x02\x20\x01(\tR\trequestId\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04pat\
    h\x12\x12\n\x04body\x18\x04\x20\x01(\x0cR\x04body\"\x81\x02\n\x17Gateway\
    WriteDataContent\x124\n\x08dataType\x18\x01\x20\x01(\x0e2\x18.pb.Gateway\
    WriteDataTypeR\x08dataType\x127\n\x08response\x18\x02\x20\x01(\x0b2\x16.\
    pb.GatewayApiResponseH\0R\x08response\x88\x01\x01\x12*\n\x07message\x18\
    \x03\x20\x01(\x0b2\x0b.pb.MessageH\x01R\x07message\x88\x01\x01\x12'\n\
    \x06notice\x18\x04\x20\x01(\x0b2\n.pb.NoticeH\x02R\x06notice\x88\x01\x01\
    B\x0b\n\t_responseB\n\n\x08_messageB\t\n\x07_notice\"I\n\x0cWsConnection\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12)\n\x06header\x18\x02\
    \x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\"`\n\x1bGatewayGetUserCon\
    nectionReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\
    \x06header\x12\x16\n\x06userId\x18\x02\x20\x01(\tR\x06userId\"~\n\x1cGat\
    ewayGetUserConnectionResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.\
    ResponseHeaderR\x06header\x122\n\x0bconnections\x18\x02\x20\x03(\x0b2\
    \x10.pb.WsConnectionR\x0bconnections\"g\n\x20GatewayBatchGetUserConnecti\
    onReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06he\
    ader\x12\x18\n\x07userIds\x18\x02\x20\x03(\tR\x07userIds\"\x83\x01\n!Gat\
    ewayBatchGetUserConnectionResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\
    \x12.pb.ResponseHeaderR\x06header\x122\n\x0bconnections\x18\x02\x20\x03(\
    \x0b2\x10.pb.WsConnectionR\x0bconnections\"6\n\x1aGatewayGetConnectionFi\
    lter\x12\x18\n\x07userIds\x18\x01\x20\x03(\tR\x07userIds\"\x84\x01\n\x1f\
    GatewayGetConnectionByFilterReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\
    \x11.pb.RequestHeaderR\x06header\x126\n\x06filter\x18\x02\x20\x01(\x0b2\
    \x1e.pb.GatewayGetConnectionFilterR\x06filter\"\x82\x01\n\x20GatewayGetC\
    onnectionByFilterResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.Resp\
    onseHeaderR\x06header\x122\n\x0bconnections\x18\x02\x20\x03(\x0b2\x10.pb\
    .WsConnectionR\x0bconnections\"\xad\x01\n\x17GatewayWriteDataToWsReq\x12\
    )\n\x06header\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x126\
    \n\x06filter\x18\x02\x20\x01(\x0b2\x1e.pb.GatewayGetConnectionFilterR\
    \x06filter\x12/\n\x04data\x18\x03\x20\x01(\x0b2\x1b.pb.GatewayWriteDataC\
    ontentR\x04data\"\x88\x01\n\x18GatewayWriteDataToWsResp\x12*\n\x06header\
    \x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\x06header\x12@\n\x12succes\
    sConnections\x18\x02\x20\x03(\x0b2\x10.pb.WsConnectionR\x12successConnec\
    tions\"\xb4\x01\n\x1eGatewayWriteDataToWsWrapperReq\x12)\n\x06header\x18\
    \x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\x126\n\x06filter\x18\
    \x02\x20\x01(\x0b2\x1e.pb.GatewayGetConnectionFilterR\x06filter\x12/\n\
    \x04data\x18\x03\x20\x01(\x0b2\x1b.pb.GatewayWriteDataContentR\x04data\"\
    \xd3\x01\n\x10GatewayKickWsReq\x12)\n\x06header\x18\x01\x20\x01(\x0b2\
    \x11.pb.RequestHeaderR\x06header\x126\n\x06filter\x18\x02\x20\x01(\x0b2\
    \x1e.pb.GatewayGetConnectionFilterR\x06filter\x12:\n\tcloseCode\x18\x03\
    \x20\x01(\x0e2\x1c.pb.WebsocketCustomCloseCodeR\tcloseCode\x12\x20\n\x0b\
    closeReason\x18\x04\x20\x01(\tR\x0bcloseReason\"\x81\x01\n\x11GatewayKic\
    kWsResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseHeaderR\
    \x06header\x12@\n\x12successConnections\x18\x02\x20\x03(\x0b2\x10.pb.WsC\
    onnectionR\x12successConnections\"@\n\x13GatewayKeepAliveReq\x12)\n\x06h\
    eader\x18\x01\x20\x01(\x0b2\x11.pb.RequestHeaderR\x06header\"B\n\x14Gate\
    wayKeepAliveResp\x12*\n\x06header\x18\x01\x20\x01(\x0b2\x12.pb.ResponseH\
    eaderR\x06header*E\n\x14GatewayWriteDataType\x12\x0c\n\x08Response\x10\0\
    \x12\x0f\n\x0bPushMessage\x10\x01\x12\x0e\n\nPushNotice\x10\x022\x81\x05\
    \n\x0egatewayService\x12]\n\x18GatewayGetUserConnection\x12\x1f.pb.Gatew\
    ayGetUserConnectionReq\x1a\x20.pb.GatewayGetUserConnectionResp\x12l\n\
    \x1dGatewayBatchGetUserConnection\x12$.pb.GatewayBatchGetUserConnectionR\
    eq\x1a%.pb.GatewayBatchGetUserConnectionResp\x12i\n\x1cGatewayGetConnect\
    ionByFilter\x12#.pb.GatewayGetConnectionByFilterReq\x1a$.pb.GatewayGetCo\
    nnectionByFilterResp\x12Q\n\x14GatewayWriteDataToWs\x12\x1b.pb.GatewayWr\
    iteDataToWsReq\x1a\x1c.pb.GatewayWriteDataToWsResp\x12_\n\x1bGatewayWrit\
    eDataToWsWrapper\x12\".pb.GatewayWriteDataToWsWrapperReq\x1a\x1c.pb.Gate\
    wayWriteDataToWsResp\x12<\n\rGatewayKickWs\x12\x14.pb.GatewayKickWsReq\
    \x1a\x15.pb.GatewayKickWsResp\x12E\n\x10GatewayKeepAlive\x12\x17.pb.Gate\
    wayKeepAliveReq\x1a\x18.pb.GatewayKeepAliveRespB\x06Z\x04./pbJ\xa9(\n\
    \x07\x12\x05\0\0\x97\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x01\0\x0b\n\x08\n\x01\x08\x12\x03\x02\0\x1b\n\t\n\x02\x08\
    \x0b\x12\x03\x02\0\x1b\n\t\n\x02\x03\0\x12\x03\x03\0\x16\n7\n\x02\x04\0\
    \x12\x04\x06\0\x0b\x01\x1a+GatewayApiRequest\x20http/\xe7\xa7\x81\xe6\
    \x9c\x89\xe5\x8d\x8f\xe8\xae\xae\x20\xe8\xaf\xb7\xe6\xb1\x82\n\n\n\n\x03\
    \x04\0\x01\x12\x03\x06\x08\x19\n\x0b\n\x04\x04\0\x02\0\x12\x03\x07\x02\
    \x1b\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x07\x02\x0f\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\x07\x10\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x07\
    \x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x08\x02\x17\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x08\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x08\t\x12\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x08\x15\x16\n\x0b\n\x04\
    \x04\0\x02\x02\x12\x03\t\x02\x12\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\t\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\t\t\r\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\t\x10\x11\n\x0b\n\x04\x04\0\x02\x03\x12\x03\n\x02\
    \x11\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\n\x02\x07\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\n\x08\x0c\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\n\
    \x0f\x10\n8\n\x02\x04\x01\x12\x04\x0e\0\x13\x01\x1a,GatewayApiResponse\
    \x20http/\xe7\xa7\x81\xe6\x9c\x89\xe5\x8d\x8f\xe8\xae\xae\x20\xe5\x93\
    \x8d\xe5\xba\x94\n\n\n\n\x03\x04\x01\x01\x12\x03\x0e\x08\x1a\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03\x0f\x02\x1c\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\
    \x0f\x02\x10\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x0f\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03\x0f\x1a\x1b\n\x0b\n\x04\x04\x01\x02\x01\
    \x12\x03\x10\x02\x17\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x10\x02\x08\
    \n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x10\t\x12\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\x10\x15\x16\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x11\
    \x02\x12\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x11\x02\x08\n\x0c\n\x05\
    \x04\x01\x02\x02\x01\x12\x03\x11\t\r\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03\x11\x10\x11\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x12\x02\x11\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03\x12\x02\x07\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03\x12\x08\x0c\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x12\x0f\
    \x10\n4\n\x02\x05\0\x12\x04\x16\0\x1d\x01\x1a(GatewayWriteDataType\x20\
    \xe5\x86\x99\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\xe7\xb1\xbb\xe5\x9e\x8b\
    \n\n\n\n\x03\x05\0\x01\x12\x03\x16\x05\x19\n\x1a\n\x04\x05\0\x02\0\x12\
    \x03\x18\x02\x0f\x1a\r\xe8\xbf\x94\xe5\x9b\x9e\xe5\x93\x8d\xe5\xba\x94\n\
    \n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x18\x02\n\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03\x18\r\x0e\n!\n\x04\x05\0\x02\x01\x12\x03\x1a\x02\x12\x1a\
    \x14\xe4\xb8\xbb\xe5\x8a\xa8\xe6\x8e\xa8\xe9\x80\x81message\n\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03\x1a\x02\r\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03\x1a\x10\x11\n\x20\n\x04\x05\0\x02\x02\x12\x03\x1c\x02\x11\x1a\
    \x13\xe4\xb8\xbb\xe5\x8a\xa8\xe6\x8e\xa8\xe9\x80\x81notice\n\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03\x1c\x02\x0c\n\x0c\n\x05\x05\0\x02\x02\x02\x12\
    \x03\x1c\x0f\x10\n7\n\x02\x04\x02\x12\x04\x20\0)\x01\x1a+GatewayWriteDat\
    aContent\x20\xe5\x86\x99\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\xe5\x86\x85\
    \xe5\xae\xb9\n\n\n\n\x03\x04\x02\x01\x12\x03\x20\x08\x1f\n\x20\n\x04\x04\
    \x02\x02\0\x12\x03\"\x02$\x1a\x13\xe5\x86\x99\xe5\x85\xa5\xe6\x95\xb0\
    \xe6\x8d\xae\xe7\xb1\xbb\xe5\x9e\x8b\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\
    \x03\"\x02\x16\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\"\x17\x1f\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03\"\"#\n\x14\n\x04\x04\x02\x02\x01\x12\x03$\
    \x02+\x1a\x07\xe5\x93\x8d\xe5\xba\x94\n\n\x0c\n\x05\x04\x02\x02\x01\x04\
    \x12\x03$\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03$\x0b\x1d\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x03$\x1e&\n\x0c\n\x05\x04\x02\x02\x01\x03\
    \x12\x03$)*\n!\n\x04\x04\x02\x02\x02\x12\x03&\x02\x1f\x1a\x14\xe4\xb8\
    \xbb\xe5\x8a\xa8\xe6\x8e\xa8\xe9\x80\x81message\n\n\x0c\n\x05\x04\x02\
    \x02\x02\x04\x12\x03&\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03&\x0b\
    \x12\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03&\x13\x1a\n\x0c\n\x05\x04\
    \x02\x02\x02\x03\x12\x03&\x1d\x1e\n\x20\n\x04\x04\x02\x02\x03\x12\x03(\
    \x02\x1d\x1a\x13\xe4\xb8\xbb\xe5\x8a\xa8\xe6\x8e\xa8\xe9\x80\x81notice\n\
    \n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03(\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x03\x06\x12\x03(\x0b\x11\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03(\x12\
    \x18\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03(\x1b\x1c\n\"\n\x02\x04\x03\
    \x12\x04,\0/\x01\x1a\x16WsConnection\x20ws\xe8\xbf\x9e\xe6\x8e\xa5\n\n\n\
    \n\x03\x04\x03\x01\x12\x03,\x08\x14\n\x0b\n\x04\x04\x03\x02\0\x12\x03-\
    \x02\x0f\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03-\x02\x07\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03-\x08\n\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03-\r\
    \x0e\n\x0b\n\x04\x04\x03\x02\x01\x12\x03.\x02\x1b\n\x0c\n\x05\x04\x03\
    \x02\x01\x06\x12\x03.\x02\x0f\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03.\
    \x10\x16\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03.\x19\x1a\n>\n\x02\x04\
    \x04\x12\x042\05\x01\x1a2GatewayGetUserConnectionReq\x20\xe8\x8e\xb7\xe5\
    \x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\xe6\x8e\xa5\n\n\
    \n\n\x03\x04\x04\x01\x12\x032\x08#\n\x0b\n\x04\x04\x04\x02\0\x12\x033\
    \x02\x1b\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x033\x02\x0f\n\x0c\n\x05\x04\
    \x04\x02\0\x01\x12\x033\x10\x16\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x033\
    \x19\x1a\n\x0b\n\x04\x04\x04\x02\x01\x12\x034\x02\x14\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x034\t\x0f\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x034\x12\x13\n\n\n\x02\
    \x04\x05\x12\x047\0:\x01\n\n\n\x03\x04\x05\x01\x12\x037\x08$\n\x0b\n\x04\
    \x04\x05\x02\0\x12\x038\x02\x1c\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x038\
    \x02\x10\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x038\x11\x17\n\x0c\n\x05\x04\
    \x05\x02\0\x03\x12\x038\x1a\x1b\n\x0b\n\x04\x04\x05\x02\x01\x12\x039\x02\
    (\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x039\x02\n\n\x0c\n\x05\x04\x05\x02\
    \x01\x06\x12\x039\x0b\x17\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x039\x18#\
    \n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x039&'\nI\n\x02\x04\x06\x12\x04=\0@\
    \x01\x1a=GatewayBatchGetUserConnectionReq\x20\xe6\x89\xb9\xe9\x87\x8f\
    \xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\
    \xe6\x8e\xa5\n\n\n\n\x03\x04\x06\x01\x12\x03=\x08(\n\x0b\n\x04\x04\x06\
    \x02\0\x12\x03>\x02\x1b\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03>\x02\x0f\n\
    \x0c\n\x05\x04\x06\x02\0\x01\x12\x03>\x10\x16\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03>\x19\x1a\n\x0b\n\x04\x04\x06\x02\x01\x12\x03?\x02\x1e\n\x0c\
    \n\x05\x04\x06\x02\x01\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\x06\x02\x01\
    \x05\x12\x03?\x0b\x11\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03?\x12\x19\n\
    \x0c\n\x05\x04\x06\x02\x01\x03\x12\x03?\x1c\x1d\n\n\n\x02\x04\x07\x12\
    \x04B\0E\x01\n\n\n\x03\x04\x07\x01\x12\x03B\x08)\n\x0b\n\x04\x04\x07\x02\
    \0\x12\x03C\x02\x1c\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03C\x02\x10\n\x0c\
    \n\x05\x04\x07\x02\0\x01\x12\x03C\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x03\
    \x12\x03C\x1a\x1b\n\x0b\n\x04\x04\x07\x02\x01\x12\x03D\x02(\n\x0c\n\x05\
    \x04\x07\x02\x01\x04\x12\x03D\x02\n\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\
    \x03D\x0b\x17\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03D\x18#\n\x0c\n\x05\
    \x04\x07\x02\x01\x03\x12\x03D&'\n\n\n\x02\x04\x08\x12\x04G\0I\x01\n\n\n\
    \x03\x04\x08\x01\x12\x03G\x08\"\n\x0b\n\x04\x04\x08\x02\0\x12\x03H\x02\
    \x1e\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x08\
    \x02\0\x05\x12\x03H\x0b\x11\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03H\x12\
    \x19\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03H\x1c\x1d\nK\n\x02\x04\t\x12\
    \x04L\0O\x01\x1a?GatewayGetConnectionByFilterReq\x20\xe6\xa0\xb9\xe6\x8d\
    \xae\xe8\xbf\x87\xe6\xbb\xa4\xe6\x9d\xa1\xe4\xbb\xb6\xe8\x8e\xb7\xe5\x8f\
    \x96\xe8\xbf\x9e\xe6\x8e\xa5\n\n\n\n\x03\x04\t\x01\x12\x03L\x08'\n\x0b\n\
    \x04\x04\t\x02\0\x12\x03M\x02\x1b\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03M\
    \x02\x0f\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03M\x10\x16\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03M\x19\x1a\n\x0b\n\x04\x04\t\x02\x01\x12\x03N\x02(\n\
    \x0c\n\x05\x04\t\x02\x01\x06\x12\x03N\x02\x1c\n\x0c\n\x05\x04\t\x02\x01\
    \x01\x12\x03N\x1d#\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03N&'\n\n\n\x02\
    \x04\n\x12\x04Q\0T\x01\n\n\n\x03\x04\n\x01\x12\x03Q\x08(\n\x0b\n\x04\x04\
    \n\x02\0\x12\x03R\x02\x1c\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03R\x02\x10\n\
    \x0c\n\x05\x04\n\x02\0\x01\x12\x03R\x11\x17\n\x0c\n\x05\x04\n\x02\0\x03\
    \x12\x03R\x1a\x1b\n\x0b\n\x04\x04\n\x02\x01\x12\x03S\x02(\n\x0c\n\x05\
    \x04\n\x02\x01\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03S\
    \x0b\x17\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03S\x18#\n\x0c\n\x05\x04\n\
    \x02\x01\x03\x12\x03S&'\n<\n\x02\x04\x0b\x12\x04W\0[\x01\x1a0GatewayWrit\
    eDataToWsReq\x20\xe5\x86\x99\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\xe5\x88\
    \xb0ws\xe8\xbf\x9e\xe6\x8e\xa5\n\n\n\n\x03\x04\x0b\x01\x12\x03W\x08\x1f\
    \n\x0b\n\x04\x04\x0b\x02\0\x12\x03X\x02\x1b\n\x0c\n\x05\x04\x0b\x02\0\
    \x06\x12\x03X\x02\x0f\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03X\x10\x16\n\
    \x0c\n\x05\x04\x0b\x02\0\x03\x12\x03X\x19\x1a\n\x0b\n\x04\x04\x0b\x02\
    \x01\x12\x03Y\x02(\n\x0c\n\x05\x04\x0b\x02\x01\x06\x12\x03Y\x02\x1c\n\
    \x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03Y\x1d#\n\x0c\n\x05\x04\x0b\x02\x01\
    \x03\x12\x03Y&'\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03Z\x02#\n\x0c\n\x05\
    \x04\x0b\x02\x02\x06\x12\x03Z\x02\x19\n\x0c\n\x05\x04\x0b\x02\x02\x01\
    \x12\x03Z\x1a\x1e\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03Z!\"\n\n\n\x02\
    \x04\x0c\x12\x04]\0`\x01\n\n\n\x03\x04\x0c\x01\x12\x03]\x08\x20\n\x0b\n\
    \x04\x04\x0c\x02\0\x12\x03^\x02\x1c\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\
    \x03^\x02\x10\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03^\x11\x17\n\x0c\n\x05\
    \x04\x0c\x02\0\x03\x12\x03^\x1a\x1b\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03_\
    \x02/\n\x0c\n\x05\x04\x0c\x02\x01\x04\x12\x03_\x02\n\n\x0c\n\x05\x04\x0c\
    \x02\x01\x06\x12\x03_\x0b\x17\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03_\
    \x18*\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03_-.\nC\n\x02\x04\r\x12\x04c\
    \0g\x01\x1a7GatewayWriteDataToWsWrapperReq\x20\xe5\x86\x99\xe5\x85\xa5\
    \xe6\x95\xb0\xe6\x8d\xae\xe5\x88\xb0ws\xe8\xbf\x9e\xe6\x8e\xa5\n\n\n\n\
    \x03\x04\r\x01\x12\x03c\x08&\n\x0b\n\x04\x04\r\x02\0\x12\x03d\x02\x1b\n\
    \x0c\n\x05\x04\r\x02\0\x06\x12\x03d\x02\x0f\n\x0c\n\x05\x04\r\x02\0\x01\
    \x12\x03d\x10\x16\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03d\x19\x1a\n\x0b\n\
    \x04\x04\r\x02\x01\x12\x03e\x02(\n\x0c\n\x05\x04\r\x02\x01\x06\x12\x03e\
    \x02\x1c\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03e\x1d#\n\x0c\n\x05\x04\r\
    \x02\x01\x03\x12\x03e&'\n\x0b\n\x04\x04\r\x02\x02\x12\x03f\x02#\n\x0c\n\
    \x05\x04\r\x02\x02\x06\x12\x03f\x02\x19\n\x0c\n\x05\x04\r\x02\x02\x01\
    \x12\x03f\x1a\x1e\n\x0c\n\x05\x04\r\x02\x02\x03\x12\x03f!\"\n,\n\x02\x04\
    \x0e\x12\x04j\0o\x01\x1a\x20GatewayKickWsReq\x20\xe8\xb8\xa2\xe5\x87\xba\
    ws\xe8\xbf\x9e\xe6\x8e\xa5\n\n\n\n\x03\x04\x0e\x01\x12\x03j\x08\x18\n\
    \x0b\n\x04\x04\x0e\x02\0\x12\x03k\x02\x1b\n\x0c\n\x05\x04\x0e\x02\0\x06\
    \x12\x03k\x02\x0f\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03k\x10\x16\n\x0c\n\
    \x05\x04\x0e\x02\0\x03\x12\x03k\x19\x1a\n\x0b\n\x04\x04\x0e\x02\x01\x12\
    \x03l\x02(\n\x0c\n\x05\x04\x0e\x02\x01\x06\x12\x03l\x02\x1c\n\x0c\n\x05\
    \x04\x0e\x02\x01\x01\x12\x03l\x1d#\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\
    \x03l&'\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03m\x02)\n\x0c\n\x05\x04\x0e\
    \x02\x02\x06\x12\x03m\x02\x1a\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03m\
    \x1b$\n\x0c\n\x05\x04\x0e\x02\x02\x03\x12\x03m'(\n\x0b\n\x04\x04\x0e\x02\
    \x03\x12\x03n\x02\x19\n\x0c\n\x05\x04\x0e\x02\x03\x05\x12\x03n\x02\x08\n\
    \x0c\n\x05\x04\x0e\x02\x03\x01\x12\x03n\t\x14\n\x0c\n\x05\x04\x0e\x02\
    \x03\x03\x12\x03n\x17\x18\n\n\n\x02\x04\x0f\x12\x04q\0t\x01\n\n\n\x03\
    \x04\x0f\x01\x12\x03q\x08\x19\n\x0b\n\x04\x04\x0f\x02\0\x12\x03r\x02\x1c\
    \n\x0c\n\x05\x04\x0f\x02\0\x06\x12\x03r\x02\x10\n\x0c\n\x05\x04\x0f\x02\
    \0\x01\x12\x03r\x11\x17\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03r\x1a\x1b\n\
    \x0b\n\x04\x04\x0f\x02\x01\x12\x03s\x02/\n\x0c\n\x05\x04\x0f\x02\x01\x04\
    \x12\x03s\x02\n\n\x0c\n\x05\x04\x0f\x02\x01\x06\x12\x03s\x0b\x17\n\x0c\n\
    \x05\x04\x0f\x02\x01\x01\x12\x03s\x18*\n\x0c\n\x05\x04\x0f\x02\x01\x03\
    \x12\x03s-.\n-\n\x02\x04\x10\x12\x04w\0y\x01\x1a!GatewayKeepAliveReq\x20\
    \xe4\xbf\x9d\xe6\x8c\x81\xe8\xbf\x9e\xe6\x8e\xa5\n\n\n\n\x03\x04\x10\x01\
    \x12\x03w\x08\x1b\n\x0b\n\x04\x04\x10\x02\0\x12\x03x\x02\x1b\n\x0c\n\x05\
    \x04\x10\x02\0\x06\x12\x03x\x02\x0f\n\x0c\n\x05\x04\x10\x02\0\x01\x12\
    \x03x\x10\x16\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03x\x19\x1a\n\n\n\x02\
    \x04\x11\x12\x04{\0}\x01\n\n\n\x03\x04\x11\x01\x12\x03{\x08\x1c\n\x0b\n\
    \x04\x04\x11\x02\0\x12\x03|\x02\x1c\n\x0c\n\x05\x04\x11\x02\0\x06\x12\
    \x03|\x02\x10\n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03|\x11\x17\n\x0c\n\x05\
    \x04\x11\x02\0\x03\x12\x03|\x1a\x1b\n\x0b\n\x02\x06\0\x12\x05\x7f\0\x97\
    \x01\x01\n\n\n\x03\x06\0\x01\x12\x03\x7f\x08\x16\nm\n\x04\x06\0\x02\0\
    \x12\x04\x82\x01\x02c\x1a_\x20GatewayGetUserConnection\x20\xe8\x8e\xb7\
    \xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\xe6\x8e\xa5\
    \n\x20\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\
    \x91\x98\xe4\xb8\x8d\xe5\xbb\xba\xe8\xae\xae\xe4\xbf\xae\xe6\x94\xb9\xe6\
    \xad\xa4\xe5\xa4\x84\xe9\x80\xbb\xe8\xbe\x91\n\n\r\n\x05\x06\0\x02\0\x01\
    \x12\x04\x82\x01\x06\x1e\n\r\n\x05\x06\0\x02\0\x02\x12\x04\x82\x01\x1f:\
    \n\r\n\x05\x06\0\x02\0\x03\x12\x04\x82\x01Ea\nx\n\x04\x06\0\x02\x01\x12\
    \x04\x85\x01\x02r\x1aj\x20GatewayBatchGetUserConnection\x20\xe6\x89\xb9\
    \xe9\x87\x8f\xe8\x8e\xb7\xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\
    \xe8\xbf\x9e\xe6\x8e\xa5\n\x20\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\
    \x8f\x91\xe4\xba\xba\xe5\x91\x98\xe5\xbb\xba\xe8\xae\xae\xe4\xb8\x8d\xe4\
    \xbf\xae\xe6\x94\xb9\xe6\xad\xa4\xe5\xa4\x84\xe9\x80\xbb\xe8\xbe\x91\n\n\
    \r\n\x05\x06\0\x02\x01\x01\x12\x04\x85\x01\x06#\n\r\n\x05\x06\0\x02\x01\
    \x02\x12\x04\x85\x01$D\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\x85\x01Op\nz\
    \n\x04\x06\0\x02\x02\x12\x04\x88\x01\x02o\x1al\x20GatewayGetConnectionBy\
    Filter\x20\xe9\x80\x9a\xe8\xbf\x87\xe6\x9d\xa1\xe4\xbb\xb6\xe8\x8e\xb7\
    \xe5\x8f\x96\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\xe6\x8e\xa5\
    \n\x20\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\
    \x91\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xa2\x9e\xe5\x8a\xa0\xe8\xbf\x87\xe6\
    \xbb\xa4\xe6\x9d\xa1\xe4\xbb\xb6\n\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\
    \x88\x01\x06\"\n\r\n\x05\x06\0\x02\x02\x02\x12\x04\x88\x01#B\n\r\n\x05\
    \x06\0\x02\x02\x03\x12\x04\x88\x01Mm\nr\n\x04\x06\0\x02\x03\x12\x04\x8b\
    \x01\x02W\x1ad\x20GatewayWriteDataToWs\x20\xe5\x90\x91\xe7\x94\xa8\xe6\
    \x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\xe6\x8e\xa5\xe5\x86\x99\xe5\x85\xa5\xe6\
    \x95\xb0\xe6\x8d\xae\n\x20\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\
    \x91\xe4\xba\xba\xe5\x91\x98\xe4\xb8\x8d\xe5\xbb\xba\xe8\xae\xae\xe4\xbf\
    \xae\xe6\x94\xb9\xe6\xad\xa4\xe5\xa4\x84\xe9\x80\xbb\xe8\xbe\x91\n\n\r\n\
    \x05\x06\0\x02\x03\x01\x12\x04\x8b\x01\x06\x1a\n\r\n\x05\x06\0\x02\x03\
    \x02\x12\x04\x8b\x01\x1b2\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\x8b\x01=U\
    \ny\n\x04\x06\0\x02\x04\x12\x04\x8e\x01\x02e\x1ak\x20GatewayWriteDataToW\
    sWrapper\x20\xe5\x90\x91\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\
    \xe6\x8e\xa5\xe5\x86\x99\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\n\x20\xe4\
    \xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\xe4\
    \xb8\x8d\xe5\xbb\xba\xe8\xae\xae\xe4\xbf\xae\xe6\x94\xb9\xe6\xad\xa4\xe5\
    \xa4\x84\xe9\x80\xbb\xe8\xbe\x91\n\n\r\n\x05\x06\0\x02\x04\x01\x12\x04\
    \x8e\x01\x06!\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\x8e\x01\"@\n\r\n\x05\
    \x06\0\x02\x04\x03\x12\x04\x8e\x01Kc\n\xb3\x01\n\x04\x06\0\x02\x05\x12\
    \x04\x92\x01\x02B\x1a\xa4\x01\x20GatewayKickWs\x20\xe8\xb8\xa2\xe5\x87\
    \xba\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe8\xbf\x9e\xe6\x8e\xa5\n\x20\
    \xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\xe5\x91\x98\
    \xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8\xe6\xad\xa4\xe5\xa4\x84\xe4\xbf\xae\
    \xe6\x94\xb9\xe8\xb8\xa2\xe5\x87\xba\xe7\x94\xa8\xe6\x88\xb7\xe8\xbf\x9e\
    \xe6\x8e\xa5\xe7\x9a\x84\xe9\x80\xbb\xe8\xbe\x91\n\x20\xe6\xaf\x94\xe5\
    \xa6\x82\xe8\xb8\xa2\xe5\x87\xba\xe8\xbf\x9e\xe6\x8e\xa5\xe4\xb9\x8b\xe5\
    \x89\x8d\xef\xbc\x8c\xe5\x85\x88\xe7\xbb\x99\xe7\x94\xa8\xe6\x88\xb7\xe5\
    \x8f\x91\xe9\x80\x81\xe4\xb8\x80\xe6\x9d\xa1\xe6\xb6\x88\xe6\x81\xaf\n\n\
    \r\n\x05\x06\0\x02\x05\x01\x12\x04\x92\x01\x06\x13\n\r\n\x05\x06\0\x02\
    \x05\x02\x12\x04\x92\x01\x14$\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x92\
    \x01/@\n\xce\x01\n\x04\x06\0\x02\x06\x12\x04\x96\x01\x02K\x1a\xbf\x01\
    \x20KeepAlive\x20\xe4\xbf\x9d\xe6\x8c\x81\xe8\xbf\x9e\xe6\x8e\xa5\n\x20\
    \xe5\xae\xa2\xe6\x88\xb7\xe7\xab\xaf\xe5\xbf\x85\xe9\xa1\xbb\xe6\xaf\x8f\
    \xe9\x9a\x94\x20config.Websocket.KeepAliveSecond\x20\xe7\xa7\x92\xe5\x8f\
    \x91\xe9\x80\x81\xe4\xb8\x80\xe6\xac\xa1\xe5\xbf\x83\xe8\xb7\xb3\xe5\x8c\
    \x85\n\x20\xe4\xba\x8c\xe6\xac\xa1\xe5\xbc\x80\xe5\x8f\x91\xe4\xba\xba\
    \xe5\x91\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8\xe8\xbf\x99\xe9\x87\x8c\
    \xe4\xbf\xae\xe6\x94\xb9\xe9\x80\xbb\xe8\xbe\x91\xef\xbc\x8c\xe6\xaf\x94\
    \xe5\xa6\x82\xe4\xb8\x80\xe8\x87\xb4\xe6\x80\xa7\xe7\xae\x97\xe6\xb3\x95\
    \xe5\xae\x89\xe5\x85\xa8\xe6\xa0\xa1\xe9\xaa\x8c\xe7\xad\x89\n\n\r\n\x05\
    \x06\0\x02\x06\x01\x12\x04\x96\x01\x06\x16\n\r\n\x05\x06\0\x02\x06\x02\
    \x12\x04\x96\x01\x17*\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x96\x015Ib\x06\
    proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(18);
            messages.push(GatewayApiRequest::generated_message_descriptor_data());
            messages.push(GatewayApiResponse::generated_message_descriptor_data());
            messages.push(GatewayWriteDataContent::generated_message_descriptor_data());
            messages.push(WsConnection::generated_message_descriptor_data());
            messages.push(GatewayGetUserConnectionReq::generated_message_descriptor_data());
            messages.push(GatewayGetUserConnectionResp::generated_message_descriptor_data());
            messages.push(GatewayBatchGetUserConnectionReq::generated_message_descriptor_data());
            messages.push(GatewayBatchGetUserConnectionResp::generated_message_descriptor_data());
            messages.push(GatewayGetConnectionFilter::generated_message_descriptor_data());
            messages.push(GatewayGetConnectionByFilterReq::generated_message_descriptor_data());
            messages.push(GatewayGetConnectionByFilterResp::generated_message_descriptor_data());
            messages.push(GatewayWriteDataToWsReq::generated_message_descriptor_data());
            messages.push(GatewayWriteDataToWsResp::generated_message_descriptor_data());
            messages.push(GatewayWriteDataToWsWrapperReq::generated_message_descriptor_data());
            messages.push(GatewayKickWsReq::generated_message_descriptor_data());
            messages.push(GatewayKickWsResp::generated_message_descriptor_data());
            messages.push(GatewayKeepAliveReq::generated_message_descriptor_data());
            messages.push(GatewayKeepAliveResp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(GatewayWriteDataType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
